\begin{ccRefClass} {Point_2<Kernel>}

\ccDefinition
An object of the class \ccRefName\ is a point in the two-dimensional
Euclidean plane $\E^2$. 

Remember that \ccStyle{Kernel::RT} and \ccStyle{Kernel::FT} denote a
\ccc{RingNumberType} and a \ccc{FieldNumberType}, respectively. For the kernel
model \ccStyle{Cartesian<T>}, the two types are the same. For the
kernel model \ccStyle{Homogeneous<T>}, \ccStyle{Kernel::RT} is equal
to \ccStyle{T}, and \ccStyle{Kernel::FT} is equal to
\ccStyle{Quotient<T>}.

\ccTypes
\ccThree{Cartesian_const_iterator}{Facet }{}
\ccThreeToTwo

\ccNestedType{Cartesian_const_iterator}{An iterator for enumerating the
      \ccHtmlNoLinksFrom{Cartesian} coordinates of a point.}

\ccCreation
\ccCreationVariable{p}


\ccHidden \ccConstructor{Point_2();}
             {introduces an uninitialized variable \ccVar.}

\ccHidden \ccConstructor{Point_2(const Point_2<Kernel> &q);}
            {copy constructor.}

\ccConstructor{Point_2(const Origin &ORIGIN);}
            {introduces a variable \ccVar\ with \ccHtmlNoLinksFrom{Cartesian} coordinates
              $(0,0)$.}

\ccConstructor{Point_2(int x, int y);}
            {introduces a point \ccVar\ initialized to $(x,y)$.}

\ccConstructor{Point_2(double x, double y);}
            {introduces a point \ccVar\ initialized to $(x,y)$
             provided \ccc{RT} supports construction from \ccc{double}.}

\ccConstructor{Point_2(const Kernel::RT &hx, const Kernel::RT &hy, const Kernel::RT &hw = RT(1));}
            {introduces a point \ccVar\ initialized to $(hx/hw,hy/hw)$.
             \ccPrecond{\ccc{hw} $\neq$ \ccc{Kernel::RT(0)}.} }

\ccConstructor{Point_2(const Kernel::FT &x, const Kernel::FT &y);}
            {introduces a point \ccVar\ initialized to $(x,y)$.}


\ccOperations
%\ccSetTwoOfThreeColumns{5cm}{4cm}

\ccHidden \ccMethod{Point_2<Kernel> & operator=(const Point_2<Kernel> &q);}
        {Assignment.}

\ccMethod{bool operator==(const Point_2<Kernel> &q) const;}
       {Test for equality. Two points are equal, iff their $x$ and $y$ 
        coordinates are equal. The point can be compared with
                \ccc{ORIGIN}.}

\ccMethod{bool operator!=(const Point_2<Kernel> &q) const;}
       {Test for inequality. The point can be compared with \ccc{ORIGIN}.}

There are two sets of coordinate access functions, namely to the
homogeneous and to the \ccHtmlNoLinksFrom{Cartesian} coordinates. They can be used
independently from the chosen kernel model.

\ccMethod{Kernel::RT hx() const;}
       {returns the homogeneous $x$ coordinate.}
\ccGlue
\ccMethod{Kernel::RT hy() const;}
       {returns the homogeneous $y$ coordinate.}
\ccGlue
\ccMethod{Kernel::RT hw() const;}
       {returns the homogenizing  coordinate.}
       
Note that you do not loose information with the homogeneous
representation, because the \ccc{FieldNumberType} is a quotient.

\ccMethod{Kernel::FT x() const;}
       {returns the \ccHtmlNoLinksFrom{Cartesian} $x$ coordinate, that is $hx/hw$.}
\ccGlue
\ccMethod{Kernel::FT y() const;}
       {returns the \ccHtmlNoLinksFrom{Cartesian} $y$ coordinate, that is $hy/hw$.}
       
The following operations are for convenience and for compatibility
with higher dimensional points. Again they come in a
\ccHtmlNoLinksFrom{Cartesian} and in a homogeneous flavor.

\ccMethod{Kernel::RT homogeneous(int i) const;}
       {returns the i'th homogeneous coordinate of \ccVar, starting with 0.
        \ccPrecond{$0\leq i \leq 2$.}}

\ccMethod{Kernel::FT cartesian(int i) const;}
       {returns the i'th \ccHtmlNoLinksFrom{Cartesian} coordinate of \ccVar, starting with 0.
        \ccPrecond{$0\leq i \leq 1$.}}


\ccMethod{Kernel::FT operator[](int i) const;}
       {returns \ccStyle{cartesian(i)}.
        \ccPrecond{$0\leq i \leq 1$.}}

\ccMethod{Cartesian_const_iterator cartesian_begin() const;}
       {returns an iterator to the \ccHtmlNoLinksFrom{Cartesian} coordinates 
        of \ccVar, starting with the 0th coordinate.}

\ccMethod{Cartesian_const_iterator cartesian_end() const;}
       {returns an off the end iterator to the \ccHtmlNoLinksFrom{Cartesian} 
        coordinates of \ccVar.}

\ccMethod{int dimension() const;}
       {returns the dimension (the constant 2).}

\ccMethod{Bbox_2 bbox() const;}
       {returns a bounding box containing \ccVar. Note that bounding boxes
        are not parameterized with whatsoever. }

\ccMethod{Point_2<Kernel>  transform(const Aff_transformation_2<Kernel> &t) const;}
       {returns the point obtained by applying $t$ on \ccVar.}


\ccHeading{Operators}

The following operations can be applied on points:

\ccFunction{bool operator<(const Point_2<Kernel> &p,
                           const Point_2<Kernel> &q);}
       {returns true iff \ccc{p} is lexicographically smaller than \ccc{q},
       i.e. either if \ccc{p.x() < q.x()} or if \ccc{p.x() == q.x()} and
       \ccc{p.y() < q.y()}.}

\ccFunction{bool operator>(const Point_2<Kernel> &p,
                           const Point_2<Kernel> &q);}
       {returns true iff \ccc{p} is lexicographically greater than \ccc{q}.}

\ccFunction{bool operator<=(const Point_2<Kernel> &p,
                           const Point_2<Kernel> &q);}
       {returns true iff \ccc{p} is lexicographically smaller or equal to \ccc{q}.}

\ccFunction{bool operator>=(const Point_2<Kernel> &p,
                           const Point_2<Kernel> &q);}
       {returns true iff \ccc{p} is lexicographically greater or equal to \ccc{q}.}

\ccFunction{Vector_2<Kernel> operator-(const Point_2<Kernel> &p,
                                  const Point_2<Kernel> &q);}
       {returns the difference vector between \ccStyle{q} and \ccStyle{p}. 
        You can substitute \ccc{ORIGIN} for either \ccc{p} or \ccc{q},
        but not for both.}

\ccFunction{Point_2<Kernel> operator+(const Point_2<Kernel> &p,
                                 const Vector_2<Kernel> &v);}
       {returns the point obtained by translating \ccStyle{p} by the 
        vector \ccStyle{v}.}

\ccFunction{Point_2<Kernel> operator-(const Point_2<Kernel> &p,
                                 const Vector_2<Kernel> &v);}
       {returns the point obtained by translating \ccStyle{p} by the 
        vector -\ccStyle{v}.}

\ccExample

The following declaration creates two points with
\ccHtmlNoLinksFrom{Cartesian} double coordinates.

\begin{cprog}

  Point_2< Cartesian<double> > p, q(1.0, 2.0);
\end{cprog} 

The variable {\tt p} is uninitialized and should first be used on 
the left hand side of an assignment. 
\begin{cprog}

  p = q;

  std::cout << p.x() << "  " << p.y() << std::endl; 
\end{cprog} 


\ccSeeAlso
\ccRefConceptPage{Kernel::Point_2}

\end{ccRefClass} 
