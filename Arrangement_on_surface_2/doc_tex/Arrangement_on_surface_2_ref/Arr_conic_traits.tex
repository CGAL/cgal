% +------------------------------------------------------------------------+
% | Reference manual page: Arr_conic_traits.tex
% +------------------------------------------------------------------------+
% | 
% | Package: Arrangement_2
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin
\begin{ccRefClass}{Arr_conic_traits_2<RatKernel,AlgKernel,NtTraits>}

\ccDefinition
%============

The class \ccRefName\ is a model of the \ccc{ArrangementTraits_2} concept
and can be used to construct and maintain arrangements of bounded segments of
algebraic curves of degree $2$ at most, also known as {\sl conic curves}.

A general conic curve $C$ is the locus of all points $(x,y)$ satisfying the
equation: $r x^2 + s y^2 + t x y + u x + v y + w = 0$, where: 
\begin{itemize}
\item If $4 r s - t^2 > 0$, $C$ is an ellipse.
      A special case occurs when $r = s$ and $t = 0$, when $C$
      becomes a circle. 
\item If $4 r s - t^2 < 0$, $C$ is a hyperbola. 
\item If $4 r s - t^2 = 0$, $C$ is a parabola.
      A degenerate case occurs when $r = s = t = 0$, when $C$ is a line.
\end{itemize}

A {\sl bounded conic arc} is defined as either of the following: 
\begin{itemize}
\item A full ellipse (or a circle) $C$. 
\item The tuple $\langle C, p_s, p_t, o \rangle$, where $C$ is the supporting
      conic curve, with the arc endpoints being $p_s$ and $p_t$ 
      (the source and target points, respectively). The orientation $o$  
      indicates whether we proceed from $p_s$ to $p_t$ in a clockwise or in a
      counterclockwise direction. Note that $C$ may also
      correspond to a line or to pair of lines --- in this case $o$ may
      specify a \ccc{COLLINEAR} orientation.
\end{itemize}

A very useful subset of the set of conic arcs are line segments and circular
arcs, as arrangements of circular arcs and line segments have some
interesting applications (e.g. offsetting polygons, motion planning for a
disc robot, etc.). Circular arcs and line segment are simpler objects and can
be dealt with more efficiently than arbitrary arcs. For these reasons, it is
possible to construct conic arcs from segments and from circles. Using these
constructors is highly recommended: It is more straightforward and also speeds 
up the arrangement  construction. However, in case the set of input curves
contain only circular arcs and line segments, it is recommended to use the
\ccc{Arr\_circle\_segment\_2} class to achieve faster running times.

In our representation, all conic coefficients (namely $r, s, t, u, v, w$)
must be rational numbers. This guarantees that the coordinates of all
arrangement vertices (in particular, those representing instersection
points) are algebraic numbers of degree $4$ (a real number $\alpha$
is an algebraic number of degree $d$ if there exist a polynomial $p$ with
{\sl integer} coefficient of degree $d$ such that $p(\alpha) = 0$).
We therefore require separate representations of the curve coefficients and
the point coordiantes. The \ccc{NtTraits} should be instantiated with a class
that defines nested \ccc{Integer}, \ccc{Rational} and \ccc{Algebraic}
number types and supports various operations on them, yielding certified
computation results (for example, it can convert rational numbers to algebraic
numbers and can compute roots of polynomials with integer coefficients).
The other template parameters, \ccc{RatKernel} and \ccc{AlgKernel} should be
geometric kernels templated with the \ccc{NtTraits::Rational} and
\ccc{NtTraits::Algebraic} number types, repectively.
It is recommended to instantiate the \ccc{CORE_algebraic_number_traits}
class as the \ccc{NtTraits} parameter, with
\ccc{Cartesian<NtTraits::Rational>} and \ccc{Cartesian<NtTraits::Algebraic>}
instantiating the two kernel types, respectively.
The number types in this case are provided by the {\sc Core} library, with its
ability to exactly represent simple algebraic numbers.

The traits class inherits its point type from \ccc{AlgKernel::Point_2},
and defines a curve and $x$-monotone curve types, as detailed below.

\ccInclude{CGAL/Arr_conic_traits_2.h}
 
\ccIsModel
    \ccc{ArrangementTraits_2} \\
    \ccc{ArrangementLandmarkTraits_2} \\

\ccTypes
%-------

\ccNestedType{Rational}{the \ccc{NtTraits::Rational} type
                        (and also the \ccc{RatKernel::FT} type).}

\ccNestedType{Algebraic}{the \ccc{NtTraits::Algebraic} type
                         (and also the \ccc{AlgKernel::FT} type).}

\subsection*{Class 
        Arr\_conic\_traits\_2$<$RatKernel,AlgKernel,NtTraits$>$::Curve\_2}
%=========================================================================

The \ccc{Curve_2} class nested within the conic-arc traits can represent
arbitrary conic arcs and support their construction in various ways.
The copy and default constructor as well as the assignment operator are
provided for conic arcs. In addition, an \ccc{operator<<}
for the curves is defined for standard output streams.

\begin{ccClass}{Arr_conic_traits_2<RatKernel,AlgKernel,NtTraits>::Curve_2}

\ccCreation
\ccCreationVariable{a}
%---------------------

\ccConstructor{Curve_2 (const typename RatKernel::Segment_2& seg);}
    {constructs an arc corresponding to the line segment \ccc{seg}.}

\ccConstructor{Curve_2 (const typename RatKernel::Circle_2& circ);}
    {constructs an arc corresponding to the full circle \ccc{circ}
     (note that this circle has a center point with rational coordinates
     and rational squared radius).}

\ccConstructor{Curve_2 (const typename RatKernel::Circle_2& circ,
                        Orientation o,
                        const Point_2& ps,
                        const Point_2& pt);}
    {constructs a circular arc supported by the circle \ccc{circ}, going
     in the given orientation \ccc{o} from the source point \ccc{ps} to
     its target point \ccc{pt}.
     \ccPrecond{\ccc{ps} and \ccc{pt} both lie on the circle \ccc{circ}.}
     \ccPrecond{\ccc{o} is not \ccc{COLLINEAR}.}}

\ccConstructor{Curve_2 (const typename RatKernel::Point_2& p1,
                        const typename RatKernel::Point_2& p2,
                        const typename RatKernel::Point_2& p3);}
    {constructs a circular arc going from \ccc{p1} (its source point)
     through \ccc{p2} to \ccc{p3} (its target point). Note that all three
     points have rational coordinates. The orientation of the arc is
     determined automatically.
     \ccPrecond{The three points are not collinear.}}

\ccConstructor{Curve_2 (const Rational& r, const Rational& s,
                        const Rational& t, const Rational& u,
                        const Rational& v, const Rational& w);}
    {constructs a conic arc that corresponds to the full conic curve
     $r x^2 + s y^2 + t x y + u x + v y + w = 0$.
     \ccPrecond{As a conic arc must be bounded, the given curve must be
                an ellipse, that is $4 r s - t^2 > 0$.}}

\ccConstructor{Curve_2 (const Rational& r, const Rational& s,
                        const Rational& t, const Rational& u,
                        const Rational& v, const Rational& w,
                        Orientation o,
                        const Point_2& ps,
                        const Point_2& pt);}
    {constructs a conic arc supported by the conic curve 
     $r x^2 + s y^2 + t x y + u x + v y + w = 0$, going
     in the given orientation \ccc{o} from the source point \ccc{ps} to
     its target point \ccc{pt}.
     \ccPrecond{\ccc{ps} and \ccc{pt} both satisfy the equation of the
                supporting conic curve and define a bounded segment of this
                curve (e.g. in case of a hyperbolic arc, both point should
                be located on the same branch of the hyperbola).}
     \ccPrecond{\ccc{o} is not \ccc{COLLINEAR} if the supporting conic is
                curves, and must be \ccc{COLLINEAR} if it is not curved
                (a line or a line-pair).}}

\ccConstructor{Curve_2 (const typename RatKernel::Point_2& p1,
                        const typename RatKernel::Point_2& p2,
                        const typename RatKernel::Point_2& p3,
                        const typename RatKernel::Point_2& p4,
                        const typename RatKernel::Point_2& p5);}
    {constructs a conic arc going from \ccc{p1} (its source point)
     through \ccc{p2}, \ccc{p3} and \ccc{p4} (in this order) to \ccc{p5}
     (its target point). Note that all five points have rational coordinates.
     The orientation of the arc is determined automatically.
     \ccPrecond{No three points of the five are not collinear.}
     \ccPrecond{The five points define a valid arc, in their given order.}}

\ccConstructor{Curve_2 (const Rational& r, const Rational& s,
                        const Rational& t, const Rational& u,
                        const Rational& v, const Rational& w,
                        Orientation o,
                        const Point_2& app_ps,
                        const Rational& r1, const Rational& s1,
                        const Rational& t1, const Rational& u1,
                        const Rational& v1, const Rational& w1,
                        const Point_2& app_pt,
                        const Rational& r2, const Rational& s2,
                        const Rational& t2, const Rational& u2,
                        const Rational& v2, const Rational& w2);}
    {constructs a conic arc supported by the conic curve 
     $r x^2 + s y^2 + t x y + u x + v y + w = 0$, going
     in the given orientation \ccc{o} from its source point to its target
     point. In this case only some approximations of the endpoints
     (\ccc{app_ps} and \ccc{app_pt}, repsectively) is available,
     and their exact locations are given implicitly, specified by the
     intersections of the supporting conic curve with 
     $r_1 x^2 + s_1 y^2 + t_1 x y + u_1 x + v_1 y + w_1 = 0$ and
     $r_2 x^2 + s_2 y^2 + t_2 x y + u_2 x + v_2 y + w_2 = 0$, repsectively.
     \ccPrecond{The two auxiliary curves specifying the endpoints really
                intersect with the supporting conic curve, such that
                the arc endpoints define a bounded segment of the supporting
                curve (e.g. in case of a hyperbolic arc, both point should
                be located on the same branch of the hyperbola).}
     \ccPrecond{\ccc{o} is not \ccc{COLLINEAR} if the supporting conic is
                curves, and must be \ccc{COLLINEAR} if it is not curved
                (a line or a line-pair).}}

\ccAccessFunctions
%-----------------

\ccThree{Orientation~~}{}{\hspace*{8.5cm}}

\ccMethod{bool is_valid() const;}
  {indicates whether \ccVar{} is a valid conic arc. As the precondition to
   some of the constructor listed above are quite complicated, their
   violation does not cause the program to abort. Instead, the constructed
   arc is invalid (a defaultly constructed arc is also invalid).
   It is however recommended to check that a constructed arc is valid before
   inserting it to an arrangement, as this operation {\sl will} cause the
   program to abort.}

\ccMethod{bool is_x_monotone() const;}
  {determines whether the arc is $x$-monotone, namely each vertical line
   intersects it at most once. A vertical line segment is also considered
   (weakly) $x$-monotone.}

\ccMethod{bool is_y_monotone() const;}
  {determines whether the arc is $y$-monotone, namely each horizontal line
   intersects it at most once. A horizontal line segment is also considered
   (weakly) $x$-monotone.}

\ccMethod{bool is_full_conic() const;}
  {indicates whether the arc represents a full conic curve (en ellipse or
   a circle).}

The six following methods return the coefficients of the supported conic,
after their conversion to integer number (reprsented by the \ccc{Integer}
type of the \ccc{NtTraits} class):

\ccThree{typename NtTraits::Integer}{}{\hspace*{8.5cm}}

\ccMethod{const typename NtTraits::Integer& r() const;}
  {returns the coefficient of $x^2$.}
\ccGlue
\ccMethod{const typename NtTraits::Integer& s() const;}
  {returns the coefficient of $t^2$.}
\ccGlue
\ccMethod{const typename NtTraits::Integer& t() const;}
  {returns the coefficient of $x y$.}
\ccGlue
\ccMethod{const typename NtTraits::Integer& u() const;}
  {returns the coefficient of $x$.}
\ccGlue
\ccMethod{const typename NtTraits::Integer& v() const;}
  {returns the coefficient of $y$.}
\ccGlue
\ccMethod{const typename NtTraits::Integer& w() const;}
  {returns the free coefficient.}

\ccThree{Orientation~~}{}{\hspace*{8.5cm}}

\ccMethod{const Point_2& source() const;}
  {returns the source point of the arc.
   \ccPrecond{\ccVar{} is not a full conic curve.}}
\ccGlue
\ccMethod{const Point_2& target() const;}
  {returns the target point of the arc.
   \ccPrecond{\ccVar{} is not a full conic curve.}}

\ccMethod{Orientation orientation() const;}
  {returns the orientation of the arc.}

\ccMethod{Bbox_2 bbox() const;}
  {return a bounding box of the arc \ccVar{}.}


\ccOperations
%------------

\ccMethod{void set_source (const Point_2 & ps);}
  {sets a new source point for the conic arc.
   \ccPrecond{\ccc{ps} lies on the supporting conic of \ccVar{}.}}
\ccGlue
\ccMethod{void set_target (const Point_2 & pt);}
  {sets a new target point for the conic arc.
   \ccPrecond{\ccc{pt} lies on the supporting conic of \ccVar{}.}}

\end{ccClass}

\subsection*{Class 
Arr\_conic\_traits\_2$<$RatKernel,AlgKernel,NtTraits$>$::X\_monotone\_curve\_2}
%==============================================================================

The \ccc{X_monotone_curve_2} class nested within the conic-arc traits is
used to represent $x$-monotone conic arcs. It inherits from the \ccc{Curve_2}
type, therefore supports the access methods and the operations listed above.

For efficiency reasons, we recommend users not to construct $x$-monotone
conic arc directly, but rather use the \ccc{Make_x_monotone_2} functor
supplied by the conic-arc traits class to convert conic curves to
$x$-monotone curves.

\begin{ccClass}{Arr_conic_traits_2<RatKernel,AlgKernel,NtTraits>::
                X_monotone_curve_2}

\ccCreation
\ccCreationVariable{xa}
%---------------------

\ccConstructor{X_monotone_curve_2 (const Curve_2& arc);}
    {converts the given arc to an $x$-monotone arc.
     \ccPrecond{\ccc{arc} is $x$-monotone.}}

\ccAccessFunctions
%-----------------

\ccMethod{const Point_2& left() const;}
  {returns the left (lexicographically smaller) endpoint of \ccVar{}.}
\ccGlue
\ccMethod{const Point_2& right() const;}
  {returns the right (lexicographically larger) endpoint of \ccVar{}.}

\end{ccClass}

\end{ccRefClass}

\ccRefPageEnd
