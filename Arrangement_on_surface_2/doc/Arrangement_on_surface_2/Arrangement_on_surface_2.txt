namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_2D_Arrangements
\anchor chapterArrangement_on_surface_2
\cgalAutoToc

\authors Ron Wein, Eric Berberich, Efi Fogel, Dan Halperin,
Michael Hemmer, Oren Salzman, and Baruch Zukerman

\section aos_sec-intro Introduction

Geometric arrangements, or arrangements for short, are subdivisions of
some space induced by geometric objects. Figure
\cgalFigureRef{aos_fig-simple_arr} shows an arrangement of two curves
\f$C_1\f$ and \f$C_2\f$ in the plane. It has three faces&mdash;two
bounded faces \f$f_1\f$ and \f$f_2\f$ (filled with diagonal-stripe
patterns) and an unbounded face. The arrangement has seven
vertices&mdash;four represent the endpoints of \f$C_1\f$ and \f$C_2\f$
(drawn as small discs), and three represent the intersection points of
the two curves (drawn as small rings). The arrangement also has eight
edges, each of which is a maximal portion of one curve not
intersecting the other.
\cgalFigureBegin{aos_fig-simple_arr,simple_arr.png}
\cgalFigureEnd

Arrangements are not restricted to curves in the plane. There are
useful arrangements in three and higher dimensions (these are not so
easy to visualize) and they can be induced by geometric objects of any
type, such as spheres, simplices, polytopes, or B&eacute;zier
surfaces. This package provides a data structure that represents a
two-dimensional arrangement of curves embedded on an orientable
parametric surface in three dimensional space, such as a plane, a
cylinder, a sphere, a tori, or a surface homeomorphic to them. This
package also provides operations that construct and manipulate such
arrangements.  Arrangements are ubiquitous in the
computational-geometry literature and have many applications; see,
e.g., \cgalCite{as-aa-00}, \cgalCite{cgal:bfhks-apsca-10},
\cgalCite{cgal:bfhmw-apsgf-10}, and \cgalCite{cgal:h-a-04}.

\subsection aos_ssec-intro-sep Separation of Topology and Geometry

The use of the generic programming paradigm enables a convenient
separation of the topology and the geometry of data
structures.\cgalFootnote{In this context, we sometimes say
<em>combinatorics</em> instead of topology, and say <em>algebra</em> or
<em>numerics</em> instead of geometry. We always mean the same
thing---the separation of the abstract, graph-like structure (the
topology) from the actual embedding in the plane (the geometry).}
This is a key aspect in the design of geometric software, and is put
into practice, for example, in the design of \cgal polyhedra, \cgal
triangulations, and our \cgal arrangements. This separation allows the
convenient abstraction of algorithms and data structures in
combinatorial and topological terms, regardless of the specific
geometry of the objects at hand. This abstraction is realized through
class and function templates that represent specific data structures
and algorithmic frameworks, respectively. Consider the class template

<code>
template <typename GeometryTraits, typename Dcel>
class Arrangement_2 { ... };
</code>

An instance of this template represents an arrangement embedded in the
plane. When the template is instantiated the `GeometryTraits`
parameter must be substituted with a type that defines a set of
geometric-object types, such as point and curve, and a set of
operations on objects of these types (see Section \ref
aos_sec-geom_traits); the `Dcel` parameter must be substituted with a
type that represents a doubly-connected edge list (\sc{Dcel}) data
structure. It defines topological-object types, such as vertices,
edges, and faces, and the operations required to maintain the
incidence relations among objects of these types (see Section \ref
aos_ssec-basic-dcel).

The class template `Arrangement_2` derives from the following class
template:

<code>
template <typename GeometryTraits, typename TopologyTraits>
class Arrangement_on_surface_2 { ... };
</code>

An instance of this template represents a two-dimensional arrangement
embedded on a surface in three dimensional space. When the template is
instantiated the `GeometryTraits` parameter must be substituted as
described above; the `TopologyTraits` parameter must be substituted
with a type that deals with the topology of the surface (see Section
\ref aos_sec-topol_traits). In particular, it maintains a
representation of the arrangement planar graph using an extended
doubly-connected edge list (\sc{EDcel}) data-structure suitable for
the particular topology.

An immediate advantage of the separation of the topology and the
geometry of data structures is that users with limited expertise in
computational geometry can employ the data structure with their own
special type of objects. They must, however, supply the relevant
traits class, which mainly involves algebraic computations. A traits
class also encapsulates the number types used to represent coordinates
of geometric objects and to carry out algebraic operations on them. It
encapsulates the type of coordinate system used (e.g., Cartesian and
homogeneous), and the geometric or algebraic computation methods
themselves. The precise set of requirements, the actual traits classes
must conform to, are organized as a hierarchy of compact concepts; see
Section \ref aos_sec-geom_traits.

\subsection aos_ssec-intro-well_behaved Well-Behaved Curves

What constitutes valid curves that can be handled by the
\ref PkgArrangement2Summary package is discussed in detail in Section
\ref aos_sec-geom_traits, where the models of the traits classes are
described. However, when we cite combinatorial complexity bounds or
bounds on the resources (running time, storage) required by
algorithms, we often postulate stricter assumptions on the input
curves. The prevalent term in use is that the curves are <em>well
behaved</em>, which may have different interpretations in different
settings. If we are concerned with combinatorial complexity bounds for
curves in the plane, then the standard assumptions are that (i) each
curve is non-self-intersecting (so-called Jordan arc) and (ii) every
pair of curves intersects in at most some constant number of
points. For algorithmic purposes we need to require more since we
assume that any operation on a small constant number of curves takes
unit time. In this sense arcs of algebraic curves of degree bounded by
a constant (namely the zero set of bivariate polynomials of constant
maximum total degree) are well behaved. Naturally, what are typically
considered well-behaved surfaces in \f$\mathbb{R}^3\f$ is even more
complicated to state.

Remarks
<ol>
<li> From the complexity-bound perspective, most of the arrangements
  that we can deal with can be regarded as defined by well-behaved
  curves. Even though the package allows for self-intersecting curves,
  for most types each curve can be decomposed into a constant number
  of well-behaved curves, thus having no effect on the asymptotic
  bounds that we cite.
</li>
<li> One type of curves that we deal with is special in this sense:
  <em>polylines</em>, namely concatenations of an unlimited number of
  line segments. A is not considered well behaved, as it cannot be
  decomposed into a constant number of constant-descriptive complexity
  subcurves. Informative bounds for arrangements of polylines are
  expressed by other parameters in addition to the number of
  polylines, for example, the total number of segments in all the
  polylines together. The same holds for the more general type
  <em>polycurve</em>, which are piecewise curves that are not
  necessarily linear.
</li>
</ol>

\subsection aos_ssec-intro-outline Outline

In Section \ref aos_sec-basic we provide the minimum material you need
to know in order to use \cgal 2D arrangements in the plane. In Section
\ref aos_sec-curved_surfaces we provide additional material you need to know
in order use \cgal 2D arrangements embedded on curved surfaces. Most
of the succeeding material is oblivious to the type of the embedding
surface. In Section \ref arr_secqueries we show how queries on an
arrangement can be issued. In Section \ref arr_secgl_funcs we review
some important free (global) functions that operate on arrangements,
the most important ones being the free insertion-functions.  In Section
\ref aos_sec-unbounded we explain how to construct and manipulate
arrangements of unbounded curves.  Section \ref aos_sec-geom_traits
contains detailed descriptions of the geometric traits concept
hierarchy and the various geometric traits classes included in the
arrangement package. The different traits classes enables the
construction and manipulation of arrangements of different families of
curves. Naturally, here, the embedding surface plays a significant
role. In Section \ref arr_secnotif we review the notification
mechanism that allows external classes to keep track of the changes
that an arrangement instance goes through. Section \ref arr_secex_dcel
explains how to extend the \sc{Dcel} records, to store extra data with
them, and to efficiently update this data.  In Section \ref
arr_secoverlay we introduce the fundamental operation of overlaying
two arrangements.  Section \ref arr_secarr_with_hist describes a
class-template that extends the arrangement by storing additional
history records with its curves. In Section \ref aos_sec-io we review
the arrangement input/output functions. In Section \ref aos_sec-bgl we
describes how to apply the graph algorithms implemented in the Boost
Graph Library to arrangement types. Finally, in Section \ref
aos_sec-tips we provide some tips that can be applied to expedite
cmoputation.

\section aos_sec-basic Basic Arrangements

We start with a formal definition of two-dimensional planar
arrangements, and proceed with an introduction to the data structure
used to represent the incidence relations among features of
two-dimensional arrangements, namely, the <em>doubly-connected edge
list</em>, or \sc{dcel} for short. In Section \ref
aos_ssec-basic-arr_class we review in detail the interface of the
`Arrangement_2` class-template, which can be used to represent
arrangements in the plane. It is a central component in the
arrangement package.

\subsection aos_ssec-basic-dcel Representation of Arrangements: The Dcel

Given a set \f$\cal C\f$ of planar curves, the <em>arrangement</em>
\f$\cal A(\cal C)\f$ is the subdivision of the plane into
zero-dimensional, one-dimensional and two-dimensional
cells,\cgalFootnote{We use the term <em>cell</em> to describe the
various dimensional entities in the induced subdivision. Sometimes,
the term <em>face</em> is used for this purpose in the
literature. However, we use the term <em>face</em> to describe a
<em>two-dimensional</em> cell.}  called <em>vertices</em>,
<em>edges</em> and <em>faces</em>, respectively, induced by the curves
in \f$\cal C\f$.

The curves in \f$\cal C\f$ can intersect each other (a single curve
may also be self-intersecting or may comprise several disconnected
branches) and are not necessarily \f$x\f$-monotone.\cgalFootnote{A
continuous planar curve \f$C\f$ is <em>\f$x\f$-monotone</em> if every
vertical line intersects it at most once. For example, a non-vertical
line segment is always \f$x\f$-monotone and so is the graph of any
continuous function \f$y = f(x)\f$. For convenience, we treat vertical
line segments as <em>weakly \f$x\f$-monotone</em>, as there exists a
single vertical line that overlaps them. A circle of radius \f$r\f$
centered at \f$(x_0, y_0)\f$ is not \f$x\f$-monotone, as the vertical
line \f$x = x_0\f$ intersects it at \f$(x_0, y_0 - r)\f$ and at
\f$(x_0, y_0 + r)\f$.}  We construct a collection \f$\cal C''\f$ of
\f$x\f$-monotone subcurves that are pairwise disjoint in their
interiors in two steps as follows. First, we decompose each curve in
\f$\cal C\f$ into maximal \f$x\f$-monotone subcurves (and possibly
isolated points), obtaining the collection \f$\cal C'\f$. Note that an
\f$x\f$-monotone curve cannot be self-intersecting. Then, we decompose
each curve in \f$\cal C'\f$ into maximal connected subcurves not
intersecting any other curve (or point) in \f$\cal C'\f$. The
collection \f$\cal C''\f$ may also contain isolated points, if the
curves of \f$\cal C\f$ contain such points. The arrangement induced by
the collection \f$\cal C''\f$ can be conveniently embedded as a planar
graph, whose vertices are associated with curve endpoints or with
isolated points, and whose edges are associated with subcurves. It is
easy to see that \f$\cal A(\cal C) = \cal A(\cal C'')\f$. This graph
can be represented using a <em>doubly-connected edge list</em>
data-structure (\sc{Dcel} for short), which consists of containers of
vertices, edges and faces and maintains the incidence relations among
these cells.

The \sc{Dcel} data-structure represents each edge using a pair of
directed <em>halfedges</em>, one going from the
\f$xy\f$-lexicographically smaller (left) endpoint of the curve
towards the \f$xy\f$-lexicographically larger (right) endpoint, and
the other, known as its <em>twin</em> halfedge, going in the opposite
direction. As each halfedge is directed, it has a <em>source</em>
vertex and a <em>target</em> vertex. Halfedges are used to separate
faces, and to connect vertices, with the exception of <em>isolated
vertices</em> (representing isolated points), which are unconnected.
If a vertex \f$v\f$ is the target of a halfedge \f$ e\f$, we say that
\f$v\f$ and \f$e\f$ are <em>incident</em> to each other. The halfedges
incident to a vertex \f$v\f$ form a circular list oriented in a
clockwise order around this vertex. (An isolated vertex has no
incident halfedges.)

An <em>edge</em> of an arrangement is a maximal portion of a curve
between two vertices of the arrangement. Each edge is represented in
the \sc{Dcel} by a pair of twin halfedges. Each halfedge \f$e\f$
stores a pointer to its <em>incident face</em>, which is the face lying
to its left. Moreover, every halfedge is followed by another halfedge
sharing the same incident face, such that the target vertex of the
halfedge is the same as the source vertex of the next halfedge. The
halfedges around faces form circular chains, such that all halfedges
of a chain are incident to the same face and wind along its boundary.
We call such a chain a <em>connected component of the boundary</em> or
<em>CCB</em> for short.

The unique CCB of halfedges winding in a counterclockwise orientation
along a face boundary is referred to as the <em>outer CCB</em> of the
face. For the time being let us consider only arrangements of bounded
curves, such that exactly one unbounded face exists in every
arrangement. The unbounded face does not have an outer boundary. Any
other connected component of the boundary of the face is called a
<em>hole</em> (or <em>inner CCB</em>), and can be represented as a
circular chain of halfedges winding in a clockwise orientation around
it. Note that a hole does not necessarily correspond to a face at all,
as it may have no area, or alternatively it may contain several faces.
Every face can have several holes in its interior, or may contain no
holes at all. In addition, every face may contain isolated vertices in
its interior. See \cgalFigureRef{arr_figseg_dcel} for an illustration
of the various \sc{Dcel} features. For more details on the \sc{Dcel}
data structure see \cgalCite{bkos-cgaa-00} Chapter 2.

\cgalFigureBegin{arr_figseg_dcel,arr_segs.png}
An arrangement of interior-disjoint line segments with some of the
\sc{Dcel} records that represent it. The unbounded face \f$f_0\f$ has
a single connected component that forms a hole inside it, and this
hole is comprised if several faces. The half-edge \f$e\f$ is directed
from its source vertex \f$v_1\f$ to its target vertex \f$v_2\f$. This
edge, together with its twin \f$e'\f$, correspond to a line segment
that connects the points associated with \f$v_1\f$ and \f$v_2\f$ and
separates the face \f$f_1\f$ from \f$f_2\f$. The predecessor \f$e_{\rm
prev}\f$ and successor \f$e_{\rm next}\f$ of \f$e\f$ are part of the
chain that form the outer boundary of the face \f$f_2\f$. The face
\f$f_1\f$ has a more complicated structure as it contains two holes in
its interior: One hole consists of two adjacent faces \f$f_3\f$ and
\f$f_4\f$, while the other hole is comprised of two edges. \f$f_1\f$
also contains two isolated vertices \f$u_1\f$ and \f$u_2\f$ in its
interior.
\cgalFigureEnd

\subsection aos_ssec-basic-arr_class The Arrangement Class Template

The class template `Arrangement_2<Traits,Dcel>` can be used to represent
a planar arrangement; it provides the interface needed to construct
planar arrangements, traverse them, and maintain them. An arrangement
is defined by a geometric <em>traits</em> class that determines the
family of planar curves that form the arrangement, and a \sc{Dcel}
class. The traits class supplies a minimal set of geometric operations
(predicates and constructions) required to construct and maintain the
arrangement and to operate on it. The \sc{Dcel} class represents the
<em>topological structure</em> of the planar subdivision.

The design of the arrangement package is guided by the need to
separate between the representation of the arrangements and the
various geometric algorithms that operate on them, and by the need to
separate between the topological and geometric aspects of the planar
subdivision. The separation is exhibited by the two template
parameters of the `Arrangement_2` template:

<UL>

<LI>The `Traits` template-parameter should be instantiated with a
  model of the `ArrangementBasicTraits_2` concept or optionally a
  concept that refines the `ArrangementBasicTraits_2` concept. A model
  of the `ArrangementBasicTraits_2` concept defines the types of
  \f$x\f$-monotone curves and two-dimensional points, namely
  `X_monotone_curve_2` and `Point_2`, respectively, and supports basic
  geometric predicates on them.

  In the first sections of this chapter we always use
  `Arr_segment_traits_2` as our traits class, to construct
  arrangements of line segments. However, the arrangement package
  contains several other traits classes that can handle other types of
  curves, such as polylines (continuous piecewise-linear curves),
  conic arcs, and arcs of rational functions. We exemplify the usage
  of these traits classes in Section \ref aos_sec-geom_traits.
<LI>The `Dcel` template-parameter should be instantiated with a class
  that is a model of the `ArrangementDcel` concept. The value of this
  parameter is `Arr_default_dcel<Traits>` by default.  However, in
  many applications it is necessary to extend the \sc{Dcel} features;
  see Section \ref arr_secex_dcel for further explanations and
  examples.
</UL>

\subsection Arrangement_on_surface_2ASimpleProgram A Simple Program

\image html triangle.png
\image latex triangle.png

The simple program listed below constructs a planar map of three line
segments forming a triangle. The constructed arrangement is
instantiated with the `Arr_segment_traits_2` traits class to handle
segments only.  The resulting arrangement consists of two faces, a
bounded triangular face and the unbounded face.  The program is not
very useful as it is, since it ends immediately after the arrangement
is constructed. We give more enhanced examples in the rest of this
chapter.

\code{.cpp}
#include <CGAL/Cartesian.h>
#include <CGAL/MP_Float.h>
#include <CGAL/Quotient.h>
#include <CGAL/Arr_segment_traits_2.h>
#include <CGAL/Arrangement_2.h>

typedef CGAL::Quotient<CGAL::MP_Float> Number_type;
typedef CGAL::Cartesian<Number_type> Kernel;
typedef CGAL::Arr_segment_traits_2<Kernel> Traits_2;
typedef Traits_2::Point_2 Point_2;
typedef Traits_2::X_monotone_curve_2 Segment_2;
typedef CGAL::Arrangement_2<Traits_2> Arrangement_2;

int main()
{
  Arrangement_2 arr;
  Segment_2 cv[3];
  Point_2 p1 (0, 0), p2 (0, 4), p3 (4, 0);

  cv[0] = Segment_2 (p1, p2);
  cv[1] = Segment_2 (p2, p3);
  cv[2] = Segment_2 (p3, p1);
  CGAL::insert (arr, &cv[0], &cv[3]);
  return (0);
}
\endcode

\subsection arr_ssectraverse Traversing the Arrangement

The simplest and most fundamental arrangement operations are the
various traversal methods, which allow users to systematically go over
the relevant features of the arrangement at hand.

As mentioned above, the arrangement is represented as a \sc{Dcel},
which stores three containers of vertices, halfedges and faces. Thus,
the `Arrangement_2` class supplies iterators for these containers. For
example, the methods `vertices_begin()` and `vertices_end()` return
`Arrangement_2::Vertex_iterator` objects that define the valid range
of arrangement vertices. The value type of this iterator is
`Arrangement_2::Vertex`. Moreover, the vertex-iterator type is
equivalent to `Arrangement_2::Vertex_handle`, which serves as a
pointer to a vertex. As we show next, all functions related to
arrangement features accept handle types as input parameters and
return handle types as their output.

In addition to the iterators for arrangement vertices, halfedges
and faces, the arrangement class also provides `edges_begin()`
and `edges_end()` that return
`Arrangement_2::Edge_iterator` objects for traversing the
arrangement edges. Note that the value type of this iterator is
`Arrangement_2::Halfedge`, representing one of the twin
halfedges that represent the edge.

All iterator, circulator\cgalFootnote{A <em>circulator</em> is used to
traverse a circular list, such as the list of halfedges incident to a
vertex - see below.} and handle types also have non-mutable
(<em>const</em>) counterparts. These non-mutable iterators are useful to
traverse an arrangement without changing it. For example, the
arrangement has a non-constant member function called
`vertices_begin()` that returns a `Vertex_iterator` object and another
const member function that returns a `Vertex_const_iterator`
object. In fact, all methods listed in this section that return an
iterator, a circulator or a handle have non-mutable counterparts. It
should be noted that, for example, `Vertex_handle` can be readily
converted into a `Vertex_const_handle`, but not vice-verse.

Conversion of a non-mutable handle to a corresponding mutable handle
are nevertheless possible, and can be performed using the static
function `Arrangement_2::non_const_handle()` (see, e.g., Section \ref
arr_ssecpl). There are three variant of this function, one for each
type of handle.

\subsection arr_sssectr_vertex Traversal Methods for an Arrangement Vertex

A vertex is always associated with a geometric entity, namely with
a `Point_2` object, which can be obtained by the `point()`
method of the `Vertex` class nested within `Arrangement_2`.

\todo With doxygen it is enough to prefix a method with the
right scope to get the right link in the manual. So we could write:
\"A vertex is always associated with a geometric entity, namely with
an `Arrangement_2::Point_2` object, which can be obtained by the
`Arrangement_2::Vertex::point()` method.\"

The `is_isolated()` method determines whether a vertex is isolated
or not. Recall that the halfedges incident to a non-isolated vertex,
namely the halfedges that share a common target vertex, form a circular
list around this vertex. The `incident_halfedges()` method returns
a circulator of type `Arrangement_2::Halfedge_around_vertex_circulator`
that enables the traversal of this circular list in a clockwise
direction. The value type of this circulator is `Halfedge`.

The following function prints all the neighbors of a given
arrangement vertex (assuming that the `Point_2` type can be
inserted into the standard output using the `<<` operator). The
arrangement type is the same as in the simple example above.

\code
void print_neighboring_vertices (Arrangement_2::Vertex_const_handle v)
{
  if (v->is_isolated()) {
    std::cout << "The vertex (" << v->point() << ") is isolated" << std::endl;
   return;
  }

  Arrangement_2::Halfedge_around_vertex_const_circulator first, curr;
  first = curr = v->incident_halfedges();

  std::cout << "The neighbors of the vertex (" << v->point() << ") are:";
  do {
    // Note that the current halfedge is directed from u to v:
    Arrangement_2::Vertex_const_handle u = curr->source();
    std::cout << " (" << u->point() << ")";
  } while (++curr != first);
  std::cout << std::endl;
}
\endcode

In case of an isolated vertex, it is possible to obtain the face
that contains this vertex using the `face()` method.

\subsection arr_sssectr_halfedge Traversal Methods for an Arrangement Halfedge

Each arrangement edge, realized as a pair of twin halfedges,
is associated with an `X_monotone_curve_2` object, which
can be obtained by the `curve()` method of the `Halfedge`
class nested in the `Arrangement_2` class.

The `source()` and `target()` methods return handles to
the halfedge source and target vertices respectively. We can
obtain a handle to the twin halfedge using the `twin()`
method. From the definition of halfedges, it follows that if
`he` is a halfedge handle, then:
<UL>
<LI>`he->curve()` is equivalent to `he->twin()->curve()`,
<LI>`he->source()` is equivalent to `he->twin()->target()`, and
<LI>`he->target()` is equivalent to `he->twin()->source()`.
</UL>

Every halfedge has an incident face that lies to its left, which
can be obtained by the `face()` method. Recall that a
halfedge is always one link in a connected chain of halfedges that
share the same incident face, known as a <em>CCB</em>. The
`prev()` and `next()` methods return handles to the
previous and next halfedges in the CCB respectively.

As the CCB is a circular list of halfedges, it is only natural to
traverse it using a circulator. The `ccb()` method returns a
`Arrangement_2::Ccb_halfedge_circulator` object for the
halfedges along the CCB.

The function `print_ccb()` listed below prints all \f$x\f$-monotone
curves along a given CCB (assuming that the `Point_2` and the
`X_monotone_curve_2` types can be inserted into the standard output
using the `<<` operator).

\code
void print_ccb (Arrangement_2::Ccb_halfedge_const_circulator circ)
{
  Ccb_halfedge_const_circulator curr = circ;
  std::cout << "(" << curr->source()->point() << ")";
  do {
    Arrangement_2::Halfedge_const_handle he = curr->handle();
    std::cout << " [" << he->curve() << "] "
              << "(" << he->target()->point() << ")";
  } while (++curr != circ);
  std::cout << std::endl;
}
\endcode

\subsection arr_sssectr_face Traversal Methods for an Arrangement Face

An arrangement of bounded curves always has a single unbounded face.
The function `unbounded_face()` returns a handle to this face.
(Note that an empty arrangement contains nothing <em>but</em> the
unbounded face.)

Given a `Face` object, we can use the `is_unbounded()`
method to determine whether it is unbounded. Bounded faces have an
outer CCB, and the `outer_ccb()` method returns a circulator
for the halfedges along this CCB. Note that the halfedges along
this CCB wind in a counterclockwise orientation around the outer
boundary of the face.

A face can also contain disconnected components in its interior,
namely holes and isolated vertices:
<UL>
<LI>The `holes_begin()` and `holes_end()` methods return
`Arrangement_2::Hole_iterator` iterators that define the range
of holes inside the face. The value type of this iterator is
`Ccb_halfedge_circulator`, defining the CCB that winds in a
clockwise orientation around a hole.
<LI>The `isolated_vertices_begin()` and
`isolated_vertices_end()` methods return
`Arrangement_2::Isolated_vertex_iterator` iterators that
define the range of isolated vertices inside the face. The value
type of this iterator is `Vertex`.
</UL>

The function `print_face()` listed below prints the outer and
inner boundaries of a given face, using the function `print_ccb()`,
which was introduced in the previous subsection.

\code
void print_face (Arrangement_2::Face_const_handle f)
{
  // Print the outer boundary.
  if (f->is_unbounded())
    std::cout << "Unbounded face. " << std::endl;
  else {
    std::cout << "Outer boundary: ";
    print_ccb (f->outer_ccb());
  }

  // Print the boundary of each of the holes.
  Arrangement_2::Hole_const_iterator hi;
  int index = 1;
  for (hi = f->holes_begin(); hi != f->holes_end(); ++hi, ++index) {
    std::cout << " Hole #" << index << ": ";
    print_ccb (*hi);
  }

  // Print the isolated vertices.
  Arrangement_2::Isolated_vertex_const_iterator iv;
  for (iv = f->isolated_vertices_begin(), index = 1;
       iv != f->isolated_vertices_end(); ++iv, ++index){
    std::cout << " Isolated vertex #" << index << ": "
              << "(" << iv->point() << ")" << std::endl;
  }
}
\endcode

\subsection aos_ssec-tr_ex Additional Example

The function listed below prints the current setting of a given
arrangement. This concludes the preview of the various traversal
methods.\cgalFootnote{The file `arr_print.h`, which can be found under
the examples folder, includes this function and the rest of the
functions listed in this section. Over there they are written in a
more generic fashion, where the arrangement type serves as a template
parameter for these functions, so different instantiations of the
`Arrangement_2<Traits,Dcel>` template can be provided to the same
function templates.}

\code
void print_arrangement (const Arrangement_2& arr)
{
  // Print the arrangement vertices.
  Vertex_const_iterator vit;
  std::cout << arr.number_of_vertices() << " vertices:" << std::endl;
  for (vit = arr.vertices_begin(); vit != arr.vertices_end(); ++vit) {
    std::cout << "(" << vit->point() << ")";
    if (vit->is_isolated())
       std::cout << " - Isolated." << std::endl;
    else
       std::cout << " - degree " << vit->degree() << std::endl;
  }

  // Print the arrangement edges.
  Edge_const_iterator eit;
  std::cout << arr.number_of_edges() << " edges:" << std::endl;
  for (eit = arr.edges_begin(); eit != arr.edges_end(); ++eit)
    std::cout << "[" << eit->curve() << "]" << std::endl;

  // Print the arrangement faces.
  Face_const_iterator fit;
  std::cout << arr.number_of_faces() << " faces:" << std::endl;
  for (fit = arr.faces_begin(); fit != arr.faces_end(); ++fit)
    print_face (fit);
}
\endcode

\subsection arr_ssecmodify Modifying the Arrangement

In this section we review the various member functions of the
`Arrangement_2` class that allow users to modify the
topological structure of the arrangement by introducing new edges
or vertices, modifying them, or removing them.

The arrangement member-functions that insert new curves into the
arrangement, thus enabling the construction of a planar subdivision, are
rather specialized, as they require a-priori knowledge on the location of
the inserted curve. Indeed, for most purposes it is more convenient to
construct an arrangement using the free (global) insertion-functions.

\subsection arr_sssecmf_insert_cv Inserting Non-Intersecting x-Monotone Curves

The most important functions that allow users to modify the
arrangement, and perhaps the most frequently used ones, are the
specialized insertion functions of \f$x\f$-monotone curves whose
interior is disjoint from any other curve in the existing
arrangement and do not contain any vertex of the arrangement. In
addition, these function require that the location of the curve in the
arrangement is known.

The motivation behind these rather harsh restrictions on the nature of
the inserted curves is the decoupling of the topological arrangement
representation from the various algorithms that operate on it. While
the insertion of an \f$x\f$-monotone curve whose interior is disjoint
from all existing arrangement features is quite straightforward (as we
show next), inserting curves that intersect with the curves already
inserted into the arrangement is much more complicated and requires
the application of non-trivial geometric algorithms.  These insertion
operations are therefore implemented as free functions that operate on
the arrangement and the inserted curve(s); see Section \ref arr_secgl_funcs
for more details and examples.
\cgalFootnote{You may skip to Section \ref arr_secgl_funcs, and return to this subsection at a later point in time.}


\cgalFigureBegin{arr_figex_1,insert.png}

The various specialized insertion procedures. The inserted
\f$x\f$-monotone curve is drawn with a light dashed line, surrounded
by two solid arrows that represent the pair of twin half-edges added
to the \sc{Dcel}. Existing vertices are shown as black dots while
new vertices are shown as light dots. Existing half-edges that are
affected by the insertion operations are drawn as dashed arrows.
(a) Inserting a curve as a new hole inside the face \f$f\f$.
(b) Inserting a curve from an existing vertex \f$u\f$ that
corresponds to one of its endpoints.
(c) Inserting an \f$x\f$-monotone curve whose endpoints are the
already existing vertices \f$u_1\f$ and \f$u_2\f$. In our case, the
new pair of half-edges close a new face \f$f'\f$, where the hole
\f$h_1\f$, which used to belong to \f$f\f$, now becomes an enclave
in this new face.
\cgalFigureEnd

When an \f$x\f$-monotone curve is inserted into an existing
arrangement, such that the interior of this curve is disjoint from any
arrangement feature, only the following three scenarios are possible,
depending on the status of the endpoints of the inserted subcurve:

<OL>
<LI>In case both curve endpoints do not correspond to any existing
arrangement vertex we have to create two new vertices
corresponding to the curve endpoints and connect them using a pair
of twin halfedges. This halfedge pair initiates a new hole inside
the face that contains the curve in its interior.</LI>
<LI>If exactly one endpoint corresponds to an existing arrangement
vertex (we distinguish between a vertex that corresponds to the left
endpoint of the inserted curve and a vertex corresponding to its right
endpoint), we have to create a new vertex that corresponds to the other
endpoint of the curve and to connect the two vertices by a pair of
twin halfedges that form an "antenna" emanating from the boundary
of an existing connected component (note that if the existing vertex
used to be isolated, this operation is actually equivalent to forming
a new hole inside the face that contains this vertex).</LI>
<LI>If both endpoints correspond to existing arrangement
vertices, we connect these vertices using a pair of twin halfedges.
(If one or both vertices are isolated this case reduces to one of
the two previous cases respectively.) The two following subcases may
occur:
<UL>
<LI>Two disconnected components are merged into a single connected
component (as is the case with the segment \f$s_1\f$ in the figure to the
left).</LI>
<LI>A new face is created, a face that splits from an existing
arrangement face. In this case we also have to examine the holes and
isolated vertices in the existing face and move the relevant ones
inside the new face (as is the case with the segment \f$s_2\f$ in the
figure to the left).</LI>
</UL>
</LI>
</OL>

\image html connect_comp.png
\image latex connect_comp.png

The `Arrangement_2` class offers insertion functions named
`insert_in_face_interior()`, `insert_from_left_vertex()`,
`insert_from_right_vertex()` and `insert_at_vertices()` that perform
the special insertion procedures listed above. The first function
accepts an \f$x\f$-monotone curve \f$C\f$ and an arrangement face
\f$f\f$ that contains this curve in its interior. The other functions
accept an \f$x\f$-monotone curve \f$C\f$ and handles to the existing
vertices that correspond to the curve endpoint(s). Each of the four
functions returns a handle to one of the twin halfedges that have been
created, where:

<UL>
<LI>`insert_in_face_interior(C, f)` returns a halfedge directed
from the vertex corresponding to the left endpoint of `C`
toward the vertex corresponding to its right endpoint.
<LI>`insert_from_left_vertex(C, v)` and
`insert_from_right_vertex(C, v)` returns a halfedge whose
source is the vertex \f$v\f$ that and whose target is the new vertex
that has just been created.
<LI>`insert_at_vertices(C, v1, v2)` returns a halfedge directed
from \f$v_1\f$ to \f$v_2\f$.
</UL>

\cgalFigureBegin{arr_figex_2,ex_1.png}
The arrangement of the line segments \f$s_1, \ldots, s_5\f$
constructed in `edge_insertion.cpp`. The arrows mark the direction of
the halfedges returned from the various insertion functions.
\cgalFigureEnd

The following program demonstrates the usage of the four insertion
functions. It creates an arrangement of five line segments, as
depicted in \cgalFigureRef{arr_figex_1}.\cgalFootnote{Notice that in
all figures in the rest of this chapter the coordinate axes are drawn
only for illustrative purposes and are <em>not</em> part of the
arrangement.} As the arrangement is very simple, we use the simple
Cartesian kernel of \cgal with integer coordinates for the segment
endpoints. We also use the `Arr_segment_traits_2` class that enables
the efficient maintenance of arrangements of line segments; see more
details on this traits class in Section \ref aos_sec-geom_traits. This
example, as many others in this chapter, uses some print-utility
functions from the file `print_arr.h`; these functions are also listed
in Section \ref arr_ssectraverse.

\cgalExample{Arrangement_on_surface_2/edge_insertion.cpp}

Observe that the first line segment is inserted in the interior of
the unbounded face. The other line segments are inserted
using the vertices created by the insertion of previous segments.
The resulting arrangement consists of three faces, where the two
bounded faces form together a hole in the unbounded face.

\subsection arr_sssecmf_iso_verts Manipulating Isolated Vertices

Isolated points are in general simpler geometric entities than
curves and indeed the member functions that manipulate them are
easier to understand.

The function `insert_in_face_interior(p, f)` inserts an isolated point
\f$p\f$, located in the interior of a given face \f$ f\f$, into the
arrangement and returns a handle to the arrangement vertex it has
created and associated with \f$p\f$. Naturally, this function has a
precondition that \f$p\f$ is really an isolated point, namely it does
not coincide with any existing arrangement vertex and does not lie on
any edge. As mentioned in Section \ref arr_ssectraverse, it is
possible to obtain the face containing an isolated vertex handle
\f$v\f$ by calling `v->face()`.

The function `remove_isolated_vertex(v)` receives a handle to an
isolated vertex and removes it from the arrangement.

\cgalFigureBegin{arr_figex_3,ex_2.png}
An arrangement of line segments containing three isolated vertices,
as constructed in `isolated_vertices.cpp`. The vertices \f$u_2\f$
and \f$u_3\f$ are eventually removed from the arrangement.
\cgalFigureEnd

The following program demonstrates the usage of the arrangement
member-functions for manipulating isolated vertices. It first inserts
three isolated vertices located inside the unbounded face, then it
inserts four line segments that form a rectangular hole inside the
unbounded face (see \cgalFigureRef{arr_figex_2} for an
illustration). Finally, it traverses the vertices and removes those
isolated vertices that are still contained in the unbounded face
(\f$u_2\f$ and \f$u_3\f$ in this case):

\cgalExample{Arrangement_on_surface_2/isolated_vertices.cpp}

\subsection arr_sssecmf_halfedges Manipulating Halfedges

In the previous subsection we showed how to introduce new isolated
vertices in the arrangement. But how does one create a vertex that
lies on an existing arrangement edge (more precisely, on an
\f$x\f$-monotone curve that is associated with an arrangement edge)?

It should be noted that such an operation involves the splitting of a
curve at a given point in its interior, while the traits class used by
`Arrangement_2` does not necessarily have the ability to perform such
a split operation. However, if users have the ability to split an
\f$x\f$-monotone curve into two at a given point \f$ p\f$ (this is
usually the case when employing a more sophisticated traits class; see
Section \ref aos_sec-geom_traits for more details) they can use the
`split_edge(e, C1, C2)` function, were \f$C_1\f$ and \f$C_2\f$ are the
two subcurves resulting from splitting the \f$x\f$-monotone curve
associated with the halfedge \f$e\f$ at some point (call it \f$p\f$)
in its interior. The function splits the halfedge pair into two pairs,
both incident to a new vertex \f$v\f$ associated with \f$p\f$, and
returns a handle to a halfedge whose source equals \f$e\f$'s source
vertex and whose target is the new vertex \f$v\f$.

The reverse operation is also possible. Suppose that we have a vertex
\f$v\f$ of degree \f$2\f$, whose two incident halfedges, \f$e_1\f$ and
\f$e_2\f$, are associated with the curves \f$C_1\f$ and
\f$C_2\f$. Suppose further that it is possible to merge these two
curves into a single continuous \f$x\f$-monotone curve
\f$C\f$. Calling `merge_edge(e1, e2, C)` will merge the two edges into
a single edge associated with the curve \f$C\f$, essentially removing
the vertex \f$v\f$ from the arrangement.

Finally, the function `remove_edge(e)` removes the edge \f$e\f$ from
the arrangement. Note that this operation is the reverse of an
insertion operation, so it may cause a connected component to split
into two, or two faces to merge into one, or a hole to disappear. By
default, if the removal of `e` causes one of its end-vertices to
become isolated, we remove this vertex as well.  However, users can
control this behavior and choose to keep the isolated vertices by
supplying additional Boolean flags to `remove_edge()` indicating
whether the source and the target vertices are to be removed should
they become isolated.

\cgalFigureBegin{arr_figex_4,ex_3.png}
An arrangement of line segments as constructed in
`edge_manipulation.cpp`. Note that the edges \f$e_7\f$ and \f$e_8\f$
and the vertices \f$w_1\f$ and \f$w_2\f$, introduced in step (b) are
eventually removed in step (c).
\cgalFigureEnd

In the following example program we show how the edge-manipulation
functions can be used. The program works in three steps, as
demonstrated in \cgalFigureRef{arr_figex_3}. Note that here we still
stick to integer coordinates, but as we work on a larger scale we use
an unbounded integer number-type (in this case, the `Gmpz` type taken
from the <span class="textsc">Gmp</span> library) instead of the
built-in `int` type.\cgalFootnote{As a rule of thumb, one can use a
bounded integer type for representing line segments whose coordinates
are bounded by \f$\lfloor\sqrt[3]{M}\rfloor\f$, where \f$M\f$ is the
maximal representable integer value. This guarantees that no overflows
occur in the computations carried out by the traits class, hence all
traits-class predicates always return correct results.}  In case the
<span class="textsc">Gmp</span> library is not installed (as indicated
by the `CGAL_USE_GMP` flag defined in `CGAL/basic.h`), we use
`MP_Float`, a number-type included in \cgal's support library that is
capable of storing floating-point numbers with unbounded mantissa. We
also use the standard Cartesian kernel of \cgal as our kernel. This is
recommended when the kernel is instantiated with a more complex number
type, as we demonstrate in other examples in this chapter.

\cgalExample{Arrangement_on_surface_2/edge_manipulation.cpp}

Note how we use the halfedge handles returned from `split_edge()` and
`merge_edge()`. Also note the insertion of the isolated vertex
\f$v_6\f$ located inside the triangular face (the incident face of
\f$e_7\f$). This vertex seizes from being isolated, as it is gets
connected to other vertices.

In this context, we should mention the two member functions
`modify_vertex(v, p)`, which sets \f$p\f$ to be the point associated
with the vertex \f$v\f$, and `modify_edge(e, c)`, which sets \f$C\f$
to be the \f$x\f$-monotone curve associated with the halfedge
\f$e\f$. These functions have preconditions that \f$p\f$ is
geometrically equivalent to `v->point()` and \f$C\f$ is equivalent to
`e->curve()` (i.e., the two curves have the same graph), respectively,
to avoid the invalidation of the geometric structure of the
arrangement. At a first glance it may seen as these two functions are
of little use. However, we should keep in mind that there may be
extraneous data (probably non-geometric) associated with the point
objects or with the curve objects, as defined by the traits
class. With these two functions we can modify this data; see more
details in Section \ref aos_sec-geom_traits.

In addition, we can use these functions to replace a geometric object
(a point or a curve) with an equivalent object that has a more compact
representation. For example, we can replace the point
\f$(\frac{20}{40}, \frac{99}{33})\f$ associated with some vertex
\f$v\f$, by \f$(\frac{1}{2}, 3)\f$.

\subsection arr_sssecadv_insert Advanced Insertion Functions

\image html pred_around_vertex.png
\image latex pred_around_vertex.png

\cgalAdvancedBegin

Assume that the specialized insertion function
`insert_from_left_vertex(C, v)` is invoked for a curve \f$C\f$, whose
left endpoint is already associated with a non-isolated vertex
\f$v\f$. Namely, \f$v\f$ has already several incident halfedges. It is
necessary in this case to locate the exact place for the new halfedge
mapped to the inserted new curve \f$C\f$ in the circular list of
halfedges incident to \f$v\f$. More precisely, it is sufficient to
locate one of the halfedges `pred` directed toward \f$v\f$ such that
\f$C\f$ is located between `pred` and `pred->next()` in clockwise
order around \f$v\f$, in order to complete the insertion (see
\cgalFigureRef{arr_figex_1} for an illustration). This may take
\f$O(d)\f$ time where \f$d\f$ is the degree of the vertex. However, if
the halfedge `pred` is known in advance, the insertion can be carried
out in constant time.

The `Arrangement_2` class provides the advanced versions of the
specialized insertion functions for a curve \f$C\f$ - namely we have
`insert_from_left_vertex(C, pred)` and
`insert_from_right_vertex(C, pred)` that accept a halfedge `pred` as
specified above, instead of a vertex \f$v\f$. These functions are more
efficient, as they take constant time and do not perform any geometric
operations. Thus, they should be used when the halfedge `pred` is
known. In case that the vertex \f$v\f$ is isolated or that the
predecessor halfedge for the new inserted curve is not known, the
simpler versions of these insertion functions should be used.

Similarly, there exist two overrides of the `insert_at_vertices()`
function: One that accept the two predecessor halfedges around the two
vertices \f$v_1\f$ and \f$v_2\f$ that correspond to the curve
endpoints, and one that accepts a handle for one vertex and a
predecessor halfedge around the other vertex.

\cgalFigureBegin{arr_figex_5,ex_4.png}
An arrangement of line segments, as constructed in
`special_edge_insertion.cpp`. Note that \f$p_0\f$ is initially
inserted as an isolated point and later on connected to the other four
vertices.
\cgalFigureEnd

The following program shows how to construct the arrangement
depicted in \cgalFigureRef{arr_figex_4} using the specialized
insertion functions that accept predecessor halfedges:

\cgalExample{Arrangement_on_surface_2/special_edge_insertion.cpp}

It is possible to perform even more refined operations on an
`Arrangement_2` instance given specific topological information.
As most of these operations are very fragile and perform no precondition
testing on their input in order to gain efficiency, they are not included
in the public interface of the arrangement class. Instead, the
`Arr_accessor<Arrangement>` class allows access to these internal
arrangement operations - see more details in the Reference Manual.
\cgalAdvancedEnd

\section arr_secqueries Issuing Queries on an Arrangement

One of the most important query types defined on arrangements is
the <em>point-location</em> query: Given a point, find the arrangement
cell that contains it. Typically, the result of a point-location
query is one of the arrangement faces, but in degenerate situations
the query point can be located on an edge or it may coincide with a
vertex.

Point-location queries are common in many applications, and also
play an important role in the incremental construction of arrangements
(and more specifically in the free insertion-functions described in
Section \ref arr_secgl_funcs). Therefore, it is crucial to have the
ability to answer such queries effectively.

\subsection arr_ssecpl Point-Location Queries

The `Arrangement_2` class template does not support point-location
queries directly, as the arrangement representation is decoupled from
the geometric algorithms that operate on it. The <em>2D Arrangements</em>
package includes a set of classe templates that are capable of
answering such queries; all are models of the concept
`ArrangementPointLocation_2`. Each model employs a different
algorithm or <em>strategy</em> for answering queries. A model of this
concept must define the `locate()` member function, which accepts
an input query-point and returns an object that represents the
arrangement cell that contains this point. This object is is type
`Arr_point_location_result<Arrangement_2>::%Type`---a discriminated
union container of the bounded types `Vertex_const_handle`,
`Halfedge_const_handle`, or `Face_const_handle`. Depending on
whether the query point is located inside a face, on an edge, or on a
vertex, the appropriate handle can be obtained with <em>value retrieval</em>
by `boost::get` as demonstrated in the example below.

Note that the handles returned by the `locate()` functions are
non-mutable (`const`). If necessary, such handles may
be cast to mutable handles using the `non_const_handle()` methods
`Arrangement_2::non_const_handle()` provided by the
`Arrangement_2` class.

An object `pl` of any point-location class must be attached to an
`Arrangement_2` object `arr` before it is used to answer
point-location queries on `arr`. This attachment can be performed
when `pl` is constructed or at a later time using the
`pl.init(arr)` call.

The function template listed below accepts a point-location object,
the type of which is a model of the `ArrangementPointLocation_2`
concept, and a query point. The function template issues a
point-location query for the given point, and prints out the result.
It is defined in the header file `point_location_utils.h`.

\anchor lst_pl
\code
template <typename PointLocation>
void locate_point(const PointLocation& pl,
                  const typename PointLocation::Arrangement_2::Point_2& q)
{
  typedef PointLocation                                 Point_location;
  typedef typename Point_location::Arrangement_2        Arrangement_2;
  typename CGAL::Arr_point_location_result<Arrangement_2>::Type obj =
    pl.locate(q);

  // Print the result.
  print_point_location<Arrangement_2>(q, obj);
}
\endcode

The function template `locate_point()` calls an instance of the
function template `print_point_location()`, which inserts the
result of the query into the standard output-stream. It is listed
below, and defined in the header file `point_location_utils.h`.
Observe how the function `boost::get()` is used to cast the
resulting object into a handle to an arrangement feature. The
point-location object `pl` is assumed to be already attached
to an arrangement.

\code
template <typename Arrangement_>
void
print_point_location
(const typename PointLocation::Arrangement_2::Point_2& q
 typename CGAL::Arr_point_location_result<Arrangement_>::Type obj)
{
  typedef Arrangement_                                  Arrangement_2;

  typedef typename Arrangement_2::Vertex_const_handle   Vertex_const_handle;
  typedef typename Arrangement_2::Halfedge_const_handle Halfedge_const_handle;
  typedef typename Arrangement_2::Face_const_handle     Face_const_handle;

  const Vertex_const_handle*   v;
  const Halfedge_const_handle* e;
  const Face_const_handle*     f;

  std::cout << "The point (" << q << ") is located ";
  if (f = boost::get<Face_const_handle>(&obj)) // located inside a face
    std::cout << "inside "
              << (((*f)->is_unbounded()) ? "the unbounded" : "a bounded")
              << " face." << std::endl;
  else if (e = boost::get<Halfedge_const_handle>(&obj)) // located on an edge
    std::cout << "on an edge: " << (*e)->curve() << std::endl;
  else if (v = boost::get<Vertex_const_handle>(&obj)) // located on a vertex
    std::cout << "on " << (((*v)->is_isolated()) ? "an isolated" : "a")
              << " vertex: " << (*v)->point() << std::endl;
  else CGAL_error_msg("Invalid object.");
}
\endcode

\subsection arr_sssecpl_strat Choosing a Point-Location Strategy

Each of the various point-location class templates employs a different
algorithm or <em>strategy</em>\cgalFootnote{The term <em>strategy</em>
is borrowed from the design-pattern taxonomy \cgalCite{cgal:ghjv-dpero-95},
Chapter 5. A <em>strategy</em> provides the means to define a family of
algorithms, each implemented by a separate class. All classes that implement
the various algorithms are made interchangeable, letting the algorithm in use
vary according to the user choice.} for answering queries:
<UL>
<LI> `Arr_naive_point_location<Arrangement>` employs the
  <em>naive</em> strategy. It locates the query point naively,
  exhaustively scanning all arrangement cells.

<LI> `Arr_walk_along_line_point_location<Arrangement>` employs
  the <em>walk-along-a-line</em> (or <em>walk</em> for short) strategy.
  It simulates a traversal, in reverse order, along an imaginary
  vertical ray emanating from the query point. It starts from the
  unbounded face of the arrangement and moves downward toward the
  query point until it locates the arrangement cell containing it.

<LI>`Arr_landmarks_point_location<Arrangement,Generator>`
  uses a set of <em>landmark</em> points, the location of which in the
  arrangement is known. It employs the <em>landmark</em> strategy. Given a
  query point, it uses a nearest-neighbor search-structure (a
  <span class="textsc">Kd</span>-tree is used by default) to find the
  nearest landmark, and then traverses the straight-line segment
  connecting this landmark to the query point.

  There are various ways to select the landmark set in the
  arrangement. The selection is governed by the `Generator`
  template parameter. The default generator class, namely
  `Arr_landmarks_vertices_generator`, selects all the vertices of
  the attached arrangement as landmarks. Additional generators that
  select the set in other ways, such as by sampling random
  points or choosing points on a grid, are also available; see the
  Reference Manual for more details.

  The landmark strategy requires that the type of the attached
  arrangement be an instance of the `Arrangement_2<Traits,Dcel>`
  class template, where the `Traits` parameter is substituted with
  a geometry-traits class that models the
  `ArrangementLandmarkTraits_2` concept, which refines the basic
  `ArrangementBasicTraits_2` concept; see
  Section \ref aos_sssec-tr_lanmarks_concept for details. Most traits
  classes included in the <em>2D Arrangement</em> package are models of
  this refined concept.

<LI>`Arr_trapezoid_ric_point_location<Arrangement>` implements an
  improved variant of Mulmuley's point-location algorithm
  \cgalCite{m-fppa-90}; see also \cgalCite{bkos-cgaa-00}, Chapter 6.
  The (expected) query-time is logarithmic. The arrangement faces
  are decomposed into simpler cells each of constant complexity, known
  as <em>pseudo-trapezoids</em>, and a search structure (a directed acyclic
  graph) is constructed on top of these cells, facilitating the search
  of the pseudo trapezoid (hence the arrangement cell) containing a
  query point in expected logarithmic time. The trapezoidal map and
  the search structure are built by a randomized incremental construction
  algorithm (RIC).

</UL>

The first two strategies do not require any extra data. The class
templates that implement them store a pointer to an arrangement object
and operate directly on it. Attaching such point-location objects to
an existing arrangement has virtually no running-time cost at all, but
the query time is linear in the size of the arrangement (the
performance of the walk strategy is much better in practice, but
its worst-case performance is linear). Using these strategies is
therefore recommended only when a relatively small number of
point-location queries are issued by the application, or when the
arrangement is constantly changing (That is, changes in the arrangement
structure are more frequent than point-location queries).

On the other hand, the landmarks and the trapezoid RIC strategies
require auxiliary data structures on top of the arrangement, which
they need to construct once they are attached to an arrangement object
and need to keep up-to-date as this arrangement changes.  The data
structure needed by the landmarks strategy can be constructed in
\f$O(N \log N)\f$ time, where \f$N\f$ is the overall number of edges
in the arrangement, but the constant hidden in the \f$O()\f$ notation
for the trapezoidal map RIC strategy is much larger. Thus,
construction needed by the landmark algorithm is in practice
significantly faster than the construction needed by the trapezoidal
map RIC strategy. In addition, although both resulting data structures
are asymptotically linear in size, using a <span
class="textsc">Kd</span>-tree as the nearest-neighbor search-structure
that the landmark algorithm stores significantly reduces memory
consumption.  The trapezoidal map RIC algorithm has expected
logarithmic query time, while the query time for the landmark strategy
may be as large as linear. In practice however, the query times of
both strategies are competitive. For a detailed experimental
comparison see \cgalCite{cgal:hh-eplca-05}.

Updating the auxiliary data structures of the trapezoidal map RIC
algorithm is done very efficiently. On the other hand, updating the
nearest-neighbor search-structure of the landmark algorithm may
consume more time when the arrangement changes frequently, especially
when a <span class="textsc">Kd</span>-tree is used, as it must be
rebuilt each time the arrangement changes. It is therefore recommended
that the `Arr_landmarks_point_location` class template be used when
the application frequently issues point-location queries on an
arrangement that only seldom changes. If the arrangement is more
dynamic and is frequently going through changes, the
`Arr_trapezoid_ric_point_location` class template should be the
selected point-location strategy.

\subsection arr_sssecpl_ex An Example

\cgalFigureBegin{arr_figex_8,ex_5.png}
The arrangement of line segments, as constructed in `point_location_example.cpp`, `vertical_ray_shooting.cpp`, and `batched_point_location.cpp`. The arrangement vertices are drawn as small discs, while the query points \f$q_1, \ldots, q_6\f$ are marked with crosses.
\cgalFigureEnd

The program listed below constructs a simple arrangement of five line
segments that form a pentagonal face, with a single isolated
vertex in its interior, as depicted in \cgalFigureRef{arr_figex_5}.
Notice that we use the same arrangement structure in the next
three example programs. The arrangement construction is performed by
the function `construct_segment_arr()` defined in the header file
`point_location_utils.h`. (Its listing is omitted here.) The
program employs the naive and the landmark strategies to issue
several point-location queries on this arrangement.

\cgalExample{Arrangement_on_surface_2/point_location_example.cpp}

Note that the program uses the `locate_point()` function template
to locate a point and nicely print the result of each query; see
\ref lst_pl "here".

\subsection arr_ssecray_shoot Vertical Ray Shooting

Another important query issued on arrangements is the vertical
ray-shooting query: Given a query point, which arrangement feature
do we encounter by a vertical ray shot upward (or downward) from this
point? In the general case the ray hits an edge, but it is possible
that it hits a vertex, or that the arrangement does not have any
vertex or edge lying directly above (or below) the query point.

All point-location classes listed in the previous section are also
models of the `ArrangementVerticalRayShoot_2` concept. That is,
they all have member functions called `ray_shoot_up(q)` and
`ray_shoot_down(q)` that accept a query point `q`. These functions
output an object of type type
`Arr_point_location_result<Arrangement_2>::%Type`---a discriminated
union container of the bounded types `Vertex_const_handle`,
`Halfedge_const_handle`, or `Face_const_handle`. The latter type
is used for the unbounded face of the arrangement, in case there is no
edge or vertex lying directly above (or below) `q`.

The function template `vertical_ray_shooting_query()` listed
below accepts a vertical ray-shooting object, the type of which
models the `ArrangementVerticalRayShoot_2` concept. It exports
the result of the upward vertical ray-shooting operation from a
given query point to the standard output-stream. The ray-shooting
object `vrs` is assumed to be already attached to an arrangement.
The function template is defined in the header file
`point_location_utils.h.

\code
template <typename RayShoot>
void shoot_vertical_ray(const RayShoot& vrs,
                       const typename RayShoot::Arrangement_2::Point_2& q)
{
  typedef RayShoot                                      Vertical_ray_shooting;

  // Perform the point-location query.
  typename Vertical_ray_shooting::result_type obj = vrs.ray_shoot_up(q);

  // Print the result.
  typedef typename Vertical_ray_shooting::Arrangement_2 Arrangement_2;
  typedef typename Arrangement_2::Vertex_const_handle   Vertex_const_handle;
  typedef typename Arrangement_2::Halfedge_const_handle Halfedge_const_handle;
  typedef typename Arrangement_2::Face_const_handle     Face_const_handle;

  const Vertex_const_handle*   v;
  const Halfedge_const_handle* e;
  const Face_const_handle*     f;

  std::cout << "Shooting up from (" << q << ") : ";
  if (v = boost::get<Vertex_const_handle>(&obj))         // we hit a vertex
    std::cout << "hit " << (((*v)->is_isolated()) ? "an isolated" : "a")
              << " vertex: " << (*v)->point() << std::endl;
  else if (e = boost::get<Halfedge_const_handle>(&obj))  // we hit an edge
    std::cout << "hit an edge: " << (*e)->curve() << std::endl;
  else if (f = boost::get<Face_const_handle>(&obj)) \{    // we hit nothing
    CGAL_assertion((*f)->is_unbounded());
    std::cout << "hit nothing." << std::endl;
  else CGAL_error();
}
\endcode

The program below uses the function template listed above to
perform vertical ray-shooting queries on an arrangement. The
arrangement and the query points are exactly the same as in
`point_location.cpp`; see \cgalFigureRef{arr_figex_5}.

\cgalExample{Arrangement_on_surface_2/vertical_ray_shooting.cpp}

The number type we use in this example is \cgal's built-in
`MP_Float` type, which is a floating-point number with an
unbounded mantissa and a 32-bit exponent. It supports construction
from an integer or from a machine `float` or `double` and
performs additions, subtractions and multiplications in an exact
number.

\subsection arr_ssecbatched_pl Batched Point-Location

Suppose that at a given moment our application has to issue a
relatively large number \f$m\f$ of point-location queries on a
specific arrangement object. Naturally, It is possible to define a
point-location object and use it to issue separate queries on the
arrangement. However, as explained in Section \ref arr_ssecpl choosing
a simple point-location strategy (either the naive or the walk
strategy) means inefficient queries, while the more sophisticated
strategies need to construct auxiliary structures that incur
considerable overhead in running time.

Alternatively, the <em>2D Arrangement</em> package includes a free
`locate()` function that accepts an arrangement and a range of
query points as its input and sweeps through the arrangement to
locate all query points in one pass. The function outputs the query
results as pairs, where each pair consists of a query point
and a discriminated union container, which represents the
cell containing the point; see Section \ref arr_ssecpl. The output
pairs are sorted in increasing $xy$-lexicographical order of the
query point.

The batched point-location operation is carried out by sweeping the
arrangement. Thus, it takes \f$O((m+N)\log{(m+N)})\f$ time, where
\f$N\f$ is the number of edges in the arrangement. Issuing separate
queries exploiting a point-location strategy with logarithmic query
time per query, such as the trapezoidal map RIC strategy (see Section
\ref arr_sssecpl_strat), is asymptotically more efficient. However,
experiments show that when the number \f$m\f$ of point-location
queries is of the same order of magnitude as \f$N\f$, the batched
point-location operation is more efficient in practice.  One of the
reasons for the inferior performance of the alternative
(asymptotically faster) procedures is the necessity to construct and
maintain complex additional data structures.

The program below issues a batched point-location query, which
is essentially equivalent to the six separate queries performed in
`point_location_example.cpp`; see Section \ref arr_ssecpl.

\cgalExample{Arrangement_on_surface_2/batched_point_location.cpp}

\section arr_secgl_funcs Free Functions in the Arrangement Package

In Section \ref aos_ssec-basic-arr_class we reviewed in details the
`Arrangement_2` class, which represents two-dimensional subdivisions
induced by planar curves, and mentioned that its interface is minimal
in the sense that the member functions hardly perform any geometric
algorithms and are mainly used for maintaining the topological
structure of the subdivision. In this section we explain how to
utilize the free (global) functions that operate on arrangements. The
implementation of these operations typically require non-trivial
geometric algorithms or load some extra requirements on the traits
class.

\subsection arr_ssecinc_insert Incremental Insertion Functions

\subsection arr_sssecinsert_non_x Inserting Non-Intersecting Curves

In Section \ref aos_ssec-basic-arr_class we explained how to construct
arrangements of \f$x\f$-monotone curves that are pairwise disjoint in
their interior, when the location of the segment endpoints in the
arrangement is known. Here we relax this constraint, and allow the
location of the inserted \f$x\f$-monotone curve endpoints to be arbitrary,
as it may be unknown at the time of insertion. We retain, for the moment,
the requirement that the interior of the inserted curve is disjoint from
all existing arrangement edges and vertices.

The free function `insert_non_intersecting_curve(arr, C, pl)` inserts
the \f$x\f$-monotone curve \f$C\f$ into the arrangement `arr`, with
the precondition that the interior of \f$C\f$ is disjoint from all
`arr`'s existing edges and vertices. The third argument `pl` is a
point-location object attached to the arrangement, which is used for
performing the insertion. It locates both curve endpoints in the
arrangement, where each endpoint is expected to either coincide with
an existing vertex or lie inside a face.  It is possible to invoke one
of the specialized insertion functions (see Section \ref
aos_ssec-basic-arr_class), based on the query results, and insert
\f$C\f$ at its proper position.\cgalFootnote{The
`insert_non_intersecting_curve()` function, as all other functions
reviewed in this section, is a function template, parameterized by an
arrangement class and a point-location class (a model of the
`ArrangementPointLocation_2` concept).} The insertion operation thus
hardly requires any geometric operations on top on the ones needed to
answer the point-location queries. Moreover, it is sufficient that the
arrangement class is instantiated with a traits class that models the
`ArrangementBasicTraits_2` concept (or the
`ArrangementLandmarkTraits_2` concept, if the landmark point-location
strategy is used), which does not have to support the computation of
intersection points between curves.

The variant `insert_non_intersecting_curve(arr, c)` is also
available. Instead of accepting a user-defined point-location
object, it defines a local instance of the walk point-location
class and uses it to insert the curve.

\subsection arr_sssecinsert_x_mon Inserting x-Monotone Curves

The `insert_non_intersecting_curve()` function is very efficient, but
its preconditions on the input curves are still rather
restricting. Let us assume that the arrangement is instantiated with a
traits class that models the refined `ArrangementXMonotoneTraits_2`
concept and supports intersection computations (see Section \ref
aos_sec-geom_traits for the exact details). Given an \f$x\f$-monotone
curve, it is sufficient to locate its left endpoint in the arrangement
and to trace its <em>zone</em>, namely the set of arrangement features
crossing the curve, until the right endpoint is reached. Each time the
new curve \f$C\f$ crosses an existing vertex or an edge, the curve is
split into subcurves (in the latter case, we have to split the curve
associated with the existing halfedge as well) and associate new edges
with the resulting subcurves. Recall that an edge is represented by a
pair of twin halfedges, so we split it into two halfedge pairs.

The free function `insert(arr, C, pl)` performs this insertion
operation. It accepts an \f$x\f$-monotone curve \f$C\f$, which may
intersect some of the curves already in the arrangement `arr`, and
inserts it into the arrangement by computing its zone.  Users may
supply a point-location object `pl`, or use the default walk
point-location strategy (namely, the variant `insert(arr, C)` is also
available). The running-time of this insertion function is
proportional to the complexity of the zone of the curve \f$C\f$.

\cgalAdvancedBegin
In some cases users may have a prior knowledge of the location of the
left endpoint of the \f$x\f$-monotone curve `c` they wish to insert,
so they can perform the insertion without issuing any point-location
queries. This can be done by calling `insert(arr, C, obj)`, where
`obj` is an object represents the location of `c`'s left endpoint in
the arrangement - namely it wraps a `Vertex_const_handle`, a
`Halfedge_const_handle` or a `Face_const_handle` (see also Section
\ref arr_ssecpl).
\cgalAdvancedEnd

\subsection aos_ssec-insert_gen Inserting General Curves

So far all our examples were of arrangements of line segments, where
the `Arrangement_2` template was instantiated with the
`Arr_segment_traits_2` class. In this case, the fact that `insert()`
accepts an \f$x\f$-monotone curve does not seem to be a restriction,
as all line segments are \f$x\f$-monotone (note that we consider
vertical line segments to be <em>weakly</em> \f$x\f$-monotone).

Suppose that we construct an arrangement of circles. A circle is
obviously not \f$x\f$-monotone, so we cannot insert it in the same way
we inserted \f$x\f$-monotone curves. \cgalFootnote{Note that a key
operation performed by `insert()` is to locate the left endpoint of
the curve in the arrangement. A circle, however, does not have any
endpoints!} However, it is possible to subdivide each circle into two
\f$x\f$-monotone circular arcs (its upper half and its lower half) and
to insert each \f$x\f$-monotone arc separately.

The free function `insert()` also supports general curve and not
necessarily \f$x\f$-monotone curves. In this case it requires that the
traits class used by the arrangement `arr` to be a model of the
concept `ArrangementTraits_2`, which refines the
`ArrangementXMonotoneTraits_2` concept. It has to define an additional
`Curve_2` type (which may differ from the `X_monotone_curve_2` type),
and support the subdivision of curves of this new type into
\f$x\f$-monotone curves (see the exact details in Section \ref
aos_sec-geom_traits). The `insert(arr, C, pl)` function performs the
insertion of the curve \f$C\f$, which does not need to be
\f$x\f$-monotone, into the arrangement by subdividing it (if needed)
into \f$x\f$-monotone subcurves and inserting each one
separately. Users may supply a point-location object `pl`, or use the
default walk point-location strategy by calling `insert(arr, C)`.

\subsection arr_sssecinsert_point Inserting Points

The arrangement class enables us to insert a point as an isolated
vertex in a given face. The free function
`insert_point(arr, p, pl)` inserts a vertex into `arr` that
corresponds to the point `p` at an arbitrary location. It uses
the point-location object `pl` to locate the point in the
arrangement (by default, the walk point-location strategy is used),
and acts according to the result as follows:
<UL>
<LI>If `p` is located inside a face, it is inserted as an
isolated vertex inside this face.
<LI>If `p` lies on an edge, the edge is split to create a
vertex associated with `p`.
<LI>Otherwise, `p` coincides with an existing vertex and
we are done.
</UL>
In all cases, the function returns a handle to the vertex
associated with `p`.

The arrangement `arr` should be instantiated with a traits class
that models the `ArrangementXMonotoneTraits_2` concept, as the
insertion operation may involve splitting curves.

\subsection arr_sssecinsert_ex An Example

\cgalFigureBegin{arr_figex_10,ex_8.png}
An arrangement of five intersecting line segments, as constructed in
`incremental_insertion.cpp` and `aggregated_insertion.cpp`. The
segment endpoints are marked by black disks and the arrangement
vertices that correspond to intersection points are marked by
circles. The query point \f$q\f$ is marked with a cross and the face
that contains it is shaded.
\cgalFigureEnd

The program below constructs an arrangement of intersecting
line-segments. We know that \f$s_1\f$ and \f$s_2\f$ do not intersect,
so we use `insert_non_intersecting_curve()` to insert them into the
empty arrangement. The rest of the segments are inserted using
`insert()`. The resulting arrangement consists of \f$13\f$ vertices,
\f$16\f$ edges, and \f$5\f$ faces, as can be seen in
\cgalFigureRef{arr_figex_8}.

In the earlier examples, all arrangement vertices corresponded to
segment endpoints. In this example we have additional vertices that
correspond to intersection points between two segments. The
coordinates of these intersection points are rational numbers, if the
input coordinates are rational (or integer). Therefore, the
`Quotient<int>` number type is used to represent the coordinates:

\cgalExample{Arrangement_on_surface_2/incremental_insertion.cpp}

\subsection arr_ssseczone Other Zone Related Functions

In this section we have described so far free functions that
insert curves and points to a given arrangement. Now we will describe
functions that don't insert curves or points to an arrangement nor do
they change the arrangement, but they are closely related to the
incremental insertion functions as they also use the zone algorithm.

The free function `do_intersect()` checks if a given curve or
\f$x\f$-monotone curve intersects an existing arrangement's edges or
vertices.  If the give curve is not an \f$x\f$-monotone curve then the
function subdivides the given curve into \f$x\f$-monotone subcurves
and isolated vertices . Each subcurve is in turn checked for
intersection.  The function uses the zone algorithm to check if the
curve intersects the arrangement. First, the curve's left endpoint is
located. Then, its zone is computed starting from its left endpoint
location. The zone computation terminates when an intersection with an
arrangement's edge/vertex is found or when the right endpoint is
reached.  A given point-location object is used for locating the left
endpoint of the given curve in the existing arrangement. By default,
the function uses the "walk along line" point-location strategy -
namely an instance of the class `Arr_walk_along_line_point_location`.
If the given curve is \f$ x\f$-monotone then the traits class must
model the `ArrangementXMonotoneTraits_2` concept. If the curve is not
\f$x\f$-monotone curve then the traits class must model the
`ArrangementTraits_2` concept.

The `zone()` function computes the zone of a given \f$x\f$-monotone
curve in a given arrangement. Meaning, it outputs all the
arrangement's elements (vertices, edges and faces) that the
\f$x\f$-monotone curve intersects in the order that they are
discovered when traversing the \f$x\f$-monotone curve from left to
right.  The function uses a given point-location object to locate the
left endpoint of the given \f$x\f$-monotone curve. By default, the
function uses the "walk along line" point-location strategy.  The
function requires that the traits class will model the
`ArrangementXMonotoneTraits_2` concept.

\subsection arr_ssecagg_insert Aggregated Insertion Functions

Let us assume that we have to insert a set of \f$m\f$ input curves
into an arrangement. It is possible to do this incrementally,
inserting the curves one by one, as shown in the previous section.
However, the arrangement package provides three free functions that
aggregately insert a range of curves into an arrangement:

<UL>

<LI>`insert_non_intersecting_curves(arr, begin, end)` inserts a range
of \f$ x\f$-monotone curves given by the input iterators `[begin,
end)` into an arrangement `arr`. The \f$x\f$-monotone curves should
be pairwise disjoint in their interior and also interior-disjoint from
all existing edges and vertices of `arr`.  <LI>`insert(arr, begin,
end)` inserts a range of general (not necessarily \f$x\f$-monotone)
curves of type `Curve_2` or `X_monotone_curve_2` that may intersect
one another, given by the input iterators `[begin, end)`, into the
arrangement `arr`.</LI>
</UL>

We distinguish between two cases:
(i) The given arrangement `arr` is empty (has only an unbounded face),
so we have to construct it from scratch.
(ii) We have to insert \f$m\f$ input curves to a non-empty arrangement
`arr`.

In the first case, we sweep over the input curves, compute
their intersection points and construct the \sc{Dcel} that represents
their planar arrangement. This process is performed in
\f$O\left((m + k)\log m\right)\f$ time, where \f$k\f$ is the total number
of intersection points. The running time is asymptotically better
than the time needed for incremental insertion, if the arrangement
is relatively sparse (when \f$k\f$ is bounded by \f$\frac{m^2}{\log
m}\f$), but in practice it is recommended to use this aggregated
construction process even for dense arrangements, since the
sweep-line algorithm needs less geometric operations compared to
the incremental insertion algorithms and hence typically runs
much faster in practice.

Another important advantage the aggregated insertion functions
have is that they do not issue point-location queries. Thus, no
point-location object needs to be attached to the arrangement. As
explained in Section \ref arr_ssecpl, there is a trade-off
between construction time and query time in each of the
point-location strategies, which affects the running times of the
incremental insertion process. Naturally, this trade-off is irrelevant
in case of aggregated insertion as above.

The example below shows how to construct the arrangement of
line segments depicted in \cgalFigureRef{arr_figex_8} and built
incrementally in `incremental_insertion.cpp`, as shown in the previous
section. We use the aggregated insertion function
`insert()` as we deal with line segments.
Note that no point-location object needs to be defined and attached to the
arrangement:

\cgalExample{Arrangement_on_surface_2/aggregated_insertion.cpp}

In case we have to insert a set of \f$m\f$ curves into an existing
arrangement, where we denote the number of edges in the arrangement by
\f$N\f$.  As a rule of thumb, if \f$m = o(\sqrt{N})\f$, we insert the
curves one by one. For larger input sets, we use the aggregated
insertion procedures.

\cgalFigureBegin{arr_figex_unb1,ex_10.png}
An arrangement of intersecting line segments, as constructed in
`global_insertion.cpp`. The segments of \f${\mathcal S}_1\f$ are
drawn in solid lines and the segments of \f${\mathcal S}_2\f$ are
drawn in dark dashed lines. Note that the segment \f$ s\f$ (light
dashed line) overlaps one of the segments in \f${\mathcal S}_1\f$.
\cgalFigureEnd

In the example below we aggregately construct an arrangement of a set
\f${\mathcal S}_1\f$ containing five line segments. Then we insert a
single segment using the incremental insertion function. Finally, we
add a set \f${\mathcal S}_2\f$ with five more line segments in an
aggregated fashion.  Notice that the line segments of \f${\mathcal
S}_1\f$ are pairwise interior-disjoint, so we use
`insert_non_intersecting_curves()`.  \f${\mathcal S}_2\f$ also contain
pairwise interior-disjoint segments, but as they intersect the
existing arrangement, we have to use `insert()` to insert them. Also
note that the single segment \f$s\f$ we insert incrementally overlaps
an existing arrangement edge:

\cgalExample{Arrangement_on_surface_2/global_insertion.cpp}

The number type used in the example above,
`Quotient<MP_Float>`, is comprised of a numerator and a
denominator of type `MP_Float`, namely floating-point numbers
with unbounded mantissa. This number type is therefore capable of
exactly computing the intersection points as long as the segment
endpoints are given as floating-point numbers.

\subsection arr_ssecgl_remove Removing Vertices and Edges

The free functions `remove_vertex()` and `remove_edge()` handle
the removal of vertices and edges from an arrangement. The difference
between these functions and the member functions of the `Arrangement_2`
template having the same name is that they allow the merger of two curves
associated with adjacent edges to form a single edge. Thus, they require
that the traits class that instantiates the arrangement instance is a model
of the refined `ArrangementXMonotoneTraits_2` concept (see
Section \ref aos_sec-geom_traits).

The function `remove_vertex(arr, v)` removes the vertex `v` from the
given arrangement `arr`, where `v` is either an isolated vertex or is
a <em>redundant</em> vertex - namely, it has exactly two incident
edges that are associated with two curves that can be merged to form a
single \f$x\f$-monotone curve.  If neither of the two cases apply, the
function returns an indication that it has failed to remove the
vertex.

The function `remove_edge(arr, e)` removes the edge `e`
from the arrangement by simply calling `arr.remove_edge(e)`
(see Section \ref arr_ssecmodify). In addition, if either of the
end vertices of `e` becomes isolated or redundant after the removal
of the edge, it is removed as well.

\image html h_shape.png
\image latex h_shape.png

The following example demonstrates the usage of the free removal
functions. In creates an arrangement of four line segment forming
an H-shape with a double horizontal line. Then it removes the two
horizontal edges and clears all redundant vertices, such that the
final arrangement consists of just two edges associated with the
vertical line segments:

\cgalExample{Arrangement_on_surface_2/global_removal.cpp}

\section aos_sec-unbounded Arrangements of Unbounded Curves

Previous sections dealt only with arrangements of line segments,
namely of bounded curves. Such arrangements always have one unbounded
face that contains all other arrangement features. This section
explains how to construct arrangements of unbounded curves, such as
lines and rays.

\subsection arr_ssecunb_basic Basic Manipulation and Traversal Methods

Consider the arrangement induced by the two lines \f$y = x\f$ and \f$y
= -x\f$. These two lines intersect at the origin, such that the
arrangement contains a single vertex \f$v = (0,0)\f$, with four
infinite rays emanating from it. Each ray corresponds to an
arrangement edge, and these edges subdivide the plane into four
unbounded faces.  Consider a halfedge pair that represents one of the
edges. The source vertex of one of these halfedges is \f$v\f$ and its
target is at infinity, while the other has its source at infinity and
\f$v\f$ is its target.

If `e` is an object of the nested type
`Arrangement_2::Halfedge`, then the predicates
`e.source_at_infinity()` and `e.target_at_infinity()` indicate
whether the halfedge represents a curve with an end at infinity.
In general there is no need to access the source (or the target) of a
halfedge if it lies at infinity, since this vertex is not associated
with any valid point. Similarly, calling `arr.number_of_vertices()`
for an arrangement object `arr` counts only the vertices
associated with finite points, and ignores vertices at infinity
(and the range `[vertices_begin(), vertices_end())` contains only
finite vertices). The method `arr.number_of_vertices_at_infinity()`
counts the number of vertices at infinity.

As mentioned above, arrangements of unbounded curves usually have more
than one unbounded face. The function `arr.number_of_unbounded_faces()`
returns the number of unbounded arrangement faces
(Thus, `arr.number_of_faces() - arr.number_of_unbounded_faces()`
is the number of bounded faces).
The functions `arr.unbounded_faces_begin()` and
`arr.unbounded_faces_end()` return iterators of type
`Arrangement_2::Unbounded_face_iterator` that specify the range
of unbounded faces. Naturally, the value-type of this iterator is
`Arrangement_2::Face`.

The specialized insertion functions listed in Section \ref
arr_sssecmf_insert_cv can also be used for inserting \f$x\f$-monotone
unbounded curves, provided that they are interior-disjoint from any
subcurve that already exists in the arrangement. For example, if you
wish to insert a ray \f$r\f$ emanating from \f$(0,0)\f$ in the
direction of \f$(1,0)\f$, to the arrangement of \f$y = -x\f$ and \f$y
= x\f$, you can use the function `arr.insert_from_left_vertex()`, as
the left endpoint of \f$r\f$ is already associated with an arrangement
vertex.  Other edge-manipulation functions can also be applied on
edges associated with unbounded curves.

\cgalFigureBegin{arr_figunb_dcel,ex_unb1.png}
An arrangement of unbounded linear objects, as constructed in unbounded_non_intersecting.cpp.
\cgalFigureEnd

The following example demonstrates the use of the insertion function
for pairwise interior-disjoint unbounded curves. In this example we
use the traits class `Arr_linear_traits_2<Kernel>` to instantiate the
`Arrangement_2` template. This traits class is capable of representing
line segments as well as unbounded linear curves (namely lines and
rays). Observe that objects of the type `X_monotone_curve_2` defined
by this traits class are constructible from `Line_2`, `Ray_2`, and
`Segment_2` objects, as defined in the instantiated kernel.

The first three curves are inserted using the special insertion
functions for \f$ x\f$-monotone curves whose location in the
arrangement is known. Notice that inserting an unbounded curve in the
interior of an unbounded face, or from an existing vertex that
represents the bounded end of the curve, may cause an unbounded face
to split (this is never the case when inserting a bounded curve -
compare with Section \ref arr_sssecmf_insert_cv). Then, three
additional rays are inserted incrementally, using the insertion
function for \f$ x\f$-monotone curves whose interior is disjoint from
all arrangement features.  Finally, the program prints the size of the
arrangement (compare to the illustration in
\cgalFigureRef{arr_figex_unb1}) and the outer boundaries of its six
unbounded faces:

\cgalExample{Arrangement_on_surface_2/unbounded_non_intersecting.cpp}

\subsection arr_ssecunb_global Free Functions

In principle, all queries and operations that relate to arrangements
of bounded curves can also be applied to arrangements of unbounded
curves. For example, it is possible to issue point-location and
vertical ray-shooting queries (see also Section \ref arr_secqueries)
on arrangements of lines, where the only restriction is that the query
point has finite coordinates.\cgalFootnote{Currently, all
point-location strategies except the trapezoidal RIC point-location
strategy are capable of handling arrangements of unbounded curves.}

In the following example we show how an arrangement of unbounded lines
is utilized to solve the following problem: Given a set of points,
does the set contain at least three collinear points? In this example
a set of input points is read from a file. The file `points.dat` is
used by default. It contains definitions of \f$100\f$ points randomly
selected on the grid \f$[-10000,10000]\times[-10000,10000]\f$. We
construct an arrangement of the dual lines, where the line \f$p^{*}\f$
dual to the point \f$p = (p_x, p_y)\f$ is given by the equation \f$y =
p_x*x - p_y\f$, and check whether three (or more) of the dual lines
intersect at a common point, by searching for a (dual) vertex, whose
degree is greater than \f$4\f$. If such a vertex exists, then there
are at least three dual lines that intersect at a common point, which
implies that there are at least three collinear points.

\cgalExample{Arrangement_on_surface_2/dual_lines.cpp}

Note that there are no three collinear points among the points defined
in the input file `points.dat`. In the second part of the example the
existence of collinearity is forced and verified as follows. A line
dual to the midpoint of two randomly selected points is introduced,
and inserted into the arrangement. This operation is followed by a
test that verifies that a vertex of degree greater than \f$4\f$
exists. This implied that collinearity indeed exists as explained
above.

\subsection arr_ssecunb_rep Representation of Unbounded Arrangements
\cgalAdvancedBegin

\cgalFigureBegin{typenormal,unb_dcel.png}
A \sc{Dcel} representing an arrangement of four lines. Halfedges are
drawn as thin arrows. The vertices \f$v_1, \ldots, v_8\f$ lie at
infinity, and are not associated with valid points. The halfedges that
connect them are fictitious, and are not associated with concrete
curves. The face denoted \f$f_0\f$ (lightly shaded) is the fictitious
"unbounded face" which lies outside the bounding rectangle (dashed)
that bounds the actual arrangement. The four fictitious vertices
\f$v_{\rm bl}, v_{\rm tl}, v_{\rm br}\f$ and \f$v_{\rm tr}\f$
represent the four corners of the bounding rectangle.
\cgalFigureEnd

Given a set \f$\cal C\f$ of unbounded curves, a simple approach for
representing the arrangement induced by \f$\cal C\f$ would be to clip
the unbounded curves using an axis-parallel rectangle that contains
all finite curve endpoints and intersection points between curves in
\f$\cal C\f$. This process would result in a set \f$\cal C\f$ of
bounded curves (line segments if \f$\cal C\f$ contains lines and
rays), and it would be straightforward to compute the arrangement
induced by this set.  However, we would like to operate directly on
the unbounded curves without having to preprocess them. Therefore, we
use an implicit bounding rectangle embedded in the \sc{Dcel}
structure.  \cgalFigureRef{arr_figunb_dcel} shows the arrangement of
four lines that subdivide the plane into eight unbounded faces and two
bounded ones. Notice that in this case the unbounded faces have outer
boundaries, and the halfedges along these outer CCBs are drawn as
arrows. The bounding rectangle is drawn with a dashed line. The
vertices \f$v_1,v_2,\ldots,v_8\f$, which represent the unbounded ends
of the four lines, and lie on the bounding rectangle, actually exist
at infinity, and the halfedges connecting them are <em>fictitious</em>,
and represent portions of the bounding rectangle. Note that the outer
CCBs of the unbounded faces contain fictitious halfedges. The twins of
these halfedges form together one connected component that corresponds
to the entire bounding rectangle, which forms a single hole in a face
\f$f_0\f$. We say that \f$f_0\f$ is <em>fictitious</em>, as it does
not correspond to a real two-dimensional cell of the arrangement.

Observe that there are four extra vertices at infinity that do not lie
on any curve; they are denoted as \f$v_{\rm bl}, v_{\rm tl}, v_{\rm
br}\f$, and \f$v_{\rm tr}\f$, and represent the bottom-left, top-left,
bottom-right, and top-right corners of the bounding rectangle,
respectively. Similarly, there are fictitious halfedges that lie on
the top, the bottom, the left, or the right edge of the bounding
rectangle. When the arrangement is empty, there are exactly four pairs
of fictitious halfedges, that divide the plane into two faces, namely
a fictitious face lying outside of the bounding rectangle and a single
unbounded face bounded by the bounding rectangle.

Summarizing the above, there are four types of arrangement vertices,
which differ from one another by their location with respect to the
bounding bounding rectangle:
<OL>
<LI>A vertex, associated with a point in \f$\mathbb{R}^2\f$ whose
coordinates are bounded. Such a vertex always lies inside the
bounding rectangle.

<LI> \anchor typeunbounded A vertex that represents an unbounded end
of an \f$x\f$-monotone curve that is defined at \f$x = -\infty\f$ or
at \f$x = \infty\f$. In case of a horizontal line or a curve with a
horizontal asymptote, the \f$y\f$-coordinate of the curve end may be
finite (see for example the vertices \f$v_2\f$ and \f$v_7\f$ in
\cgalFigureRef{arr_figunb_dcel}), but in general the curve end also
goes to \f$y = \pm\infty\f$ (see for instance the vertices \f$v_1\f$,
\f$v_3\f$, \f$v_6\f$ and \f$v_8\f$ in
\cgalFigureRef{arr_figunb_dcel}). For our convenience, we will always
take a "tall" enough bounding rectangle and treat such vertices as
lying on either the left or right rectangle edges (that is, if a curve
is defined at \f$x = -\infty\f$, its left end will be represented by a
vertex on the left edge of the bounding rectangle, and if it is
defined at \f$x = \infty\f$, its right end will be represented by a
vertex of the right edge).

<LI> \anchor typeunboundedvertical A vertex that represent the
unbounded end of a vertical line or of a curve with a vertical
asymptote (finite \f$x\f$-coordinate and an unbounded
\f$y\f$-coordinate). Such a vertex always lies on one of the
horizontal edges of the bounding rectangle (either the bottom one if
\f$y = -\infty\f$, or the top one if \f$y = \infty\f$). The vertices
\f$v_4\f$ and \f$v_5\f$ in \cgalFigureRef{arr_figunb_dcel} are of this
type.

<LI> \anchor typefictitious The fictitious vertices that
represent the four corners of the bounding bounding rectangle.  </OL>

A vertex (at infinity) of Type \ref typeunbounded or Type \ref
typeunboundedvertical above always has three incident edges: one
concrete edge that is associated with an unbounded portion of an
\f$x\f$-monotone curve, and two fictitious edges connecting the vertex
to its neighboring vertices at infinity.  Fictitious vertices (of type
4 above) have exactly two incident edges.  See Section \ref
aos_sec-geom_traits on how the traits-class interface helps imposing
the fact that we never have more than one curve incident to any true
vertex at infinity.

The nested types defined in the `Arrangement_2` class support the
following methods, in addition to the ones listed in
Section \ref arr_ssectraverse :
<UL>
<LI>The `Vertex` class provides three-valued predicates
`parameter_space_in_x()` and `parameter_space_in_y()`, which
return the location of the geometric embedding of the vertex in the
parameter space. In particular, the former returns
`ARR_LEFT_BOUNDARY`, `ARR_INTERIOR`, or
`ARR_RIGHT_BOUNDARY`, and the latter returns
`ARR_BOTTOM_BOUNDARY`, `ARR_INTERIOR`, or
`ARR_TOP_BOUNDARY`. As the package currently supports only the
case where the parameter space is the compactified plane, the former
returns `ARR_INTERIOR` if the \f$x\f$-coordinate associated with the
vertex is finite, `ARR_LEFT_BOUNDARY` if it is \f$-\infty\f$, and
`ARR_RIGHT_BOUNDARY` if it is \f$\infty\f$. The latter returns
`ARR_INTERIOR` if the \f$y\f$-coordinate associated with the vertex
is finite, `ARR_BOTTOM_BOUNDARY` if it is \f$-\infty\f$, and
`ARR_TOP_BOUNDARY` if it is \f$\infty\f$. The Boolean predicate
`is_at_open_boundary()` is also provided. You can access the
point associated with a vertex only if it is not a vertex at an open
boundary (recall that a vertex at an open boundary is not associated
with a `Point_2` object).
<LI>The nested `Halfedge` class provides the Boolean predicate
`is_fictitious()`. The \f$x\f$-monotone curve associated with
a halfedge can be accessed by the `curve()` method only if the
halfedge is not fictitious.
<LI>The nested `Face` class provides the Boolean predicate
`f.is_fictitious()`. The method `outer_ccb()` has the
precondition that the face is not fictitious. Note that non-fictitious
unbounded faces always have valid CCBs (although this CCB may
comprise only fictitious halfedge in case the arrangement contains
only bounded curves).
</UL>

The method `arr.number_of_edges()` does not count the number of
fictitious edges, (which is always
`arr.number_of_vertices_at_infinity() + 4`), and the iterators
returned by `arr.edges_begin()` and `arr.edges_end()` specify
a range of non-fictitious edges. Similarly, `arr.number_of_faces()`
does not count the fictitious face. However, the
`Ccb_halfedge_circulator` of the outer boundary of an
unbounded face or the `Halfegde_around_vertex_circulator` of a vertex
at infinity do traverse fictitious halfedges. For example, it is possible
to traverse the outer boundaries of the unbounded arrangement edges
using the following procedure:

\code
  Arrangement_2::Unbounded_face_const_iterator fit;
  Arrangement_2::Ccb_halfedge_const_circulator first, curr;
  Arrangement_2::Halfedge_const_handle he;
  int k = 1;

  for (fit = arr.unbounded_faces_begin();
       fit != arr.unbounded_faces_end(); ++fit, k++) {
    std::cout << "Unbounded face no. " << k << ": ";
    curr = first = fit->outer_ccb();
    if (! curr->source()->is_at_infinity())
      std::cout << "(" << curr->source()->point() << ")";
    do {
      he = curr;
      if (! he->is_fictitious())
        std::cout << " [" << he->curve() << "] ";
      else
        std::cout << " [ ... ] ";

      if (! he->target()->is_at_infinity())
        std::cout << "(" << he->target()->point() << ")";

      ++curr;
    } while (curr != first);
    std::cout << std::endl;
}
\endcode
\cgalAdvancedEnd

\section aos_sec-curved_surfaces Arrangements on Curved Surfaces

We are given a surface \f$S\f$ in \f$\mathbb{R}^3\f$ and a set \f$\cal
C \f$ of curves embedded on this surface. The curves subdivide \f$S\f$
into cells of dimension 0 (<em>vertices</em>), 1 (<em>edges</em>), and
2 (<em>faces</em>). This subdivision is the <em>arrangement</em>
\f$\cal A(\cal C) \f$ induced by \f$\cal C\f$ on \f$S\f$. Arrangements
embedded on curved surfaces in \f$\mathbb{R}^3\f$ are generalizations
of arrangements embedded in the plane. In this section we explain how
to construct, maintain, and manipulate two-dimensional arrangements
embedded on orientable parametric surfaces in three dimensions, such
as planes, cylinders, spheres, and tori, and surfaces homeomorphic to
them; see Figure \cgalFigureRef{aos_fig-surfaces}. Such arrangements
have many theoretical and practical applications; see, e.g.,
\cgalCite{as-aa-00}, \cgalCite{cgal:bfhks-apsca-10},
\cgalCite{cgal:bfhmw-apsgf-10}, \cgalCite{cgal:fhktww-a-07}, and
\cgalCite{cgal:h-a-04}.

\cgalFigureAnchor{aos_fig-surfaces}
<center>
<table border=0>
<tr>
<td>\image html sphere.png</td>
<td>\image html cylinder.png</td>
<td>\image html cone.png</td>
<td>\image html ellipsoid.png</td>
<td>\image html torus.png</td>
<td>\image html paraboloid.png</td>
<tr align="center">
<td>(a) Sphere</td>
<td>(b) Cylinder</td>
<td>(c) Cone</td>
<td>(d) Ellipsoid</td>
<td>(e) Torus</td>
<td>(f) Paraboloid</td>
</tr>
</table>
</center>
\cgalFigureCaptionBegin{aos_fig-surfaces}
Various two-dimensional parametric surfaces, arrangements on which
are supported by the framework.
\cgalFigureCaptionEnd

\subsection aos_ssec-curved_surfaces-parameteric Parametric Surfaces

We use \f$\overline{\mathbb{R}}\f$ to denote the compactified real line
\f$\mathbb{R} \cup \{-\infty,+\infty\}\f$. The mapping
\f$x \mapsto x/(1 - x^2)\f$ is a homeomorphism between
\f$(-1,+1)\f$ and \f$\mathbb{R}\f$ and between \f$[-1,+1]\f$ and
\f$\overline{\mathbb{R}}\f$. So you may also think of finite intervals
instead of the (compactified) real line in what follows.

A parametric surface \f$S\f$ is given by a continuous function
\f$\phi_S: \Phi \rightarrow \mathbb{R}^3\f$, where the domain \f$\Phi
= X \times Y\f$ is a rectangular two-dimensional parameter space; \f$S
= \phi_S(\Phi)\f$. \f$X\f$ and \f$Y\f$ are open, half-open, or closed
intervals with endpoints in \f$\overline{\mathbb{R}}\f$. We use
\f$x_{\rm min}\f$, \f$x_{\rm max}\f$, \f$y_{\rm min}\f$, and \f$y_{\rm
max}\f$ to denote the endpoints of \f$X\f$ and \f$Y\f$, respectively.

<ul>

<li>The left side of the boundary of \f$\Phi\f$ consists of the points
\f$(x_{\rm min},y)\f$ with \f$y \in {\rm closure}(Y)\f$. It is
<em>open</em>, if \f$x_{\rm min} \not\in X\f$ or \f$y\not\in Y\f$, and
<em>closed</em>, otherwise. The right side is defined analogously.
The bottom side consists of the points \f$(x, y_{\rm min})\f$ with
\f$x \in (x_{\rm min},x_{\rm max})\f$; the top side is defined
analogously. Bottom and top side can also be open. Note that the
"corners" of the parameter space belong to the vertical sides; this
asymmetry corresponds to the fact, that we sweep \f$x\f$-monotone
curves, and not \f$y\f$-monotone curves. The four sides together form
the boundary \f$\partial \Phi\f$.</li>

<li>A point \f$p \in S\f$ is <em>regular</em> if it has only one
pre-image. All pre-images of a non-regular point lie in the boundary
of \f$\Phi\f$. In particular, \f$\phi_S\f$ is bijective on
\f$(x_{\rm min},x_{\rm max})\times(y_{\rm min},y_{\rm max})\f$.
More precisely, a non-regular point has either exactly two pre-images
that lie on opposite sides of the domain, or all points of exactly one
side of the domain.</li>

</ul>

A side of the domain is contracted, if \f$\phi_S\f$ is constant on it.
The image of the side is called a <em>contraction point</em>.

The bottom and top sides of the domain (similarly for the left and
right sides) are <em>identified</em>, if
\f$\phi_S(x,y_{\rm min}) = \phi_S(x,y_{\rm max})\f$ for all
\f$x \in X \f$. The curve \f$x \mapsto \phi_S(x,y_{\rm min})\f$ is
called an <em>identification curve</em>.

Rectangles, strips, quadrants, half-planes, and planes can be modeled
with \f$\phi_S \f$ being the identity mapping. For example,
\f$\Phi_S(x, y) = (x, y, 0)\f$ with \f$X = Y =(-\infty, +\infty)\f$
parameterizes the plane. Surfaces such as paraboloids can be
modeled through continuous and bijective parameterizations, for
example, \f$\phi_S(x,y) = (x,y,x^2 + y^2)\f$, where
\f$U = V =(-\infty, +\infty)\f$, defines a paraboloid of revolution.
Cylinders, tori, spheres, and surfaces homeomorphic to them, require
more general parameterizations. For example, the unit sphere is
commonly parameterized as
\f$\phi_S(x, y) = (\cos x \cos y, \sin x \cos y, \sin y)\f$, where
\f$\Phi = [-\pi, \pi] \times [-\frac{\pi}{2}, \frac{\pi}{2}]\f$. With
respect to this parameterization, the north and the south pole and
all points on the opposite Prime (Greenwich) Meridian are
non-regular. The north pole \f$(0,0,1)\f$ has infinitely many
pre-images \f$(x, \pi/2)\f$ with \f$-\pi < x < \pi\f$ and so does the
south pole \f$(0,0,-1)\f$. The points on the opposite Prime Meridian
have two pre-images each, namely \f$(-\pi,y)\f$ and \f$(\pi,y)\f$
with \f$-\pi/2 \leq y \leq \pi/2\f$. We say that the upper and lower
side of the domain are <em>contracted</em> and the left and right sides
are <em>identified</em>. These are exactly the kinds of non-injectivity
that we allow.

We give more examples. A <em>triangle</em> with corners
\f$(a_1, b_1), (a_2, b_2)\f$, and \f$(a_3, b_3)\f$ can be
parameterized via \f$\Phi = [0,1] \times [0,1]\f$ with
\f$\phi_S(x,y) = (a_1 + x(a_2 - a_1) + xy(a_3-a_2), b_1 +
x(b_2 - b_1) + xy(b_3-b_2), 0)\f$. The left side of the rectangular
domain contracts to a point. An open or closed <em>cylinder</em> is
modelled by identifying the vertical sides and having \f$Y\f$ open or
closed, respectively. A <em>torus</em> is modelled by identifying the
vertical sides and the horizontal sides. A <em>paraboloid</em> or
<em>half-cone</em> may be modelled by identifying the vertical sides
and contracting one of the horizontal sides to a point. More elegantly,
they are modelled by a bijective parameterization as given above. A
<em>sphere</em> is modelled by identifying the vertical sides and
contracting both horizontal sides. A <em>croissant</em>, a torus with
one pinch point, is modelled by identifying the vertical and
identifying the horizontal sides and, in addition, contracting one of
the pairs. However, the croissant is excluded by our definitions. All
surfaces supported by our framework are locally homeomorphic to a
disk, and hence an \sc{EDcel} data-structure suffices for representing
arrangements on these surfaces. The croissant is, at the pinch point,
not locally homeomorphic to a disk, and hence a more general
cell-tuple data structure than an \sc{EDcel} would be needed.

A curve \f$\gamma\f$ is a continuous function \f$\gamma: I \rightarrow
\Phi\f$, where \f$I\f$ is an open, half-open, or closed interval with
endpoints 0 and 1, and \f$\gamma\f$ is injective except for at a
finite number of points. If \f$0 \not\in I\f$, \f$\lim_{t \rightarrow
0+} \gamma(t)\f$ exists (in the closure of \f$\Phi\f$) and lies in an
open side of the boundary. Similarly, if \f$1 \not\in I\f$, \f$\lim_{t
\rightarrow 1-} \gamma(t)\f$ exists and lies in an open side of the
boundary. A curve \f$C\f$ in \f$S\f$ is the image of a curve
\f$\gamma\f$ in the domain.

A curve is <em>closed in the domain</em> if \f$\gamma(0) =
\gamma(1)\f$; in particular, \f$0 \in I\f$ and \f$1 \in I\f$. A curve
is <em>closed in the surface \f$S\f$ (or simply closed)</em> if
\f$\phi_S(\gamma(0)) = \phi_S(\gamma(1))\f$. A curve \f$\gamma\f$ has
two <em>ends</em>, the 0-end \f$\langle \gamma,0 \rangle\f$ and the
1-end \f$\langle \gamma,1 \rangle\f$. If \f$d \in I\f$, the
\f$d\f$-end has a geometric interpretation. It is a point in
\f$\Phi\f$. If \f$d \not\in I\f$, the \f$d\f$-end has no geometric
interpretation. You may think of it as a point on an open side of the
domain or an initial or terminal segment of \f$\gamma\f$. If \f$d
\not\in I\f$, we say that the \f$d\f$-end of the curve is open. The
equator curve on the sphere in standard parameterization is given by
\f$\gamma(t) = (\pi(2t - 1),0)\f$ for \f$t \in [0,1]\f$. The
\f$0\f$-end of \f$\gamma\f$ is the point \f$(-\pi,0)\f$ in \f$\Phi\f$
and a point on the equator of the sphere. It is closed on the sphere,
but non-closed in \f$\Phi\f$. The diagonal \f$(u,u)\f$ in the plane
is, for example, given by \f$\gamma(t) = (x(t),y(t))\f$ and \f$x(t) =
y(t) = (t - 1/2)/(t(1-t))\f$.  Both ends of this curve are open. The
\f$d\f$-end of a curve \f$\gamma\f$ is incident to the left side if
either \f$d \in I\f$ and \f$\gamma(d)\f$ lies on the left side or \f$d
\not\in I\f$ and \f$\lim_{t \rightarrow d} \gamma(t)\f$ lies on the
left side, which is then an open side. Similarly for the other sides.

A <em>strongly \f$x\f$-monotone curve</em> is the image of a curve
\f$\gamma\f$, such that if \f$t_1 < t_2\f$, then \f$x(t_1) <
x(t_2)\f$. A <em>vertical curve</em> is the image of a curve
\f$\gamma\f$, such that \f$x(t) = C\f$ for all \f$t \in I\f$ and some
\f$C \in X\f$ and \f$y(t_1) < y(t_2)\f$ for \f$t_1 < t_2\f$. For
instance, every Meridian curve of a sphere parameterized as above is
vertical. A <em>\f$x\f$-monotone curve</em> is either vertical or
strongly \f$x\f$-monotone.

\subsection aos_ssec-curved_surfaces-aos_class The Arrangement on Surface Class Template

The class template `Arrangement_on_surface_2<GeomTraits, TopolTraits>`
can be used to represent a 2D arrangement embedded in a 3D
surface. The template is parameterized by template parameters
<em>geometry traits</em> and <em>topology traits</em>. The
topology-traits type deals with the topology of the parametric
surface. As explained in the previous section, a parametric surface
\f$S \f$ is given by a continuous function \f$\phi_S: \Phi \rightarrow
\mathbb{R}^3\f$, where the domain \f$\Phi = X \times Y\f$ is a
rectangular two-dimensional parameter space; \f$S =
\phi_S(\Phi)\f$. \f$X\f$ and \f$Y\f$ are open, half-open, or closed
intervals with endpoints in \f$\overline{\R} \f$.

The geometry-traits type introduces the type names of the basic
geometric objects (i.e., point, curve, and \f$u \f$-monotone curve)
and the set of operations on objects of these types required to
construct and maintain the arrangement and to operate on it. The
traits-concept hierarchy described in Section \ref aos_sec-geom_traits
accurately define the requirements imposed on an instantiated geometry
traits class. Recall that requirements apply to the parameter space
\f$\Phi = X \times Y\f$; thus, they are defined in terms of \f$x\f$
and \f$y\f$ coordinates.  Most requirements apply to all type of
arrangements regadless of the embedding surface. However, several
refined concepts apply only to arrangements on surfaces that are not
the plane, that is, modeled with \f$\phi_S\f$ not being the identity
mapping. They differ according to the type of the side boundaries of
the parameter space being open, closed, constracted, or identified.

At this point only one type of arrangements on non planar surfaces is
supported, namely, arrangements embedded on the sphere and induced by
arcs of great circles, aka geodesic arcs. Figure
\cgalFigureRef{aos_fig-voronoi} shows various Voronoi diagrams the
bisectors of which are geodesic arcs.  They are represented as
arrangements induced by geodesic arcs embedded on the sphere.

\cgalFigureAnchor{aos_fig-voronoi}
<center>
<table border=0>
<tr>
<td>\image html voronoi.jpg</td>
<td>\image html degenerate_voronoi.jpg</td>
<td>\image html power_diagram.jpg</td>
<td>\image html degenerate_power_diagram.jpg</td>
<tr align="center">
<td>(a)</td>
<td>(b)</td>
<td>(c)</td>
<td>(d)</td>
</tr>
</table>
</center>
\cgalFigureCaptionBegin{aos_fig-voronoi}
Voronoi diagrams on the sphere.
All diagram edges are geodesic arcs.
Sites are drawn in red and Voronoi edges are drawn in blue.
(a) The Voronoi diagram of 32 random points.
(b) A highly degenerate case of Voronoi diagram of 30 point sites on the sphere.
(c) The power diagram of 10 random circles.
(d) A degenerate power diagram of 14 sites on the sphere.
\cgalFigureCaptionEnd

\section aos_sec-geom_traits The Geometry Traits

A traits class encapsulates the definitions of the geometric entities
and implements the geometric predicates and constructions needed by
instances of the `Arrangement_on_surface_2` class template and by the
peripheral algorithms that operate on objects of such
instances. Observe that that there are different levels of
requirements from the traits class; namely, the traits class can model
different concept refinement-levels.

This section is divided into three parts. The first part desribes the
refinement hierarchy of the arrangement-traits conepts. The seond part
reviews various models of these conepts. These are traits classes,
which handle different curve families, such as line segments,
polylines, conic arcs, B&eacute;zier curves, algebraic curves, and
geodesic arcs on the sphere. The last part introduces decorators for
geometric traits classes. A decorator of a traits class attaches
auxiliary data to the geometric objects handled by the original traits
class, thereby extending it.

\subsection aos_ssec-geom_traits-concepts The Hierarchy of the Geometry Traits Concepts

\subsubsection aos_sssec-geom_traits-concepts_main The Main Concepts

A rather large direted acyclic graph is required to capture the entire
hierarchy of the geometry traits-class conepts. In the following
sections we review individual clusters of the graph and desribe the
relations between them. Figure
\cgalFigureRef{aos_fig-central_concept_cluster} depicts the central
cluster.

\cgalFigureBegin{aos_fig-central_concept_cluster,central_concept_cluster.png}
The hierarchy of the main geometry traits concepts.
\cgalFigureEnd

\paragraph aos_par-geom_traits-concepts_basic The Basic Concept

A model of the basic concept, `ArrangementBasicTraits_2`, needs to
define the types `%Point_2` and `%X_monotone_curve_2`, where objects
of the first type are the geometric mapping of arrangement vertices,
and objects of the latter type are the geometric mapping of edges. In
addition, it has to support the the set of predicates listed
below. This basic set of predicates is sufficient for constructing
arrangements of bounded \f$x\f$-monotone curves that are pairwise
disjoint in their interiors and points that do not lie in the interior
of the curves. The basic set of predicates is also sufficient for
answering vertical ray-shooting queries and point-location queries
with a small exception: Locating a point using the landmark strategy
requires a traits class that models the concept
`ArrangementLandmarkTraits_2`; see Section \ref
aos_sssec-tr_lanmarks_concept.

<DL>
<DT><B>`Compare_x_2`:</B><DD> Compares the \f$x\f$-coordinates of two points.
<DT><B>`Compare_xy_2`:</B><DD> Compares two points lexicographically, first by
  their \f$x\f$-coordinates, and if they are equal, by their
  \f$y\f$-coordinates.
<DT><B>`Equal_2`:</B><DD> There are two overloaded Boolean operators that
  test equality. One returns true iff two given points represent the same
  geometric point in the plane, and the second returns true iff the graphs
  of two given \f$x\f$-monotone curves are the same.\cgalFootnote{The
  predicate that tests equality between graphs of two \f$x\f$-monotone
  curves is used only for testing as part of the test suite.}
<DT><B>`Construct_min_vertex_2`,`Construct_max_vertex_2`:</B><DD>
  Returns the lexicographically smaller or left (resp. larger or right)
  endpoint of an $x$-monotone curve.
<DT><B>`Is_vertical_2`:</B><DD> Determines whether an \f$x\f$-monotone curve
  is vertical.
<DT><B>`Compare_y_at_x_2`:</B><DD> Given an \f$x\f$-monotone curve \f$C\f$
  and a point \f$p\f$ that lies in the \f$x\f$-range of \f$C\f$, determines
  whether \f$p\f$ lies below, above or on \f$C\f$.
<DT><B>`Compare_y_at_x_right_2`:</B><DD> Given two \f$x\f$-monotone curves
  \f$C_1\f$ and \f$C_2\f$ that share a common minimal (left) endpoint
  \f$p\f$, determines whether \f$C_1\f$ lies above or under \f$C_2\f$
  immediately to the right of \f$p\f$, or whether the two curves overlap
  there.
</DL>

Each model of the concept `ArrangementBasicTraits_2`
needs to define a tag named `Has_left_category`. It determines
whether the traits class supports the following predicate:
<DL>
<DT><B>`Compare_y_at_x_left_2`:</B><DD> Given two \f$x\f$-monotone curves
  \f$C_1\f$ and \f$C_2\f$ that share a common maximal (right) endpoint
  \f$p\f$, determines whether \f$C_1\f$ lies above or under \f$C_2\f$
  immediately to the left of \f$p\f$, or whether the two curves overlap
  there.
</DL>
If the `Has_left_category` type nested in a model of the basic concept
is defined as `Tag_true`\cgalFootnote{In principle, the category type may
only be convertible to the tag type, but in practice the category is
typically explicitly defined as the tag.} the model must support the
predicate. If the type is defined as `Tag_false`, we resort to an internal
version, which is based just on the reduced set of provided operations.
The internal version might be less efficient, but it exempts the traits
developer from the potentially non-trivial task of providing an
(efficient) implementation of this predicate.

The basic set of predicates is sufficient for constructing
arrangements of \f$x\f$-monotone curves that do not reach or approach
the boundary of the parameter space. The nature of the input curves,
whether they are expected to reach or approach the left, right,
bottom, or top side of the boundary of the parameter space, must be
conveyed by the traits class. This is done through the definition of
four additional nested types, namely `Left_side_category`,
`Right_side_category`, `Bottom_side_category`, and
`Top_side_category`. Each of those types must be convertible to the
type `Arr_oblivious_side_tag` for the class to be a model of the
concept `ArrangementBasicTraits_2`.

\paragraph aos_par-geom_traits-concepts_intersecting Intersecting x-Monotone Curves}

Constructing an arrangement induced by \f$x\f$-monotone curves that
may intersect in their interior requires operations that are not
listed by the `ArrangementBasicTraits_2` concept. The additional
operations are listed by the concept `ArrangementXMonotoneTraits_2`,
which refines the basic arrangement-traits concept described above.
While models of the `ArrangementXMonotoneTraits_2` concept still
handle only \f$x\f$-monotone curves, the curves are not restricted to
be disjoint in their interiors. Such a model must be capable of
computing points of intersection between \f$x\f$-monotone curves,
splitting curves at these intersection points to obtain pairs of
interior-disjoint subcurves, and optionally merging pairs of
subcurves. A point of intersection between two curves is also
represented by the `%Point_2` type. A model of the refined concept must
define an additional type called `Multiplicity`.  An object of this
type indicates the multiplicity of the intersection point of two
curves, also referred to as the <em>intersection
number</em>.\cgalFootnote{See,
e.g., http://en.wikipedia.org/wiki/Intersection_number for more
information about intersection numbers.} Loosely speaking, if two
curves intersect at a point \f$p\f$ but have different tangents (first
derivatives) at \f$p\f$, \f$p\f$ is of multiplicity 1. If the curve
tangents are equal but their curvatures (second derivatives) are not,
\f$p\f$ is of multiplicity 2, and so on. The multiplicity of points of
intersection between line segments is always 1, and the multiplicity
of a point of intersection between two polylines is 1 if the
intersection point is interior to the corresponding two line segments
of the polylines, and undefined (coded as 0) otherwise. A model of the
refined concept thus has to support the following additional
operations:

<DL>
<DT><B>`Split_2`:</B><DD> Splits an \f$x\f$-monotone curve \f$C\f$ at a
  given point \f$p\f$, which lies in the interior of \f$C\f$, into two
  subcurves.
<DT><B>`Are_mergeable_2`:</B><DD> Determines whether two \f$ x\f$-monotone
  curves \f$C_1\f$ and \f$C_2\f$ that share a common endpoint can be
  merged into a single continuous \f$x\f$-monotone curve representable by
  the traits class.\cgalFootnote{On the face of it this seems a difficult
  predicate to implement. In practice we use very simple tests to decide
  whether two curves are mergeable: We check whether their underlying
  curves are identical and whether they do not bend to form a
  non-\f$x\f$-monotone curve.}
<DT><B>`Merge_2`:</B><DD> Merges two mergeable \f$x\f$-monotone curves
  into a single curve.
<DT><B>`Intersection_2`:</B><DD> Computes all intersection points and
  overlapping sections of two given \f$x\f$-monotone curves. If possible,
  computes also the multiplicity of each intersection point. Providing
  the multiplicity of an intersection point is not required, but it can
  expedite the arrangement construction. Typically, the multiplicity is
  a byproduct of the intersection computation. However, if it is not
  available, undefined multiplicity (coded as 0) is assumed. Having the
  multiplicity of intersection points while constructing arrangements
  enables the exploitation of the geometric knowledge intersection points
  may have.
</DL>
Using a model of the `ArrangementXMonotoneTraits_2` it is
possible to construct arrangements of sets of \f$x\f$-monotone curves
(and points) that may intersect one another. The two operations
listed above, regarding the merging of curves, are optional, and should
be provided only if the type `Has_merge_category` nested in a model of
the `ArrangementXMonotoneTraits_2` concept is defined as `Tag_true`.
Otherwise, it is not possible to merge \f$x\f$-monotone curve and
redundant vertices may be left in the arrangement due to the removal of
edges.

\paragraph aos_par-geom_traits-concepts_arbitrary Arbitrary Curves

The concept `ArrangementTraits_2` refines the
`ArrangementXMonotoneTraits_2` concept. A model of the refined concept
must define an additional type that is used to represent general, not
necessarily \f$x\f$-monotone and not necessarily connected, curves,
named `Curve_2`. It also has to support the subdivision of a curve of
that type into a set of continuous \f$x\f$-monotone curves and
isolated points. For example, the curve \f$C:\ (x^2 + y^2)(x^2 + y^2 -
1) = 0\f$ comprises the unit circle (the locus of all points for which
\f$x^2 + y^2 = 1\f$) and the origin \f$(0,0)\f$. \f$C\f$ should
therefore be subdivided into two circular arcs, the upper part and the
lower part of the unit circle, and a single isolated point.  In
particular a model of the refined concept has to support the following
additional operation:

<DL>
<DT><B>`Make_x_monotone_2`:</B><DD> Divides a given general curve of type
  `Curve_2` into continuous weakly \f$x\f$-monotone curves and isolated points.
</DL>

Note that the a model of the refined concept `ArrangementTraits_2` is
required only when using the free `insert()` functions (see Section \ref
arr_secgl_funcs), which accept an object of type `Curve_2` or a range
of objects of that type. In all other cases it is sufficient to use a
model of the `ArrangementXMonotoneTraits_2` concept.

\subsubsection aos_sssec-tr_lanmarks_concept The Landmarks Concept

\cgalFigureBegin{aos_fig-landmark_concept_cluster,landmark_concept_cluster.png}
The traits-concept hierarchy for arrangements associated with the landmark
point-location strategy.
\cgalFigureEnd

The type of an arrangement associated with the landmark point-location
strategy (see Section \ref arr_ssecpl) must be an instance of the
`Arrangement_on_surface_2<GeomTraits, TopolTraits>` class template,
where the `GeomTraits` parameter is substituted with a model of the
concept `ArrangementLandmarkTraits_2`. (Naturally, it can also model
either the `ArrangementXMonotoneTraits_2` concept or the
`ArrangementTraits_2` concept.) The `ArrangementLandmarkTraits_2`
concept refines the two concepts `ArrangementApproximateTraits_2` and
`ArrangementConstructXMonotoneCurveTraits_2`. Each of these two
concepts, in turn, refines the concept `ArrangementBasicTraits_2`.

A model of the `ArrangementApproximateTraits_2` concept must define a
fixed precision number type (typically the double-precision
floating-point `double`) and support the operation below (in addition
to fulfilling the requirements listed by the `ArrangementBasicTraits_2`
concept).
<DL>
<DT><B>`Approximate_2`:</B>
<DD> Given a point `p`, approximate the \f$x\f$ and
\f$y\f$-coordinates of `p` using a not necessarily multi-precision
number type. We use this operation for approximate
computations---there are certain operations performed during the
search for the location of the point that need not be exact, and that
can be performed faster when carried out, for example, using a
fixed-precision number type.
</DL>
A model of the `ArrangementConstructXMonotoneCurveTraits_2` concept
must support the operation below (in addition to fulfilling the
requirements listed by the `ArrangementBasicTraits_2` concept).
<DL>
<DT><B>`Construct_x_monotone_curve_2`:</B>
<DD> Given two points \f$p_1\f$ and \f$p_2\f$, construct
an \f$x\f$-monotone curve connecting \f$p_1\f$ and \f$p_2\f$.
</DL>

Most traits classes model the `ArrangementTraits_2` concept, and some
also model the `ArrangementLandmarkTraits_2` concept.

\subsubsection aos_ssec-traits-curved Unbounded or Curved Surface Concepts

We descend to the bottom level of the hierarchy. The refinements
described in this section provide the requirements imposed on traits
classes used with arrangements that support unbounded curves and
arrangements embedded on curved surfaces. In particular, these
requirements list additional operations that handle boundary
conditions of curves that either reach the boundary of the parameter
space (the pre-image of their endpoints lie on the boundary) or
approach it (the pre-image of their endpoints approach the
boundary). For each side of the parameter space there are four
available concepts, models of which can be used to handle open,
closed, contracted, and identified side,
respectively. \cgalFootnote{Note that we explicitly distinguish
closed-only, contracted, and identified sides, although the latter two
are closed in \f$\Phi\f$ as well.}  Theoretically, this makes for a
total of \f$4^4 = 256\f$ combinations. However, only a subset of them
is meaningful. If a side is identified, the opposite side must also be
identified. In addition, a contracted side must be adjacent to two
identified sides. This narrows down the number of valid combinations
to 35.

The types `Left_side_category`, `Right_side_category`,
`Bottom_side_category`, and `Top_side_category` nested in every model
of the `ArrangementBasicTraits_2` concept indicate whether the
corresponding boundary side is open, closed, contracted, or
identified, respectively, or whether the type of the boundary side is
irrelevant, as curves inserted into the arrangement are never expected
to reach the boundary side. In particular, these types nested in
models of the concepts `ArrangementOpenLeftTraits_2`,
`ArrangementOpenRightTraits_2`, `ArrangementOpenBottomTraits_2`, and
`ArrangementOpenTopTraits_2`, respectively, must be convertible to
`Arr_open_side_tag`. Similarly, these types must be convertible to
`Arr_closed_side_tag`, `Arr_constracter_side_tag`, or
`Arr_identified_side_tag` when nested in models of the corresponding
concepts. For example, the `Arr_rational_function_traits_2`
traits-model supports unbounded curves; see Section \ref
arr_ssectr_ratfunc. Thus, all four nested types are defined as
`Arr_open_side_tag`.  Adversely, all four types nested in the
`Arr_segment_traits_2` traits-model (see Section \ref arr_ssectr_segs)
are defined as `Arr_oblivious_side_tag`, as segments are always
bounded.

\cgalFigureBegin{aos_fig-open_concept_hierarchy,open_concept_hierarchy.png}
Bottom portion of the refinement hierarchy of the geometry-traits
concepts for curves embedded on an open surface, for instance, the
entire plane.
\cgalFigureEnd

Several predicates are required to handle \f$x\f$-monotone curves that
approach the boundary of the parameter space. These predicates are
sufficient to handle not only curves embedded in an unbounded
parameter space, but also curves embedded in a bounded parameter space
with open boundaries. The arrangement type instantiated with a traits
class that models the combined concept
`ArrangementOpenBoundaryTraits_2` shown in Figure
\cgalFigureRef{aos_fig-open_concept_hierarchy} can handle curves that
are open in any direction. Recall that an arrangement that supports
unbounded \f$x\f$-monotone curves maintains an implicit bounding
rectangle in the \sc{Dcel} structure; see Section \ref
arr_ssecunb_rep. If some curves inserted into an arrangement object
are expected to be unbounded; namely, there exists \f$d \in \{0,1\}\f$
such that \f$\lim_{t \rightarrow d}x(t) = \pm\infty\f$ or \f$\lim_{t
\rightarrow d}y(t) = \pm\infty\f$ holds for at least one input curve
\f$C(t) = (x(t),y(t))\f$, the arrangement template must be
instantiated with a model of the `ArrangementOpenBoundaryTraits_2`
concept.\cgalFootnote{A curve that reaches the boundary of the
parameter space in this case is open and unbounded.}

\cgalFigureBegin{aos_fig-spherical_concept_hierarchy,spherical_concept_hierarchy.png}
Bottom portion of the refinement hierarchy of the geometry-traits
concepts for curves embedded on a spherical-like parameterized surface
\cgalFigureEnd

A suitable geometry-traits component for arrangements embedded on
surfaces homeomorphic to a sphere is a model of the combined
concept `ArrangementSphericalTraits_2` shown in Figure
\cgalFigureRef{aos_fig-spherical_concept_hierarchy}.

\cgalFigureBegin{aos_fig-left_side_cluster,left_side_cluster.png}
Top portion of the refinement hierarchy of the geometry-traits
concepts for curves that either reach the left side of the boundary
of the parameter space or approach it. A similar hierarchy also
exists for the left, bottom, and top sides.
\cgalFigureEnd

The shared requirements for the four options of a side are collected
in abstract layers called `ArrangementLeftSideTraits_2`,
`ArrangementRightSideTraits_2`, `ArrangementBottomSideTraits_2`, and
`ArrangementTopSideTraits_2`; see, e.g., Figure
\cgalFigureRef{aos_fig-left_side_cluster}.

\cgalFigureBegin{aos_fig-side_clusters,side_clusters.png}
Top portion of the refinement hierarchy of the geometry-traits
concepts for curves that either reach the vertical sides of the
boundary of the parameter space or approach it, and similarly for
curves that either reach or approach horizontal sides.
\cgalFigureEnd

The shared requirements for the options of opposite sides are
collected in two additional abstract layers called
`ArrangementVerticalSideTraits_2` and `ArrangementHorizontalSideTraits_2`; see
Figure \cgalFigureRef{aos_fig-side_clusters}.

The abstract concept `ArrangementHorizontalSideTraits_2` requires the
following predicate:

<DL>

<DT><B>`Parameter_space_in_x_2`:</B>

<DD>This predicate is overloaded with two versions. We distinguish
between identified and non-identified sides as explained below.

(i) Given a curve \f$C = (x(t), y(t))\f$ and an enumerator that
specify either the minimum end or the maximum end of the curve, and
thus map to a parameter value \f$d \in \{0,1\}\f$, determine the
location of the \f$d\f$-end of \f$C\f$ with respect to the
\f$x\f$-axis. More precisely, if \f$C\f$ is open at its \f$d\f$-end
end, determine whether \f$\lim_{t \rightarrow d} x(t)\f$ is equal to
\f$x_{\rm min}\f$, equal to \f$x_{\rm max}\f$, or falls in between. If
\f$C\f$ is not open at its \f$d\f$-end end, determine whether
\f$x(d)\f$ is equal to \f$x_{\rm min}\f$, equal to \f$x_{\rm max}\f$,
or falls in between.

(ii) Given a point \f$p\f$, determine the location of the point with
respect to the \f$x\f$-axis. More precisely, determine whether
\f$x_p\f$ is equal to \f$x_{\rm min}\f$, equal to \f$x_{\rm max}\f$,
or falls in between. If \f$p\f$ is on a vertical boundary; that is,
\f$x_p \in \{x_{\rm min},x_{\rm max}\}\f$, then the boundary side
containing \f$p\f$ cannot be open and must not be identified. In other
words, this overloaded version is required only for the concepts
`ArrangementClosedLeftTraits_2`, `ArrangementClosedRightTraits_2`,
`ArrangementContractedLeftTraits_2` and
`ArrangementContractedRightTraits_2` concepts.

</DL>

The abstract concept `ArrangementVerticalSideTraits_2` requires the
following predicate:

<DL>

<DT><B>`Parameter_space_in_y_2`:</B>

<DD>This predicate is overloaded with two versions. We distinguish
between identified and non-identified sides as explained below.

(i) Given a curve \f$C\f$ and an enumerator that specify either the
minimum end or the maximum end of the curve, and thus map to a
parameter value \f$d \in \{0,1\}\f$, determine the location of the
\f$d\f$-end of \f$C\f$ with respect to the \f$y\f$-axis. More
precisely, if \f$C\f$ is open at its \f$d\f$-end end, determine
whether \f$\lim_{t \rightarrow d} y(t)\f$ is equal to \f$y_{\rm
min}\f$, equal to \f$y_{\rm max}\f$, or falls in between. If \f$C\f$
is not open at its \f$d\f$-end end, determine whether \f$y(d)\f$ is
equal to \f$y_{\rm min}\f$, equal to \f$y_{\rm max}\f$, or falls in
between.

(ii) Given a point \f$p\f$, determine the location of the point with
respect to the \f$y\f$-axis. More precisely, determine whether
\f$y_p\f$ is equal to \f$y_{\rm min}\f$, equal to \f$y_{\rm max}\f$,
or falls in between.  If \f$p\f$ is on a horizontal boundary; that is,
\f$y_p \in \{y_{\rm min},y_{\rm max}\}\f$, then the boundary side
containing \f$p\f$ cannot be open and must not be identified. In other
words, this overloaded version is required only for the concepts
`ArrangementClosedBottomTraits_2`, `ArrangementClosedTopTraits_2`,
`ArrangementContractedBottomTraits_2` and
`ArrangementContractedTopTraits_2` concepts.

</DL>

The two symmetric predicates above determine the location of a
curve-end in the parameter space. However, in general,
\f$x\f$-coordinates and \f$y\f$-coordinates are differently
handled. This asymmetry is brought on by the various algorithms
applied to arrangements, the input and output arguments of which are
\f$x\f$-monotone curves. Indeed, all curves maintained by any
arrangement are continuous weakly \f$x\f$-monotone curves. A non
\f$x\f$-monotone curve is divided into \f$x\f$-monotone sub curves
(and perhaps points) before it is inserted into an arrangement. This
asymmetry is also reflected in the predicates listed below. They help
determining the order of curve-ends lying on the boundary of the
parameter space with respect to regular points and among each other.

The concept `ArrangementHorizontalSideTraits_2` requires two additional
predicates:

<DL>
<DT><B>`Compare_x_on_boundary_2`:</B>

<DD>This predicate is overloaded with three versions.
We distinguish between open and non-open sides as explained below.

(i) Given a regular point \f$p\f$, an \f$x\f$-monotone curve \f$C =
(x(t),y(t))\f$, and an enumerator that specifies either the minimum
end or the maximum end of the curve, and thus maps to a parameter
value \f$d \in \{0,1\}\f$, compare the \f$x\f$-coordinate of \f$p\f$
and the \f$x\f$-coordinate of \f$C\f$ at its respective limit or end
depending on whether it is open or non-open. More precisely, if
\f$C\f$ is open at its \f$d\f$-end end, compare the values \f$x_p\f$
and \f$\lim_{t \rightarrow d} x(t)\f$. A precondition assures that
\f$C\f$ has a vertical asymptote at its \f$d\f$-end; that is
\f$\lim_{t \rightarrow d} x(t)\f$ is a real value. If \f$C\f$ is not
open, compare the values \f$x_p\f$ and \f$x(d)\f$.

(ii) Given two curves \f$C_1 = (x_1(t),y_1(t))\f$ and \f$C_2 =
(x_2(t),x_2(t))\f$ and enumerators that specify either the minimum end
or the maximum end of each curve, and thus map to parameter values
\f$d_1, d_2 \in \{0,1\}\f$, compare the \f$x\f$-coordinates of the
curves at their respective limits or ends. More precisely, if
\f$C_1\f$ (resp. \f$C_2\f$) is open at its \f$d_1\f$-end
(resp. \f$d_2\f$-end), use the value \f$\lim_{t \rightarrow d_1}
x_1(t)\f$ (resp. \f$\lim_{t \rightarrow d_2} x_2(t)\f$) for the
comparison.  A precondition assures that \f$C_1\f$ (resp. \f$C_2\f$)
has a vertical asymptote at its \f$d_1\f$-end (resp. \f$d_2\f$-end);
that is \f$\lim_{t \rightarrow d_1} x_1(t)\f$ is (resp. \f$\lim_{t
\rightarrow d_2} x_2(t)\f$) a real value. If \f$C_1\f$
(resp. \f$C_2\f$) is not open at its \f$d_1\f$-end
(resp. \f$d_2\f$-end), use the value \f$x_1(d_1)\f$
(resp. \f$x_2(d_2)\f$) for the comparison.

(iii) Given two points \f$p_1\f$ and \f$p_2\f$, such that at least one
of them lies on a horizontal boundary side, compare the
\f$x\f$-coordinates of the points. That is, compare \f$x_{p_1}\f$ and
\f$x_{p_2}\f$. If \f$p_1\f$ (resp. \f$p_2\f$) is on the boundary; that
is, \f$y_{p_1} \in \{y_{\rm min},y_{\rm max}\}\f$ (resp. \f$y_{p_2}
\in \{y_{\rm min},y_{\rm max}\}\f$), then the boundary side containing
\f$p_1\f$ (resp. \f$p_2\f$) must be either closed or identified. In
other words, this overloaded version is required only for the concepts
`ArrangementClosedBottomTraits_2`, `ArrangementClosedTopTraits_2`,
`ArrangementIdentifiedBottomTraits_2` and
`ArrangementIdentifiedTopTraits_2` concepts.

<DT><B>`Compare_x_near_boundary_2`:</B>

<DD>Given two \f$x\f$-monotone curves \f$C_1\f$ and \f$C_2\f$ and an
enumerator \f$i\f$ that specifies either the minimum ends or the
maximum ends of the two curves, and thus map to parameter values
\f$d_1, d_2 \in \{0,1\}\f$, respectively, compare the
\f$x\f$-coordinate of the curves near their respective limits or
ends. That is, compare the \f$x\f$-coordinates of the horizontal
projection of a point \f$p\f$ onto \f$C_1\f$ and onto \f$C_2\f$. A
precondition assures that \f$C_1\f$ and \f$C_2\f$ have vertical
asymptotes at their respective ends. Furthermore, both curves approach
the same boundary-side, either the bottom or the top, at their
respective ends. If both curves approach the bottom boundary-side,
\f$p\f$ is located far to the bottom, such that the result is
invariant under a translation of \f$p\f$ farther to the bottom. If
both curves approach the top boundary-side, \f$p\f$ is located far to
the top in a similar manner. Another precondition assures that the
\f$x\f$-coordinates of the limits of the curves at their respective
ends are equal. That is, the predicate `Compare_x_on_boundary_2`
applied to \f$C_1\f$, \f$C_2\f$, and \f$i\f$ evaluates to `EQUAL`.
</DL>

The concept `ArrangementVerticalSideTraits_2` requires two
additional predicates:

<DL>
<DT><B>`Compare_y_on_boundary_2`:</B>

<DD>Given two points \f$p_1\f$ and \f$p_2\f$, such that at least one
of them lies on a vertical boundary side, compare the
\f$y\f$-coordinates of the points. That is, compare \f$y_{p_1}\f$ and
\f$y_{p_2}\f$. If \f$p_1\f$ (resp. \f$p_2\f$) is on the boundary; that
is, \f$x_{p_1} \in \{x_{\rm min},x_{\rm max}\}\f$ (resp. \f$x_{p_2}
\in \{x_{\rm min},x_{\rm max}\}\f$), then the vertical boundary side
containing \f$p_1\f$ (resp. \f$p_2\f$) must be either closed or
identified. In other words, this overloaded version is required only
for the concepts `ArrangementClosedLeftTraits_2`,
`ArrangementClosedRightTraits_2`, `ArrangementIdentifiedLeftTraits_2`
and `ArrangementIdentifiedRightTraits_2` concepts.

<DT><B>`Compare_y_near_boundary_2`:</B>

<DD> Given two \f$x\f$-monotone curves \f$C_1\f$ and \f$C_2\f$, and an
enumerator \f$i\f$ that specifies either the minimum ends or the
maximum ends of the two curves, and thus maps to parameter values \f$d
\in \{0,1\}\f$, compare the \f$y\f$-coordinates of the curves near
their respective ends. More precisely, compares the
\f$y\f$-coordinates of the vertical projection of a point \f$p\f$ onto
\f$C_1\f$ and onto \f$C_2\f$. If the enumerator \f$i\f$ specifies the
minimum ends, the curves must approach the left boundary-side. In this
case \f$p\f$ is located far to the left, such that the result is
invariant under a translation of \f$p\f$ farther to the left. If
\f$i\f$ specifies the maximum ends, the curves must approach the right
boundary-side. In that case \f$p\f$ is located far to the right in a
similar manner.  </DL>

The concepts `ArrangementIdentifiedLeftTraits_2` and
`ArrangementIdentifiedRightTraits_2` introduces the following requirement:

<DL>
<DT><B>`Is_on_y_identification_2`:</B>

<DD>This predicate is overloaded with two versions.

(i) Given a point \f$p\f$, determine whether \f$p\f$ lies in the image
of the vertical and identified sides of the boundary. More precisely,
determine whether \f$x_p \in \{x_{\rm min},x_{\rm max}\}\f$ for all
pre-images of \f$p\f$.

(ii) Given a curve \f$C\f$, determine whether the entire curve \f$C\f$
lies in the image of the vertical and identified sides of the
boundary.
</DL>

Similarly, the concepts `ArrangementIdentifiedBottomTraits_2` and
`ArrangementIdentifiedTopTraits_2` introduces the following requirement:
<DL>
<DT><B>`Is_on_x_identification_2`:</B>

<DD>This predicate is overloaded with two versions.

(i) Given a point \f$p\f$, determine whether \f$p\f$ lies in the image
of the horizontal and identified sides of the boundary. More precisely,
determine whether \f$y_p \in \{y_{\rm min},y_{\rm max}\}\f$ for all
pre-images of \f$p\f$.

(ii) Given a curve \f$C\f$, determine whether the entire curve \f$C\f$
lies in the image of the horizontal and identified sides of the
boundary.

</DL>

\subsection aos_ssec-geom_traits-models Models of the Geometry Traits Concepts

In this section we review the traits classes included in the public
distribution of \cgal, that handle line segments, polylines, conic
arcs, rational functions, and arcs of B&eacute;zier and algebraic
curves.  The last subsection overviews decorators for geometric traits
classes distributed with \cgal, which extend other geometric
traits-class by attaching auxiliary data with the geometric objects.

\subsubsection arr_ssectr_segs Traits Classes for Line Segments and Linear Objects

The `Arr_segment_traits_2<Kernel>` class used so far in most example
programs in this chapter is a model of the concepts
`ArrangementTraits_2`, `ArrangementLandmarkTraits_2`, and
`ArrangementDirectionalXMonotoneTraits_2`; the later enables Boolean
set operations. It is parameterized by a geometric kernel and uses the
`Kernel::Point_2` type as it point type. However, neither the
`Curve_2` nor the `X_monotone_curve_2` types are identical to the
`Kernel::Segment_2` type. A kernel segment is typically represented by
its two endpoints, and these may have a large bit-size representation,
if the segment is intersected and split several times (in comparison
with the representation of its original endpoints). The large
representation may significantly slow down the various traits-class
operations involving such a segment. In contrast, the
`Arr_segment_traits_2` represents a segment using its supporting line
and the two endpoints, such that most computations are performed on
the supporting line, which never changes as the segment is split. It
also caches some additional information with the segment to speed up
various predicates.  An `X_monotone_curve_2` object can still be
constructed from two endpoints or from a kernel segment. Moreover, an
`X_monotone_curve_2` instance can also be casted or assigned to a
`Kernel::Segment_2` object. The two types are thus fully convertible
to one another.

The `Arr_segment_traits_2<Kernel>` class is very efficient for
maintaining arrangements of a large number of intersecting line
segments, especially if it is instantiated with the appropriate
geometric kernel. Using `Exact_predicates_exact_constructions_kernel`
as the kernel type, which is the default, is generally a good choice;
the coordinates of the segment endpoints are represented as exact
rational numbers, and this ensures the robustness and correctness of
any computation.\cgalFootnote{Many of the example programs in the rest
of the chapter include a header file named `arr_rational_nt.h`, which
defines a type named `Number_type` as either `Gmpq` or
`Quotient<MP_Float>`, depending on whether <span
class="textsc">Gmp</span> is installed or not.}

An instance of the `Arr_segment_traits_2<Kernel>` class template can
be very efficient for constructing arrangements induced by line
segments with a large number of intersections. Efficiency is affected
by the substituted geometric kernel. Using `Cartesian<Gmpq>` as the
kernel type is in general not a bad choice; the coordinates of the
segment endpoints are represented as multi-precision rational-numbers,
and this ensures the correctness of all computations regardless of the
input. Computations on multi-precision number types, such as `Gmpq`,
typically take longer than computations on machine-precision
floating-point. However, in almost all cases it is possible to
expedite the computation using numerical filtering; see `Kernel_2` and
`Kernel_3`. If the input set of line segments do not have
degeneracies; namely, no two segments in the set share a common
endpoint, and no three segments intersect at a common point, or at
least, degeneracies exist but their number is relatively small, then
filtered computation incurs only negligible overhead compared to
floating-point arithmetic, which is error-prone. Indeed, in almost all
examples and applications given in this manual, a predefined filtered
kernel is used to instantiate the line-segment traits class, namely
`Exact_predicates_exact_constructions_kernel`. Furthermore, this
kernel is used as a default kernel in case the user did not provide
one.

\cgalFigureBegin{arr_figpredef_kernels,fan_grids.png,Europe.png}
(a) An arrangement of \f$104\f$ line segments from the input file `fan_grids.dat`. (b) An arrangement of more than \f$3000\f$ interior disjoint line segments, defined in the input file `Europe.dat`.
\cgalFigureEnd

In the following example we use the predefined
`Exact_predicates_exact_constructions_kernel` for instantiating our
segment-traits class. This kernel use interval arithmetic to filter
the exact computations. The program reads a set of line segments with
integer coordinates from a file and computes their arrangement. By
default it opens the `fan_grids.dat` input-file, located in the
examples folder, which contains \f$104\f$ line segments that form
four "fan-like" grids and induce a dense arrangement, as illustrated
in \cgalFigureRef{arr_figpredef_kernels} (a):

\cgalExample{Arrangement_on_surface_2/predefined_kernel.cpp}

The arrangement package also offers a simpler alternative
segment-traits class. The traits class
`Arr_non_caching_segment_basic_traits_2<Kernel>` models the
`ArrangementBasicTraits_2` concept. It uses `Kernel::Point_2` as its
point type and `Kernel::Segment_2` as its \f$x\f$-monotone curve
type. As this traits class does not support intersecting and splitting
segments, the kernel representation is sufficient. It is still less
efficient than `Arr_segment_traits_2` for constructing arrangements of
pairwise disjoint line segments in many cases, as it performs no
caching at all, but using this traits class may be preferable as it
reduces the memory consumption a bit, since no extra data is stored
with the line segments.

The class `Arr_non_caching_segment_traits_2<Kernel>` inherits from
`Arr_non_caching_segment_basic_traits_2<Kernel>` and extends it to be
a model of the concepts `ArrangementTraits_2`,
`ArrangementLandmarkTraits_2`,and
`ArrangementDirectionalXMonotoneTraits_2`. It may thus be used to
construct arrangement of intersecting line segments, but as explained
above, for efficiency reasons it is recommended to use it only when
the arrangement is very sparse and contains hardly any intersection
points.

In the following example we read an input file containing a set of
line segments that are pairwise disjoint in their interior. As the
segments do not intersect, no new points are constructed and we can
instantiate the `Arr_non_caching_segment_traits_basic_2<Kernel>`
class-template with the predefined
`Exact_predicates_inexact_constructions_kernel`. Note that we use the
`insert_non_intersecting_curves()` function to construct the
arrangement.  By default, the example opens the `Europe.dat`
input-file, located in the examples folder, which contains more than
\f$3000\f$ line segments with floating-point coordinates that form
the map of Europe, as depicted in
\cgalFigureRef{arr_figpredef_kernels} (b):

\cgalExample{Arrangement_on_surface_2/predefined_kernel_non_intersecting.cpp}

The `Arr_linear_traits_2<Kernel>` class used for demonstrating the
construction of arrangements of unbounded curves is capable of
handling bounded and unbounded linear objects, namely lines, rays and
line segments. It is parameterized by a geometric kernel and such that
its nested `Point_2` type is the same as the kernel point. The
`Curve_2` (and `X_monotone_curve_2`) type it defines is constructible
from a `Kernel::Line_2`, a `Kernel::Ray_2` or from a
`Kernel::Segment_2` object. Just like the default segment-traits
class, the linear-traits class also use caching techniques to speed up
its predicates and constructions.

\subsubsection arr_ssectr_polylines The Polyline and Polycurve Traits Classes

Polylines are continuous piecewise linear curves. Polylines are of
particular interest, as they can be used to approximate more complex
curves in the plane. At the same time they are easier to handle in
comparison to higher-degree algebraic curves, as rational arithmetic
is sufficient to carry out computations on polylines, and to construct
arrangements of polylines in an exact and robust manner.

The `Arr_polyline_traits_2<SubcurveTraits_2>` class template handles
polylines. It models the concepts `ArrangementTraits_2`,
and `ArrangementDirectionalXMonotoneTraits_2`. The type that
substitutes the template parameter `SubcurveTraits_2` when
`Arr_polyline_traits_2<SubcurveTraits_2>` is instantiated must be a
geometry-traits class that models the following concepts:

- `ArrangementTraits_2`,
- `ArrangementDirectionalXMonotoneTraits_2`,
- `ArrangementConstructXMonotoneCurveTraits_2`.

We refer to the type that substitutes the template parameter
`SubcurveTraits_2` as the <em>subcurve traits</em> hereafter.  If, in
addition, the subcurve traits also models the concept
`ArrangementApproximateTraits_2` then the instantiated
`Arr_polyline_traits_2<SubcurveTraits>` type models the concept
`ArrangementApproximateTraits_2` as well. (By definition, modeling the
concepts `ArrangementApproximateTraits_2` and
`ArrangementConstructXMonotoneCurveTraits_2` implies modeling the
concept `ArrangementLandmarkTraits_2`.) The same holds for the
`ArrangementOpenBoundaryTraits_2` concept as well.  Modeling the
`ArrangementConstructXMonotoneCurveTraits_2` concept implies that the
subcurve traits must support the construction of a unique
(\f$x\f$-monotone) segment given two input points. Roughly speaking,
it means that each operation defined by the subcurve traits must
handle linear curves.

An instance of the polyline traits class-template inherits its nested
point type, i.e., `Point_2`, from the subcurve traits, and defines the
nested types `Curve_2` and `X_monotone_curve_2`, which are used to
represent polylines and \f$x\f$-monotone polylines, respectively.  A
polyline of the nested type `Curve_2` is stored as a vector of
`SubcurveTraits_2::Curve_2` objects, and an \f$x\f$-monotone polyline
of the nested type `X_monotone_curve_2` is stored as a vector of
`SubcurveTraits_2::X_monotone_curve_2` objects.  The nested
`X_monotone_curve_2` type inherits from the nested type `Curve_2`.  By
default, `Arr_segment_traits_2` is used as the subcurve traits (in
case where the `SubcurveTraits_2` parameter is omitted). In this case
the nested types `SubcurveTraits_2::Curve_2` and
`SubcurveTraits_2::X_monotone_curve_2` are identical types
representing line segments.

A polyline can be constructed given one of the following inputs:

- <b>A range of \a points</b>, where two succeeding points in the
  range represent the endpoints of a segment of the polyline.

- <b>A range of \a segments</b>. Note that , if the types
`SubcurveTraits_2::Curve_2` and `SubcurveTraits_2::X_monotone_curve_2` are
not the same, then when `Make_x_monotone_2` is invoked the segments
that compose the polyline will be broken into \f$x\f$-monotone
parts.

- <b>A pair of points \a or a single segment</b>. In this case a polyline
  that consists of a single segment is constructed.

Note that degenerate polylines are not supported. That is, it is
impossible to construct a polyline that contains a segment of length
zero, or an isolated point. Finally, a polyline is
<b><em>continuous</em></b> and <b><em>well-oriented</em></b>; that is,
the target of the \f$i\f$th segment is the source of the \f$i+1\f$st
segment. For example, the general polyline

\image html generic-polyline.png
\image latex generic-polyline.pdf

can be represented by one of the following two

\image html well-oriented-polyline.png
\image latex well-oriented-polyline.pdf

Also, note, that a single polyline can be split into several
\f$x\f$-monotone polylines, and that the number of intersection
points (or overlapping sections) between two polylines can also
be large.

\cgalAdvancedBegin
Technically speaking, it is possible to construct a general polyline
that is neither well-oriented nor continuous. However, it is
impossible to use such polylines for the purpose of computing an
arrangement.
\cgalAdvancedEnd

You can traverse over the range of defining segments of a given
polyline. The \a first and \a past-the-end iterators can be obtained
through the access functions of the polyline `begin_segments()` and
`end_segments()`, respectively. The vertices of an \f$x\f$-monotone
curve are always stored in a strongly monotonic lexicographical order.
In other words, \f$x\f$-monotone polylines can be directed \a either
left-to-right \a or right-to-left. If the macro
#CGAL_ALWAYS_LEFT_TO_RIGHT is set to 1, then the \f$x\f$-monotone
polylines are always directed from left-to-right (only proposed for
backward compatibility).

The polyline-traits class does not perform any geometric operations
directly. Instead, it solely relies on the functionality of the
segment traits. For example, when we need to determine the position of
a point with respect to an \f$x\f$-monotone polyline, we use binary
search to locate the relevant segment that contains the point in its
\f$x\f$-range. Then, we compute the position of the point with respect
to this segment. Thus, operations on \f$x\f$-monotone polylines of
size \f$m\f$ typically take \f$O(\log m)\f$ time.

You are free to choose the underlying segment traits class. Your
decision could be based, for example, on the number of expected
intersection points; see Section \ref arr_ssectr_segs. Moreover, it
is possible to substitute the `SubcurveTraits_2` template parameter
with a traits class that handles segments with some additional data
attached to each individual segment; see Section
\ref arr_ssecmeta_tr. This makes it possible to associate different
data objects with the different segments that compose a polyline.

\cgalFigureBegin{arr_figex_12,ex_12.png} An arrangement of three
polylines, as constructed in `polylines.cpp`. Disks mark vertices
associated with polyline endpoints, while circles mark vertices that
correspond to intersection points. Note that \f$\pi_2\f$ is split into
three \f$ x\f$-monotone polylines, and that \f$\pi_1\f$ and
\f$\pi_3\f$ have two overlapping sections. \cgalFigureEnd

The following example program constructs an arrangement of three
polylines, as depicted in \cgalFigureRef{arr_figex_12}. Note that
most points defining the polylines are not associated with arrangement
vertices. The arrangement vertices are either the endpoints of
each \f$x\f$-monotone polyline or the intersection points between two
polylines:

\cgalExample{Arrangement_on_surface_2/polylines.cpp}

The traits class `Arr_polycurve_traits_2<GeometryTraits_2>` handles
piecewise curves that are not necessarily linear, such as conic arcs,
circular arcs, Bezier curves, or line segments. We call such a
compound curve a <em>polycurve</em>. Similar to a polyline, a
polycurve is a chain of subcurves, where each two neighboring
subcurves in the chain share a common endpoint; that is, the polycurve
is continuous. As a matter of fact, most characteristics of the
`Arr_polyline_traits_2<GeometryTraits_2>` traits class apply also to
the `Arr_polycurve_traits_2<GeometryTraits_2>` traits class. The only
difference between the two, is that the latter is not a model of the
concept `ArrangementConstructXMonotoneCurveTraits_2`, and as such, it
is not able to construct a subcurve from two points. As a consequence,
it does not support the operations that (i) construct a polycurve from
a sequence of point, and (ii) push a point at the back or at the front
of a non-empty polycurve.

\subsubsection arr_ssectr_circ_seg A Traits Class for Circular Arcs and Line Segments

Circles and circular arcs are the simplest form of non-linear curves.
We handle circles whose centers have rational coordinates and whose
squared radii is also rational. If we denote the circle center by
\f$(x_0,y_0)\f$ and its radius by \f$r\f$, then the equation of the
circle - that is, \f$(x - x_0)^2 + (y - y_0)^2 = r^2\f$ - has rational
coefficients.  The intersection points of two such circles are
therefore solutions of a quadratic equation with rational
coefficients, or algebraic numbers of degree \f$2\f$. The same applies
for intersection points between such a rational circle and a line, or
a line segment, with rational coefficients (a line whose equation is
\f$ax + by + c = 0\f$, where \f$a\f$, \f$b\f$ and \f$c\f$ are
rational). Such numbers can be expressed as \f$\alpha +
\beta\sqrt{\gamma}\f$, where \f$\alpha\f$, \f$\beta\f$ and
\f$\gamma\f$ are all rational numbers.

Arrangement of circular arcs and of line segment are very useful, as
they occur in many applications. For example, when dilating a polygon
by some radius we obtain a shape whose boundary is comprised of line
segments, which correspond to dilated polygon edges, and circular
arcs, which result from dilated polygon vertices. Using the
arrangement of the boundary curves it is possible, for example, to
compute the union of a set of dilated polygons.

The `Arr_circle_segment_traits_2<Kernel>` class-template is designed
for efficient handling of arrangements of circular arcs and line
segments.  It is a model of the concepts `ArrangementTraits_2` and
`ArrangementDirectionalXMonotoneTraits_2`; the later enables Boolean
set operations. Note that it is not a model of
`ArrangementLandmarkTraits_2` concept, so it is impossible to use the
landmark point-location strategy. The traits class template is
parameterized by a geometric kernel, and can handle arrangements of
segments of `Kernel::Circle_2` objects (full circles are also
supported) or of `Kernel::Line_2` objects - namely circular arcs and
line segments.  It is important to observe that the nested `Point_2`
type defined by the traits class, whose coordinates are typically
algebraic numbers of degree 2, is <em>not</em> the same as the
`Kernel::Point_2` type, which is capable of representing a point with
rational coordinates. The coordinates of a point are represented using
the nested `CoordNT` number-type.

\cgalFigureBegin{arr_figex_13,ex_13.png}
An arrangement of three circles constructed in `circles.cpp`. Each
circle is split into two \f$x\f$-monotone circular arcs, whose
endpoints are drawn as disks. Circles mark vertices that correspond to
intersection points. The vertex \f$y_{\rm max}\f$ is a common
intersection point of all three circles.
\cgalFigureEnd


In the following example an arrangement of three full circles is
constructed, as shown in \cgalFigureRef{arr_figex_13}. Then, the
vertex of maximal degree is searched for. The geometric mapping of
this vertex is the point \f$(4,3)\f$, as all three circles intersect
at this point and the associated vertex has six incident edges:

\cgalExample{Arrangement_on_surface_2/circles.cpp}

The `Curve_2` type nested in `Arr_circle_segment_traits_2` can be used
to represent circles, circular arcs, or line segments. Curve objects
can therefore be constructed from a `Kernel::Circle_2` object or from
a `Kernel::Segment_2` object. A circular arc is typically defined by a
supporting circle and two endpoints, where the endpoints are instances
of the `Point_2` type, with rational or irrational coordinates. The
orientation of the arc is determined by the orientation of the
supporting circle. Similarly, we also support the construction of
lines segments given their supporting line (of type `Kernel::Line_2`)
and two endpoints, which may have irrational coordinates (unlike the
`Kernel::Segment_2` type).

Note that the `Kernel::Circle_2` type represents a circle whose
<em>squared radius</em> is rational, where the radius itself may be
irrational.  However, if the radius is known to be rational, it is
advisable to use it, for efficiency reasons. It is therefore also
possible to construct a circle, or a circular arc specifying the
circle center (a `Kernel::Point_2`), its rational radius, and its
orientation. Finally, we also support the construction of a circular
arcs that is defined by two endpoints and an arbitrary midpoint that
lies on the arc in between its endpoint. In this case, all three
points are required to have rational coordinates (to be kernel
points).

The following example demonstrates the usage of the various
construction methods for circular arcs and line segments. Note the
usage of the constructor of `CoordNT (alpha, beta, gamma)`, which
creates a degree-\f$2\f$ algebraic number whose value is \f$\alpha +
\beta\sqrt{\gamma}\f$.

\cgalExample{Arrangement_on_surface_2/circular_arcs.cpp}

It is also possible to construct \f$x\f$-monotone curve objects, which
represent \f$x\f$-monotone circular arcs or line segments, using
similar constructors.  Construction from a full circle is obviously
not supported. See the Reference Manual for more details.

The traits class-template
`Arr_circular_line_arc_traits_2<CircularKernel>` offered by the
arrangement package also handles circular arcs and line segments. It
is an alternative to the `Arr_circle_segment_traits_2<Kernel>`
class-template. These two class templates, while serve similar
purposes, are based on different concepts, and posses different
characteristics. You are encouraged to experiment with both, compare
their performance, and use the most suitable for your case.

\subsubsection arr_ssectr_conic A Traits Class for Conic Arcs

A <em>conic curve</em> is an algebraic curve of degree 2. Namely, it
is the locus of all points \f$(x,y)\f$ satisfying the equation \f$C:\
r x^2 + s y^2 + t xy + u x + v y + w = 0\f$, where the six
coefficients \f$\langle r, s, t, u, v, w \rangle\f$ completely
characterize the curve. The sign of the expression \f$\Delta_{C} = 4 r
s - t^2\f$ determines the type of curve:

<UL>

<LI>If \f$\Delta_{C} > 0\f$ the curve is an ellipse. A circle is a
special case of an ellipse, where \f$r = s\f$ and \f$t = 0\f$.
<LI>If \f$\Delta_{C} = 0\f$ the curve is a parabola - an unbounded
conic curve with a single connected branch. When \f$r = s = t = 0\f$
we have a line, which can be considered as a degenerate parabola.
<LI>If \f$\Delta_{C} < 0\f$ the curve is a hyperbola. That is, it
is comprised of two disconnected unbounded branches.
</UL>

As the arrangement package is suitable for bounded curves, we consider
bounded segments of conic curves, referred to as <em>conic
arcs</em>. A conic arc \f$a\f$ may be either (i) a full ellipse, or
(ii) defined by the tuple \f$\langle C, p_s, p_t, o \rangle\f$, where
\f$C\f$ is a conic curve and \f$p_s\f$ and \f$p_t\f$ are two points
on \f$C\f$ (namely \f$C(p_s) = C(p_t) = 0\f$) that define the
<em>source</em> and <em>target</em> of the arc, respectively. The arc
is formed by traversing \f$C\f$ from the source to the target going
in the orientation specified by \f$ o\f$, which is typically clockwise
or counterclockwise orientation (but may also be collinear in case of
degenerate conic curves).

We always assume that the conic coefficients \f$\langle r, s, t, u, v,
w \rangle\f$ are rational. When dealing with linear curves (line
segments and polylines), similar assumptions guarantee that all
intersection points also have rational coordinates, such that the
arrangement of such curves can be constructed and maintained using
only rational arithmetic. Unfortunately, this does not hold for conic
curves, as the coordinates of intersection points of two conic curves
with rational coefficients are in general algebraic numbers of degree
\f$4\f$.\cgalFootnote{Namely, they are roots of polynomials with
integer coefficients of degree \f$4\f$. However, in some special
cases, for example when handling only circles and circular arcs, the
coordinates of the intersection points are only of degree \f$ 2\f$,
namely they are solutions of quadratic equations.}  In addition, conic
arcs may not necessarily be \f$x\f$-monotone, and must be split at
points where the tangent to the arc is vertical.  In the general case,
such points typically have coordinates that are algebraic numbers of
degree \f$2\f$.  It is therefore clear that we have to use different
number types to represent the conic coefficients and the point
coordinates.  Note that as arrangement vertices induced by
intersection points and points with vertical tangents are likely to
have algebraic coordinates, we also allow the original endpoints of
the input arcs \f$p_s\f$ and \f$p_t\f$ to have algebraic coordinates.

The `Arr_conic_traits_2<RatKernel, AlgKernel, NtTraits>` class
template is designed for efficient handling of arrangements of
bounded conic arcs. The template has three parameters, defined as
follows:
<UL>

<LI>The `RatKernel` class is a geometric kernel, whose field type is
an exact rational type. It is used to define basic geometric entities
(e.g., a line segment or a circle) with rational
coefficients. Typically we use one of the standard \cgal kernels,
instantiated with the number type `NtTraits::Rational` (see below).

<LI>The `AlgKernel` class is a geometric kernel whose field type is an
exact algebraic type. It is used to define points with algebraic
coordinates. Typically we use one of the standard \cgal kernels,
instantiated with the number type `NtTraits::Algebraic` (see below).

<LI>The `NtTraits` class (the number-type traits class) encapsulates
all the numeric operations needed for performing the geometric
computation carried out by the geometric traits class.  It defines the
`Integer`, `Rational` and `Algebraic` number-types, and supports
several operations on these types, such as conversion between number
types, solving quadratic equations and extracting the real roots of a
polynomial with integer coefficients. It is highly recommended to use
the `CORE_algebraic_number_traits` class, which is included in the
arrangement package. It relies on the exact number types implemented
in the <span class="textsc">Core</span> library and performs exact
computations on the number types it defines.
</UL>

The `Arr_conic_traits_2` models the `ArrangementTraits_2` and
`ArrangementLandmarkTraits_2` concepts. (It supports the landmark
point-location strategy). Its `Point_2` type is derived from
`AlgKernel::Point_2`, while the `Curve_2` type represents a bounded,
not necessarily \f$x\f$-monotone, conic arc.  The
`X_monotone_curve_2` type is derived from `Curve_2`, but its
constructors are to be used only by the traits class.  You should
therefore construct only `Curve_2` objects and insert them into the
arrangement using the `insert()` or `insert()` functions.

Conic arcs can be constructed from full ellipses or by specifying a
supporting curve, two endpoints and an orientation. However, several
constructors of `Curve_2` are available to allow for some special
cases, such as circular arcs or line segments. The `Curve_2` (and the
derived `X_monotone_curve_2`) classes also support basic access
functions such as `source()`, `target()` and `orientation()`.

\subsubsection Arrangement_on_surface_2ExamplesforArrangements Examples for Arrangements of Conics

\cgalFigureBegin{arr_figex_14,ex_14.png}
An arrangement of mixed conic arcs, as constructed in conics.cpp
\cgalFigureEnd


The following example demonstrates the usage of the various
constructors for conic arcs. The resulting arrangement is depicted in
\cgalFigureRef{arr_figex_14}. Especially noteworthy are the
constructor of a circular arc that accepts three points and the
constructor that allows specifying approximate endpoints, where the
exact endpoints are given explicitly as intersections of the
supporting conic with two other conic curves. Also note that as the
preconditions required by some of these constructors are rather
complicated (see the Reference Manual for the details), a precondition
violation does not cause the program to terminate - instead, an
<em>invalid</em> arc is created. We can verify the validity of an arc
by using the `is_valid()` method. Needless to say, inserting invalid
arcs into an arrangement is not allowed.

\cgalExample{Arrangement_on_surface_2/conics.cpp}

The last example in this section demonstrates how the conic-traits
class can handle intersection points with multiplicity. The supporting
curves of the two arcs, a circle centered at \f$(0,\frac{1}{2})\f$
with radius \f$\frac{1}{2}\f$, and the hyperbola \f$y =
\frac{x^2}{1-x}\f$,\cgalFootnote{This curve can also be written as
\f$C: x^2 + xy - y = 0\f$. It is a hyperbola since \f$\Delta_{C} =
-1\f$.}  intersect at the origin such that the intersection point has
multiplicity \f$3\f$ (note that they both have the same horizontal
tangent at \f$(0,0)\f$ and the same curvature \f$1\f$). In addition,
they have another intersection point at
\f$(\frac{1}{2},\frac{1}{2})\f$ of multiplicity \f$1\f$:

\cgalExample{Arrangement_on_surface_2/conic_multiplicities.cpp}

\subsubsection arr_ssectr_ratfunc A Traits Class for Arcs of Rational Functions

The traits class `Arr_rational_function_traits_2<AlgebraicKernel_d_1>`
handles bounded and unbounded arcs of rational functions, referred to
as <em>rational arcs</em> (in particular, such an arc may correspond
to the entire graph of a rational function), and enables the
construction and maintenance of arrangements of such arcs. Rational
functions, and polynomial functions in particular, are not only
interesting in their own right, they are also very useful for
approximating or interpolating more complicated curves; see, e.g.,
[\cgalCite{cgal:ptvf-nrcpp-02} Chapter 3.

`Arr_rational_function_traits_2<AlgebraicKernel_d_1>` is a model of
the concepts `ArrangementTraits_2`, `ArrangementOpenBoundaryTraits_2`,
and `ArrangementDirectionalXMonotoneTraits_2`; the later enables
Boolean set operations. Note that it is not a model of
`ArrangementLandmarkTraits_2` concept, so it is impossible to use the
landmark point-location strategy with this traits class.

A rational function \f$y = \frac{P(x)}{Q(x)}\f$ is defined by two
polynomials \f$P\f$ and \f$ Q\f$ of arbitrary degrees. If \f$ Q(x) =
1\f$ then the function is a simple polynomial function. Usually the
domain is \f$\mathbb{R}\f$ but the function may also be restricted to
a bounded interval \f$[x_{\rm min}, x_{\rm max}]\f$ or defined over a
ray \f$ (-\infty, x_{\rm max}]\f$ or \f$[x_{\rm min},
\infty)\f$. Rational functions are represented by the nested type
`Curve_2`.  A rational arc is always \f$x\f$-monotone in the
mathematical sense. However, it is not necessarily continuous, as it
may have singularities. An arc that has singularities must be split
into continuous portions before being inserted into the
arrangement. Arbitrary rational functions are represented by the
nested type `Curve_2` and continuous portions of rational functions
are represented by the nested type `X_monotone_curve_2`. Constructors
for both types are provided by the traits. A `Curve_2` may be split up
into several `X_monotone_curve_2` using `Make_x_monotone_2`.

Using the `Arr_rational_function_traits_2<AlgebraicKernel_d_1>` class
template it is possible to construct and maintain arrangement of
rational arcs. The template parameter of the traits must be a model of
the concept `AlgebraicKernel_d_1`. A rational function is represented
as the quotient of two polynomials \f$P\f$ and \f$Q\f$ of type
`AlgebraicKernel_d_1::Polynomial_1` and an \f$x\f$-interval over
which the polynomials are defined. The type of the polynomial
coefficients, namely `AlgebraicKernel_d_1::Coefficient`, cannot be
algebraic.  Moreover, it is recommended that this type is not made
rational either, since using rational, as opposed to integral,
coefficients does not extend the range of the rational arcs and is
typically less efficient.  The type of the interval bounds, namely
`AlgebraicKernel_d_1::Bound`, however, can be algebraic. A point is
represented by a rational function and its \f$x\f$-coordinate, which
is of type `AlgebraicKernel_d_1::Algebraic_real_1`. Note that an
explicit representation of the \f$y\f$-coordinate is only computed
upon request, as it can be a rather costly operation.

The constructed rational functions are cached by the traits class. The
cache is local to each traits class object. It is therefore necessary
to construct curves using only the constructor objects provided by
member functions of the traits class.  Moreover, a curve must only be
used by the traits class object that was used to construct it. The
cache is automatically cleaned up from time to time. The amortized
clean up costs are constant. In addition, there is also a separate
member function that cleans up the cache on demand.

The curve constructors have an additional advantage. They conveniently
enable the provision of two polynomials that define a rational arc
using rational coefficients. For example, let \f$P\f$ and \f$Q\f$
denote two polynomials with integral coefficients that define a
rational arc at interest, and let \f$P'\f$ and \f$Q'\f$ denote two
polynomials with rational coefficients that define the same rational
arc; that is, the quotients \f$P/Q\f$ and \f$P'/Q'\f$ are
identical. You can construct the rational arc providing the
coefficients of \f$P'\f$ and \f$Q'\f$ to the constructor. In this
case the constructor normalizes the coefficients and stores the
desired polynomials \f$P\f$ and \f$Q\f$.

\cgalFigureBegin{arr_figex_16,ex_16.png}
An arrangement of four arcs of rational functions, as constructed in rational_functions.cpp.
\cgalFigureEnd

The following example demonstrates the construction of an arrangement
of rational arcs depicted in \cgalFigureRef{arr_figex_16}. Note the
usage of the two constructors, for polynomial arcs and for rational
arcs:

\cgalExample{Arrangement_on_surface_2/rational_functions.cpp}

\cgalFigureBegin{arr_figex_unb_rat,ex_unb_rat.png} An arrangement of
six arcs of rational functions, as constructed in
unbounded_rational_functions.cpp
\cgalFigureEnd

The following example demonstrates the construction of an arrangement
of six rational arcs - four unbounded arcs and two bounded ones - as
depicted in \cgalFigureRef{arr_figex_unb_rat}. Note the usage of the
constructors of an entire rational function and of an infinite "ray"
of such a function. Also observe that the hyperbolas \f$y =
\pm\frac{1}{x}\f$ and \f$y = \pm\frac{1}{2x}\f$ never intersect,
although they have common vertical and horizontal asymptotes, so very
"thin" unbounded faces are created between them:

\cgalExample{Arrangement_on_surface_2/unbounded_rational_functions.cpp}

\subsubsection arr_ssectr_bez A Traits Class for Planar B&eacute;zier Curves

A planar <em>B&eacute;zier curve</em> \f$B\f$ is a parametric curve
defined by a sequence of <em>control points</em> \f$p_0, \ldots,
p_n\f$ as follows:

\f{eqnarray*}{
B(t) = \left(X(t), Y(t)\right)
= \ccSum{k=0}{n}{p_k \cdot \frac{n!}{k! (n-k)!} \cdot
t^k (1-t)^{n-k}}\ .
\f}

where \f$t \in [0, 1]\f$. The degree of the curve is therefore \f$n\f$
- namely, \f$ X(t)\f$ and \f$ Y(t)\f$ are polynomials of degree
\f$n\f$. B&eacute;zier curves have numerous applications in computer
graphics and solid modelling. They are used, for example, in free-form
sketches and for defining the true-type fonts.

Using the `Arr_Bezier_curve_traits_2<RatKernel, AlgKernel, NtTraits>`
class template it is possible to construct and maintain arrangements
of B&eacute;zier curves that are given by rational control points (a
sequence of objects of the `RatKernel::Point_2` type). We can handle
curves of arbitrary degree (in general, a sequence of \f$n+1\f$
control points define a B&eacute;zier curve of degree \f$n\f$). The
template parameters are the same ones used by the `Arr_conic_traits_2`
class template, and here it is also recommended to use the
`CORE_algebraic_number_traits` class, with Cartesian kernels
instantiated with the `Rational` and `Algebraic` number-types defined
by this class.

As mentioned above, we assume that the coordinates of all control
points that define a B&eacute;zier curve are rational numbers, so both
\f$X(t)\f$ and \f$Y(t)\f$ are polynomials with rational
coefficients. The intersection points between curves are however
algebraic numbers, and their exact computation is time-consuming. The
traits class therefore contains a layer of geometric filtering that
performs all computation in an approximate manner whenever
possible. Thus, it resorts to exact computations only when the
approximate computation fails to produce an unambiguous result.  Note
that most arrangement vertices are therefore associated with
approximated points. You cannot access the coordinates of such points
and obtain them as algebraic numbers, and only access to the
approximate coordinates in possible.  See the Reference Manual for the
exact interface of the `Point_2`, `Curve_2` and `X_monotone_curve_2`
defined by the traits class.

The `Arr_Bezier_curve_traits_2` is a model of the
`ArrangementTraits_2` concept (but not of the
`ArrangementLandmarkTraits_2` concept, so it is impossible to use the
landmark point-location strategy for arrangements of rational arcs).

\cgalFigureBegin{arr_figex_bez,Bezier_arr.png}
An arrangement of ten B&eacute;zier curves of degree \f$5\f$, as
constructed in `Bezier_curves.cpp`.
\cgalFigureEnd


The following example reads a set of B&eacute;zier curves from an
input file, where each file is specified by an integer stating its
number of control points, followed by the sequence of control points,
given in integer or rational coordinates. By default, the program uses
the `Bezier.dat` file, which contains ten curves of degree \f$5\f$
each; their resulting arrangement is depicted in
\cgalFigureRef{arr_figex_bez}.

\cgalExample{Arrangement_on_surface_2/Bezier_curves.cpp}

\subsubsection arr_ssectr_alg A Traits Class for Planar Algebraic Curves of Arbitrary Degree

An algebraic curve \f$C\f$ in the plane is defined as the (real) zero
locus of a polynomial \f$f(x,y)\f$ in two variables. The curve is
uniquely defined by \f$f\f$ (although several polynomials might define
the same curve).  We call \f$f\f$ a <em>defining polynomial</em> of
\f$C\f$.

We consider arrangements induced by algebraic curves or by (weakly)
\f$x\f$-monotone segments for algebraic curves (Such a segment is not
necessarily the maximal possible (weakly) x-monotone segment; see
below.)  When talking about algebraic curves, we use the term
"segment" for a continuous, possibly non-linear subset of an algebraic
curve - see the definition below.  There are no restrictions on the
algebraic curve, that means, we support unbounded curves, vertical
curves or segments, and isolated points.

The `Arr_algebraic_segment_traits_2<Coefficient>` class template
is a model of the `ArrangementTraits_2` concept (but not of the
`ArrangementLandmarkTraits_2` concept, so it is impossible
to use the landmark point-location strategy for arrangements of
algebraic curves).
The template argument `Coefficient` determines
the type of the scalar coefficients of the polynomial.
Currently supported types are `leda_integer`, `CORE::BigInt`,
and any instance of `Sqrt_extension<A,B>`
instantiated with one of the integral types above.

The traits class defines a type `Curve_2` for algebraic curves.
Such a type can be constructed by the `Construct_curve_2` functor,
which accepts an instance of `Polynomial_2` as an argument.
This polynomial type is also available by the traits class
and constitutes a valid model
of the concept `Polynomial_d` with two variables (see ??).

\cgalFigureBegin{arr_figex_alg_curves,algebraic_curves.png} An
arrangement of algebraic curves of degrees \f$1\f$, \f$ 2\f$, \f$3\f$,
and \f$6\f$, as constructed in `algebraic_curves.cpp`.
\cgalFigureEnd

The following examples computes the arrangement induced by the four curves
in \cgalFigureRef{arr_figex_alg_curves}

\cgalExample{Arrangement_on_surface_2/algebraic_curves.cpp}

We first give a precise definition of segments of algebraic curves.  A
point \f$p\f$ on a curve \f$C_f\subset\mathbb{R}^2\f$ (with \f$f\f$
its defining equation) is called <em>semi-regular</em>, if locally
around \f$p\f$, \f$ C_f\f$ can be written as a function graph of some
continuous function in \f$x\f$ or in \f$ y\f$ (we also say that \f$
p\f$ is parameterizable in \f$x\f$ or \f$y\f$, respectively).  The
only two cases of non-semi-regular points are isolated points, and
self-intersections.  A <em>segment</em> of a curve is a closed and
continuous point set such that each interior point is semi-regular.
It follows that a weakly \f$ x\f$-monotone segment is either a
completely vertical segment, or a segment whose interior points are
all parameterizable in \f$x\f$.

The traits class allows to construct weakly \f$x\f$-monotone segments
of a curve using the `Construct_x_monotone_segment_2` functor.  The
`X_monotone_curve_2` type of the traits class represents weakly
\f$x\f$-monotone segments of a curve; however, segments may need to be
further subdivided into several (sub-)segments, for technical
reasons. Therefore, `Construct_x_monotone_segment_2` constructs a
sequence of `X_monotone_curve_2` objects, whose union represents the
weakly \f$x\f$-monotone segment that was queried.  We call a segment
<em>terminal</em> if it can be represented by the type
`X_monotone_curve_2`.

\cgalAdvancedBegin

The subdivision of segments is due to the internal representation of
\f$x\f$-monotone segments, which is based on a vertical decomposition.
We assume the defining polynomial \f$f\f$ of the curve \f$C\f$ to be
<em>square-free</em>, that means, it contains no divisor \f$g^2\f$ of
total degree greater than zero. We define a <em>(complex) critical
point</em> \f$p\in\mathbb{C}^2\f$ by \f[ f(p)=0=\frac{\partial
f}{\partial y}(p). \f] An \f$x\f$-coordinate \f$\alpha\in\mathbb{R}\f$
is <em>critical</em> if either some critical point has
\f$x\f$-coordinate \f$\alpha\f$, or if the leading coefficient of
\f$f\f$, considered as a polynomial in \f$y\f$, vanishes. In
particular, vertical lines of and isolated point of \f$C\f$ can only
take place at critical \f$x\f$-coordinates.  Between two consecutive
critical \f$x\f$-coordinates, the curve decomposes into a finite
number of \f$x\f$-monotone segments (the same is true on the left of
the leftmost, and on the right of the rightmost critical
\f$x\f$-coordinate).  The type `X_monotone_curve_2` is only able to
represent such segments (and sub-segments of them). See
\cgalFigureRef{arr_figcylindrical_decomposition} for an example of a
decomposition into terminal segments. Formally, a terminal segment is
a weakly \f$x\f$-monotone segment that is either vertical, or its
\f$x\f$-range contains no critical point in its interior.
\cgalAdvancedEnd

\cgalFigureBegin{arr_figcylindrical_decomposition,cylindrical_decomposition.png}
The critical \f$x\f$-coordinates of an algebraic curve (dashed
lines), and its decomposition into terminal segments (in different
colors). The segment from \f$p\f$ to \f$q\f$ consists of the union
of three terminal segments.
\cgalFigureEnd

Coordinates of points are represented by the type `Algebraic_real_1`,
which is defined in the traits class.  This type is taken from a model
of the `AlgebraicKernel_1` concept, which is also available by the
type `Algebraic_kernel_1`.  One can use this model to create algebraic
numbers as roots of univariate polynomials, and process them, for
instance, compare them, or approximate them to any precision. See the
documentation of `AlgebraicKernel_1` for more information.  One can
construct an object of type `Point_2` by a triple \f$(x_0,C,i)\f$,
which means that the \f$i\f$-th point (counted from below) in the
fiber of \f$C\f$ at the \f$x\f$-coordinate \f$x_0\f$ is constructed.
This is also how points are presented internally.  In the example
displayed in \cgalFigureRef{arr_figcylindrical_decomposition}, if
\f$x_1\f$ denotes the \f$x\f$-coordinate of \f$p\f$, and \f$C\f$
represents the algebraic curve, then \f$p\f$ could be represented by
\f$(x_1,C,3)\f$. If \f$x_2\f$ is the \f$x\f$-coordinate of \f$q\f$,
then \f$(x_2,C,1)\f$ is a valid representation of \f$q\f$.  Although
the \f$y\f$-coordinate of an object of type `Point_2` can be queried,
we recommend to be careful with that option, since computing an
explicit representation of the \f$y\f$-coordinate as an
`Algebraic_real_1` object can become rather expensive.

\cgalFigureBegin{arr_figex_alg_segments,algebraic_segments.png} An
arrangement of algebraic segments (solid lines), as constructed in
`algebraic_segments.cpp`. The supporting curves are drawn in dashed
lines.
\cgalFigureEnd

The following code exemplifies various methods to construct
algebraic segments. The computed arrangement is displayed in
\cgalFigureRef{arr_figex_alg_segments}.

\cgalExample{Arrangement_on_surface_2/algebraic_segments.cpp}

\subsection arr_ssecmeta_tr Traits-Class Decorators

Geometric traits-class decorators allow you to attach auxiliary data
to curves and to points. The data is automatically manipulated by the
decorators and distributed to the constructed geometric entities.
Note that additional information can alternatively be maintained by
extending the vertex, halfedge, or face types provided by the
\sc{Dcel} class used by the arrangement; see the details in Section
\ref arr_secex_dcel.

The arrangement package includes a generic traits-class decorator
template named `Arr_curve_data_traits_2<BaseTraits,
XMonotoneCurveData, Merge, CurveData, Convert>`.  This decorator is
used to attach a data field to curves and to \f$x\f$-monotone
curves. It is parameterized by a base-traits class, which is one of
the geometric traits classes described in the previous subsections, or
a user-defined traits class. The curve-data decorator derives itself
from the base-traits class, and in particular inherits its `Point_2`
type.  In addition:

<UL>
<LI>`Curve_2` is derived from the basic `BaseTraits::Curve_2`
class, extending it by an extra field of type `CurveData`.

<LI>`X_monotone_curve_2` is derived from the basic
`BaseTraits::X_monotone_curve_2` class, extending it by an extra field
of type `XMonotoneCurveData`.

</UL>
Note that the `Curve_2` and `X_monotone_curve_2` are not the same,
even if the `BaseTraits::Curve_2` and `BaseTraits::X_monotone_curve_2`
are (as in the case of the segment-traits class for example). The
extended curve types support the additional methods `data()` and
`set_data()` for accessing and modifying the data field.

You can create an extended curve (or an extended \f$x\f$-monotone curve)
from a basic curve and a curve-data object. When curves are
inserted into an arrangement, they may be split, and the
decorator handles their data fields automatically:
<UL>

<LI>When a curve is subdivided into \f$x\f$-monotone subcurves, its
data field of type `CurveData` is converted to an `XMonotoneCurveData`
object \f$d\f$ using the `Convert` functor. The object \f$d\f$ is
automatically associated with each of the resulting \f$x\f$-monotone
subcurves.

Note that by default, the `CurveData` type is identical to the
`XMonotoneCurveData` type (and the conversion functor `Convert` is
trivially defined). Thus, the data field associated with the original
curve is just duplicated and stored with the \f$x\f$-monotone
subcurves.

<LI>When an \f$x\f$-monotone curve is split into two, the decorator
class automatically copies its data field to both resulting subcurves.

<LI>When intersecting two \f$x\f$-monotone curves \f$C_1\f$ and
\f$C_2\f$, the result may include overlapping sections, represented as
\f$x\f$-monotone curves. In this case the data fields of \f$C_1\f$
and \f$C_2\f$ are merged into a single `XMonotoneCurveData` object,
using the `Merge` functor, which is supplied as a parameter to the
traits class-template. The resulting object is assigned to the data
field of the overlapping subcurves.

<LI>Merging two \f$x\f$-monotone curves is allowed only when (i) the
two curves are geometrically mergeable - that is, the base-traits
class allows to merge them - and (ii) the two curves store the same
data field.
</UL>

The `Arr_consolidated_curve_data_traits_2<BaseTraits, Data>` decorator
specializes the generic curve-data decorator. It extends the basic
`BaseTraits::Curve_2` by a single `Data` field, and the basic
`BaseTraits::X_monotone_curve_2` with a <em>set</em> of (distinct)
data objects. The `Data` type is required to support the equality
operator, used to ensure that each set contains only distinct data
objects with no duplicates.  When a curve with a data field \f$d\f$
is subdivided into \f$x\f$-monotone subcurves, each subcurve is
associated with a set \f$S = \{ d \}\f$. In case of an overlap
between two \f$x\f$-monotone curves \f$C_1\f$ and \f$C_2\f$ with
associated data sets \f$S_1\f$ and \f$S_2\f$, respectively, the
overlapping subcurve is associated with the consolidated set \f$S_1
\cup S_2\f$.

\subsubsection Arrangement_on_surface_2Examples Examples

\cgalFigureBegin{arr_figex_17,ex_17.png}
An arrangement of six red and blue segments, as constructed in `consolidated_curve_data.cpp`. Disks correspond to red-blue intersection points, while circles mark the endpoints of red-blue overlaps.
\cgalFigureEnd

In the following example, we use `Arr_segment_traits_2` as our
base-traits class, attaching an additional <em>color</em> field to
the segments using the consolidated curve-data traits class. A
color may be either <em>blue</em> or <em>red</em>. Having constructed
the arrangement of colored segments, as depicted in
\cgalFigureRef{arr_figex_17}, we detect the vertices that have incident
edges mapped to both blue and red segments. Thus, they correspond
to red-blue intersection points. We also locate the edge that
corresponds to overlaps between red and blue line segments:

\cgalExample{Arrangement_on_surface_2/consolidated_curve_data.cpp}

\cgalFigureBegin{arr_figex_18,ex_18.png}
An arrangement of four polylines, named A-D, as constructed in `generic_curve_data.cpp`.
\cgalFigureEnd

In the following example, we use `Arr_polyline_traits_2` as our
base-traits class, attaching an additional <em>name</em> field to each
polyline using the generic curve-data traits class. In case of
overlaps, we simply concatenate the names of the overlapping
polylines. Also notice how we replace the curve associated with the
edges that correspond to overlapping polylines with geometrically
equivalent curves, but with a different data fields:

\cgalExample{Arrangement_on_surface_2/generic_curve_data.cpp}

The third example we give in this section is based on `dual_lines.cpp`
given in Section \ref arr_ssecunb_global. It constructs the
arrangement of the dual lines for a set of point given in an input
file (by default we use `coll_points.dat`, which contains \f$50\f$
points randomly selected on the grid \f$[-100,100]\times[-100,100]\f$;
the file contains two distinct triplets of collinear points). Here we
use the generic curve-data decorator to attach the index of the primal
point to each of the lines.  Doing so, we can go over the incident
edges of each vertex whose degree is greater than \f$4\f$ and report
the subsets collinear points (if we have a vertex of degree \f$d\f$,
we actually need to go over \f$\frac{d}{2}\f$ edges, as each incident
line contributes exactly \f$2\f$ edges). Note that in this case the
dual line cannot overlap, so we use a dummy merge functor to
instantiate the curve-data traits:

\cgalExample{Arrangement_on_surface_2/dual_with_data.cpp}

\section aos_sec-topol_traits The Topology Traits

At this point we do not expose the topology traits concept. The
package contains one topology traits, namely,
`Arr_spherical_topology_traits_2`. It can be served as a topology
traits for an arrangement embeded on a sphere. More precisely, for an
arrangement embeded on a sphere defined over a parameter space the
left and right boundary sides of which are identified and the top and
bottom boundary sides are contracted.

\section arr_secnotif The Notification Mechanism

For some applications it is essential to know exactly what
happens inside a specific arrangement-instance. For example, when
a new curve is inserted into an arrangement, it might be desired to keep
track of the faces that are split due to this insertion operation.
Other important examples are the point-location strategies that
require auxiliary data-structures (see Section \ref arr_ssecpl),
which must be notified on various local changes in the arrangement,
in order to keep their data structures up-to-date. The arrangement
package offers a mechanism that uses <em>observers</em>
(see \cgalCite{cgal:ghjv-dpero-95}) that can be
attached to an arrangement instance and receive notifications
about the changes this arrangement goes through.

The `Arr_observer<Arrangement>` class-template is
parameterized with an arrangement class. It stores a pointer to an
arrangement object, and is capable of receiving notifications <em>just before</em> a structural change occurs in the arrangement and
<em>immediately after</em> such a change takes place.
`Arr_observer` serves as a base class for other observer
classes and defines a set of virtual notification functions,
with default empty implementations.

The set of functions can be divided into three categories, as
follows:
<OL>
<LI>Notifiers of changes that affect the entire topological structure
of the arrangement. This category consists of two pairs that
notify the observer of the following changes:
<UL>
<LI>The arrangement is cleared.
<LI>The arrangement is assigned with the contents of another
arrangement.
</UL>
<LI>Pairs of notifiers of a local change that occurs in the
topological structure. Most notifier functions belong to this
category. The relevant local changes include:
<UL>
<LI>A new vertex is constructed and associated with a point.

<li>An edge\cgalFootnote{The term "edge" refers here to a pair of twin
half-edges.} is constructed and associated with an \f$x\f$-monotone
curve.

<LI>An edge is split into two edges.
<LI>An existing face is split into two faces, as a consequence of the
insertion of a new edge.
<LI>A hole is created in the interior of a face.
<LI>Two holes are merged to form a single hole, as a consequence of the
insertion of a new edge.
<LI>A hole is moved from one face to another, as a consequence of
a face split.
<LI>Two edges are merged into one edge.
<LI>Two faces are merged into one face, as a consequence of the
removal of an edge that used to separate them.
<LI>One hole is split into two, as a consequence of the deletion of an
edge that used to connect the two components.
<LI>A vertex is removed.
<LI>An edge is removed.
<LI>A hole is deleted from the interior of a face.
</UL>
<LI>Notifiers about a change applied by a free (global) function.
This category consists of a single pair of notifiers, namely
`before_global_change()` and `after_global_change()`. Neither of
these functions is invoked by methods of the `Arrangement_2` class.
Instead, they are called by the free functions themselves. It is implied
that no point-location queries (or any other queries for that matter)
are issued between the calls to the notification functions above.
</OL>
See the Reference Manual for a detailed specification of the
`Arr_observer` class along with the exact prototypes of all
notification functions.

Each arrangement object stores a (possibly empty) list of pointers to
`Arr_observer` objects, and whenever one of the structural
changes listed in the first two categories above is about to take
place, the arrangement object performs a <em>forward</em> traversal
on this list and invokes the appropriate function of each
observer. After the change takes place the observer list is
traversed in a <em>backward</em> manner (from tail to head), and the
appropriate notification function is invoked for each observer.
This allows the nesting of observer objects.

Concrete arrangement-observer classes should inherit from
`Arr_observer`. When an observer is constructed, it is attached to
a valid arrangement supplied to the observed constructor, or alternatively
the observer can be attached to the arrangement at a later time.
When this happens, the observer instance inserts itself into the
observer list of the associated arrangement and starts receiving
notifications whenever this arrangement changes thereafter. Naturally,
the observer object unregisters itself by removing itself from
this list just before it is destroyed.

The trapezoidal RIC and the landmark point-location strategies
both use observers to keep their auxiliary data structures
up-to-date. Besides them, users can define their own observer
classes, by inheriting from the base observer class and overriding
the relevant notification functions, as required by their
applications.

\cgalFigureBegin{arr_figex_19,ex_19.png}
An arrangement of five line segments, as constructed in `observer.cpp`.
The halfedge \f$e_v\f$ (dashed) is eventually removed, so that the
final arrangement consists of four faces (one unbounded and three
bounded ones).
\cgalFigureEnd

The following example shows how to define and use an observer
class. The observer in the example keeps track of the arrangement
faces, and prints a message whenever a face is split into two due
to the insertion of an edge, and whenever two faces merge into one
due to the removal of an edge. The layout of the arrangement is
depicted in \cgalFigureRef{arr_figex_19} :

\cgalExample{Arrangement_on_surface_2/observer.cpp}

Observers are especially useful when the \sc{Dcel} records are
extended and store additional data, as they help updating this
data on-line. See Section \ref arr_secex_dcel for more details
and examples.

\section arr_secex_dcel Extending the DCEL

For many applications of the arrangement package it is necessary to
store additional information (perhaps of non-geometric nature) with
the arrangement cells. As vertices are associated with `Point_2`
objects and edges (halfedge pairs) are associated with
`X_monotone_curve_2` objects, both defined by the traits class,
it is possible to extend the traits-class type by using a traits-class
decorator, as explained in Section \ref arr_ssecmeta_tr, which may
be a sufficient solution for some applications.
However, the \sc{Dcel} faces are not associated with any geometric object,
so it is impossible to extend them using a traits-class decorator.
Extending the \sc{Dcel} face records comes handy is such cases. As a matter
of fact, it is possible to conveniently extend all \sc{Dcel} records
(namely vertices, halfedges and faces), which can also be advantageous
for some applications.

All examples presented so far use the default
`Arr_default_dcel<Traits>`.  This is done implicitly, as this class
serves as a default parameter for the `Arrangement_2` template. The
default \sc{Dcel} class just associates points with vertices and
\f$x\f$-monotone curves with halfedge, but nothing more.  In this
section we show how to use alternative \sc{Dcel} types to extend the
desired \sc{Dcel} records.

\subsection arr_ssecex_dcel_face Extending the DCEL Faces

The `Arr_face_extended_dcel<Traits, FaceData>` class-template is used
to associate auxiliary data field of type `FaceData` to each face
record in the \sc{Dcel}.

When an `Arrangement_2` object is parameterized by this \sc{Dcel}
class, its nested `Face` type is extended with the access function
`data()` and with the modifier `set_data()`. Using these extra
functions it is straightforward to access and maintain the auxiliary
face-data field.

Note that the extra data fields must be maintained by the application
programmers. They may choose to construct their arrangement, and only
then go over the faces and attach the appropriate data fields to the
arrangement faces. However, in some cases the face data can only be
computed when the face is created (split from another face, or merged
with another face). In such cases one can use an arrangement observer
tailored for this task, which receives updates whenever a face is
modified and sets its data field accordingly.

\cgalFigureBegin{arr_figex_20,ex_20.png}
An arrangement of six line segments, as constructed in `face_extension.cpp` and `dcel_extension.cpp` (in `dcel_extension.cpp` we treat the segments as directed, so they are drawn as arrows directed from the source to the target). The indices associated with the halfedges in `face_extension.cpp` are shown in brackets.
\cgalFigureEnd


The next example constructs an arrangement that contains seven bounded
faces induced by six line segments (see
\cgalFigureRef{arr_figex_20}). An observer gets notified each time a
new face \f$f\f$ is created and it associates \f$f\f$ with a running
index, (where the index of the unbounded face is 0). As a result, the
faces are numbered according to their creation order, as one can
easily verify by examining the insertion order of the
segments:\cgalFootnote{For simplicity, the particular observer used
must be attached to an empty arrangement. It is not difficult however
to modify the program to handle the general case of attaching a
similar observer to a non-empty arrangement.}

\cgalExample{Arrangement_on_surface_2/face_extension.cpp}

\subsection arr_ssecex_dcel_all Extending All DCEL Records

The `Arr_extended_dcel<Traits, VertexData, HalfedgeData, FaceData>`
class-template is used to associate auxiliary data fields of
types `VertexData` `HalfedgeData`, and `FaceData` to
each \sc{Dcel} vertex, halfedge, and face record types, respectively.

When an `Arrangement_2` object is injected with this
\sc{Dcel} class, each one of its nested `Vertex`, `Halfedge` and
`Face` classes is extended by the access function `data()`
and by the modifier `set_data()`.

The next example shows how to use a \sc{Dcel} with extended vertex,
halfedge, and face records. In this example each vertex is associated
with a color, which may be blue, red, or white, depending on whether the
vertex is isolated, represents a segment endpoint, or whether it
represents an intersection point. Each halfedge is associated with
Boolean flag indicating whether its direction is the same as the
direction of its associated segment (in this example segments are
treated as directed objects). Each face is also extended to store the
size of its outer boundary.

The constructed arrangement, depicted in \cgalFigureRef{arr_figex_20},
is similar to the arrangement constructed in the previous example.
Note that all auxiliary data fields are set during the construction
phase.  Also note that the data fields are properly maintained when
the arrangement is copied to another arrangement instance:

\cgalExample{Arrangement_on_surface_2/dcel_extension.cpp}

\cgalAdvancedBegin
The various \sc{Dcel} classes presented in this section are perfectly
sufficient for most applications based on the arrangement package.
However, users may also use their own implementation of a \sc{Dcel} class
to instantiate the `Arrangement_2` class-template, in case they need
special functionality from their \sc{Dcel}. Such a class must be a model of the
concept `ArrangementDcel`, whose exact specification is listed in the
Reference Manual.
\cgalAdvancedEnd

\section arr_secoverlay Overlaying Arrangements

Assume that we are given two geographic maps represented as
arrangements with some data objects attached to their faces,
representing some geographic information - for example, a map of
the annual precipitation in some country and a map of the vegetation
in the same country. It is interesting to overlay the two maps to
locate, for example, the regions where there is a pine forest and
the annual precipitation is between 1000mm and 1500mm.

Computing the overlay of two planar arrangement is also useful for
supporting Boolean set operations on polygons (or generalized
polygons, see, e.g., \cgalCite{cgal:behhms-cbcab-02}).

The function `overlay (arr_a, arr_b, ovl_arr, ovl_traits)` accepts two
input arrangement instances `arr_a` and `arr_b`, and constructs their
overlay instance `ovl_arr`. All three arrangements must use the same
geometric primitives. More precisely, let `arr_a` be of type
`Arrangement_2<Traits_A,Dcel_A>`, `arr_b` be of type
`Arrangement_2<Traits_B,Dcel_B>` and the resulting `ovl_arr` be of
type `Arrangement_2<Traits_R,Dcel_R>`. All types nested in geometry
traits `Traits_A`, e.g., `Point_2` and `X_monotone_curve_2`, must be
convertible to the corresponding types nested in geometry traits
`Traits_R`. The same holds for all types nested in geometry traits
`Traits_B`.  The `ovl_traits` parameter is an instance of an
<em>overlay traits-class</em>, which enables the creation of `Dcel_R`
records in the overlaid arrangement from the \sc{Dcel} features of
`arr_a` and `arr_b` that they correspond to.

In principle, we distinguish between three levels of overlay:
<DL>
<DT><B>Simple overlay:</B>

<DD>An overlay of two arrangements that store no additional data with
their \sc{Dcel} records. That is, they are defined using the default
\sc{Dcel} class `Arr_default_dcel`. Typically, the overlaid
arrangement in this case stores no extra data with its \sc{Dcel}
records as well (or if it does, the additional data fields cannot be
computed by the overlay operation), so by overlaying the two
arrangement we just compute the arrangement of all curves that induce
`arr_a` and `arr_b`.  Note that the same result can be obtained using
the standard insertion operations, but users may choose to use overlay
computation in order to achieve better running times.

The `Arr_default_overlay_traits` class should be used as an overlay
traits-class for such simple overlay operations.
<DT><B>Face overlay:</B>
<DD> An overlay of two arrangements that store additional
data fields with their faces (e.g., the geographic-map example given
in the beginning of this section). The resulting overlaid arrangement
typically also stores extraneous data fields with its faces, where the
data field that is attached to an overlaid face can be computed from
the data fields of the two faces (in `arr_a` and `arr_b`) that induce
the overlaid face.

The `Arr_face_overlay_traits` class should be used as an overlay
traits-class for face-overlay operations. It operates on arrangement, whose
\sc{Dcel} representation is based on the `Arr_face_extended_dcel`
class-template (see Section \ref arr_ssecex_dcel_face). The face-overlay
traits-class is parameterized by a functor that is capable of combining two
face-data fields of types `Dcel_A::Face_data` and
`Dcel_B::Face_data`, and computing the output `Dcel_R::Face_data`
object. The overlay traits-class uses this functor to properly construct
the overlaid faces.

<DT><B>Full overlay:</B>
<DD>An overlay of two arrangements that store additional data fields
with all their \sc{Dcel} records. That is, their \sc{Dcel} classes are
instantiations of the `Arr_extended_dcel` class-template (see Section
\ref arr_ssecex_dcel_all), where the resulting arrangement also
extends it \sc{Dcel} records with data fields computed on the basis of
the overlapping \sc{Dcel} features of the two input arrangements.
</DL>

In the following subsections we give some examples for the simple and the
face-overlay operations and demonstrate how to use the auxiliary overlay
traits-classes. For the full overlay operations users need to implement
their specialized overlay traits-class, which models the `OverlayTraits`
concept. The details of this concept are given in the Reference Manual.

\subsection arr_ssecsimp_ovl Example for a Simple Overlay

\cgalFigureBegin{arr_figex_22,ex_22.png}
Overlaying two simple arrangements of line segments, as done in
`overlay.cpp` and `ex_face_extension_overlay.cpp`. In
`face_extension_overlay.cpp` the two bounded faces are considered as
<em>marked</em>, and the octagonal face which is the intersection of
the two marked faces is denoted by \f$f_0\f$.
\cgalFigureEnd

The next program constructs two simple arrangements, as depicted in
\cgalFigureRef{arr_figex_22} and computes their overlay:

\cgalExample{Arrangement_on_surface_2/overlay.cpp}

\subsection arr_ssecface_ovl Examples for a Face Overlay

The following example shows how to compute the intersection of two
polygons using the `overlay()` function. It uses a face-extended
\sc{Dcel} class to define our arrangement class. The \sc{Dcel} extends
each face with a Boolean flag. A polygon is represented as a
<em>marked</em> arrangement face, (whose flag is set). The example
uses a face-overlay traits class, instantiated with a functor that
simply performs a logical <em>and</em> operations on Boolean flags.
As a result, a face in the overlaid arrangement is marked only when it
corresponds to an overlapping region of two marked cells in the input
arrangements. Namely, it is part of the intersection of the two
polygons.

The example computes the intersection between a square and a rhombus,
(which is actually also a square). The resulting polygon is an
octagon, denoted by \f$f_0\f$ in \cgalFigureRef{arr_figex_22} :

\cgalExample{Arrangement_on_surface_2/face_extension_overlay.cpp}

The next example demonstrates the face overlay of two arrangements
that have unbounded faces as well. The first arrangement is formed by
the two lines \f$y = x\f$ and \f$y = -x\f$, that subdivide the plane
into four unbounded faces, denoted \f$A\f$, \f$B\f$, \f$C\f$ and
\f$D\f$. The second arrangement comprises four line segments that
form a square-shaped face. When we overlay the two arrangements, each
of the four faces \f$A\f$, \f$B\f$, \f$C\f$ and \f$D\f$ is split
into an unbounded face (indexed 1) and a bounded face (indexed 2):

\cgalExample{Arrangement_on_surface_2/overlay_unbounded.cpp}

\section arr_secarr_with_hist Storing the Curve History

As stated at the beginning of this chapter (Section \ref
aos_sec-intro), when one constructs an arrangement induced by a set
\f$\cal C\f$ of arbitrary planar curves, she or he constructs a
collection \f$\cal C''\f$ of \f$x\f$-monotone subcurves of \f$\cal
C\f$ that are pairwise disjoint in their interior, and these subcurves
are associated with the arrangement edges (more precisely, with the
\sc{Dcel} halfedges). Doing so, the connection between the originating
input curves and the arrangement edges is lost. This loss might be
acceptable for some applications. However, in many practical cases it
is important to determine the input curves that give rise to the final
subcurves.

The `Arrangement_with_history_2<Traits,Dcel>` class-template extends
the `Arrangement_2` class by keeping an additional container of input
curves representing \f$\cal C\f$, and by maintaining a cross-mapping
between these curves and the arrangement edges they induce. The traits
class that is used for instantiating the template should be a model of
the `ArrangementTraits_2` concept (see Section \ref
aos_ssec-insert_gen).  That is, it should define the `Curve_2` type
(and not just the `X_monotone_curve_2` type). The `Dcel` parameter
should model the `ArrangementDcel` concept. Users can use the default
\sc{Dcel} class or an extended \sc{Dcel} class according to their
needs.

\subsection arr_ssecarrwh_traverse Traversing an Arrangement with History

The `Arrangement_with_history_2` class extends the `Arrangement_2`
class, thus all the iterator and circulator types that are defined by
the arrangement class are also available in
`Arrangement_with_history_2`.  The reader is referred to Section \ref
arr_ssectraverse for a comprehensive review of these functions.

As mentioned above, the `Arrangement_with_history_2` class maintains
a container of input curves, which can be accessed using curve handles.
The member function `number_of_curves()` returns the number of input
curves stored in the container, while `curves_begin()` and
`curves_end()` return `Arrangement_with_history_2::Curve_iterator`
objects that define the valid range of curves that induce the arrangement.
The value type of this iterator is `Curve_2`. Moreover, the curve-iterator
type is equivalent to `Arrangement_with_history_2::Curve_handle`, which
is used for accessing the stored curves. Conveniently, the corresponding
constant-iterator and constant-handle types are also defined.

As mentioned in the previous paragraph, a `Curve_handle` object `ch`
serves as a pointer to a curve stored in an arrangement-with-history instance
`arr`. Using this handle, it is possible to obtain the number of
arrangement edges this curve induces by calling
`arr.number_of_induced_edges(ch)`. The functions
`arr.induced_edges_begin(ch)` and
`arr.induced_edges_end(ch)` return iterators of type
`Arrangement_with_history_2::Induced_edges_iterator` that define the
valid range of edges induced by `ch`. The value type of these iterators
is `Halfedge_handle`. It is thus possible to traverse all arrangement
edges induced by an input curve.

It is also important to be able to perform the inverse mapping. Given an
arrangement edge, we would like to be able to determine which input curve
induces it. In case the edge represents an overlap of several curves, we
should be able to trace all input curves that overlap over this edge.
The `Arrangement_with_history_2` class is extended by several member
functions that enable such an inverse mapping. Given a halfedge handle `e`
in an arrangement with history `arr`, then
`arr.number_of_originating_curves(e)` returns the number of curves that
induce the edge (which should be 1 in non-degenerate cases, and 2 or more
in case of overlaps), while `arr.originating_curves_begin(e)` and
`arr.originating_curves_end(e)` return
`Arrangement_with_history_2::Originating_curve_iterator` objects that
define the range of curves that induce `e`. The value type of these
iterator is `Curve_2`.

It is possible to overlay two `Arrangement_with_history_2` instances
instantiated by the same traits class. In this case, the resulting
arrangement will store a consolidated container of input curves, and
automatically preserve the cross-mapping between the arrangement edges
and the consolidated curve set. Users can employ an overlay-traits class
to maintain any type of auxiliary data stored with the \sc{Dcel} features
(see Section \ref arr_secoverlay).

\subsection arr_ssecmodif_traverse Modifying an Arrangement with History

As the `Arrangement_with_history_2` class extends the `Arrangement_2`
class, it inherits the fundamental modification operations, such as
`assign()` and `clear()`, from it. The vertex-manipulation functions
are also inherited and supported (see Sections \ref
arr_sssecmf_iso_verts and \ref arr_sssecinsert_point for the
details). However, there are some fundamental differences between the
interfaces of the two classes, which we highlight in this subsection.

The most significant difference between the arrangement-with-history
class and the basic arrangement class is the way they handle their
input curves.  `Arrangement_with_history_2` always stores the
`Curve_2` objects that induce it, thus it is impossible to insert
\f$x\f$-monotone curves into an arrangement with history. The free
`insert_non_intersecting_curve()` and `insert()` that receives
\f$x\f$-monotone curve (as well as their aggregated versions) are
therefore not available for arrangement-with-history instances and
only the free `insert()` and `insert()` functions that receive
`Curve_2` (the incremental insertion function and the aggregated
insertion function) are supported - see also Section \ref
aos_ssec-insert_gen. Notice however that while the incremental
insertion function `insert(arr,c)` for an `Arrangement_2` object `arr`
does not have a return value, the corresponding
arrangement-with-history function returns a `Curve_handle` to the
inserted curve.

As we are able to keep track of all edges induced by an input curve,
we also provide a free function that removes a curve from an
arrangement. By calling `remove(arr,ch)`, where `ch` is a valid curve
handle, the given curve is deleted from the curve container, and all
edges induced solely by this curve (i.e., excluding overlapping edges)
are removed from the arrangement. The function returns the number of
edges that have been removed.

In some cases, users may need to operate directly on the arrangement
edges.  We first mention that the specialized insertion functions (see
Section \ref arr_sssecmf_insert_cv) are not supported, as they accept
\f$x\f$-monotone curves. Insertion can only be performed via the free
insertion-functions. The other edge-manipulation functions (see
Section \ref arr_sssecmf_halfedges) are however available, but have a
different interface that does not use \f$x\f$-monotone curves:

<UL>

<LI>Invoking `split_edge(e,p)` splits the edge `e` at a given point
`p` that lies in its interior.  <LI>Invoking `merge_edge(e1,e2)`
merges the two given edges. There is a precondition that `e1` and `e2`
shared a common end-vertex of degree 2, and that the \f$x\f$-monotone
subcurves associated with these edges are mergeable.  <LI>It is
possible to remove an edge by simply invoking `remove_edge(e)`.</LI>
</UL>

In all cases, the maintenance of cross-pointers for the appropriate
input curves will be done automatically.

It should be noted that it is possible to attach observers to an
arrangement-with-history instance in order to get detailed notifications of
the changes the arrangements undergoes (see Section \ref arr_secnotif for
the details).

\subsection arr_ssecarr_hist_ex Examples

\cgalFigureBegin{arr_figex_24,ex_24.png}
An arrangement with history as constructed in `curve_history.cpp`. Note that \f$s_1\f$ and \f$s_3\f$ overlap over two edges. The point-location query points are drawn as lightly shaded dots.
\cgalFigureEnd

In the following example we construct a simple arrangement of six line
segments, as depicted in \cgalFigureRef{arr_figex_24}, while
maintaining the curve history. The example demonstrates the usage of
the special traversal functions. It also shows how to issue
point-location queries on the resulting arrangement, using the
auxiliary function `locate_point()` defined in the header file
`point_location_utils.h`; see also Section \ref arr_ssecpl.

\cgalExample{Arrangement_on_surface_2/curve_history.cpp}

\cgalFigureBegin{arr_figex_25,ex_25.png}
An arrangement with history of nine circle as constructed in `edge_manipulation_curve_history.cpp`. Note the vertical tangency points of \f$C_0\f$, marked as dark dots, which subdivide this circle into an upper half and a lower half, each consists of 9 edges. The large circle \f$C_0\f$ is eventually removed from the arrangement, with all 18 edges it induces.
\cgalFigureEnd

The following example demonstrates the usage of the free `remove()`
function. We construct an arrangement of nine circles, while keeping a
handle to each inserted circle. We then remove the large circle
\f$C_0\f$, which induces \f$18\f$ edges, as depicted in
\cgalFigureRef{arr_figex_25}. The example also shows how to use the
`split_edge()` and `merge_edge()` functions when operating on an
arrangement-with-history instance:

\cgalExample{Arrangement_on_surface_2/edge_manipulation_curve_history.cpp}

\section aos_sec-io Input/Output Streams

In some cases, one would like to save an arrangement object
constructed by some application, so that later on it can be
restored. In other cases one would like to create nice drawings that
represent arrangements constructed by some application. These
drawings can be hard printed or displayed on a computer screen.

\subsection aos_ssec-io-stream Input/Output Stream

Consider an arrangement that represents a very complicated geographical
map, and assume that there are various applications that need to answer
point-location queries on this map. Naturally, you can store the set of
curves that induces the arrangement, but this implies that you would need
to construct the arrangement from scratch each time you need to reuse it.
A more efficient solution is to write the arrangement to a file in a format
that other applications can read.

This package provides an <em>inserter</em> (the `<<` operator) and an
<em>extractor</em> (the `>>` operator) for the
`Arrangement_2<Traits,Dcel>` class that inserts and an arrangement
object into an output stream and extracts an arrangement object from
an input stream respectively. The arrangement is written using a
simple predefined ASCII format that encodes the arrangement topology,
as well as all geometric entities associated with vertices and edges.

The ability to use the input/output operators, requires that the
`Point_2` type and the `X_monotone_curve_2` type defined by the traits
class both support the `<<` and `>>` operators. The
`Arr_conic_traits_2` class (see Section \ref arr_ssectr_conic), the
`Arr_rational_function_traits_2` class (see Section \ref
arr_ssectr_ratfunc), and the `Arr_linear_traits_2` class (see Section
\ref arr_ssectr_segs) currently do not provide these operators for the
geometric types they define.  Thus, only arrangements of line segments
or of polylines can be written or read.

The following example constructs the arrangement depicted in
\cgalFigureRef{arr_figex_5} and writes it to an output file. It also
demonstrates how to re-read the arrangement from a file:

\cgalExample{Arrangement_on_surface_2/io.cpp}

\subsection arr_ssecarr_io_aux_data Arrangements with Auxiliary Data

\cgalAdvancedBegin
The inserter and extractor both ignore any auxiliary data stored with
the arrangement features. Thus, they are ideal for arrangements
instantiated using the `Arr_default_dcel` class.
However, as explained in Section \ref arr_secex_dcel, one can easily
extend the arrangement faces by using the `Arr_face_extended_dcel`
template, or extend all \sc{Dcel} records by using the `Arr_extended_dcel`
template. In such cases, it might be crucial that the auxiliary data fields
are written to the file and read from there.

The arrangement package includes the free functions
`write(arr, os, formatter)`, which writes the arrangement `arr`
to an output stream `os`, and `read(arr, os, formatter)`, which
reads the arrangement `arr` from an input stream `is`. Both
operations are performed using a `formatter` object, which defines
the I/O format. The package contains three formatter classes:
<UL>
<LI>`Arr_text_formatter<Arrangement>` defines a simple textual
I/O format for the arrangement topology and geometry, disregarding any
auxiliary data that may be associated with the arrangement features.
This is the default formatter used by the arrangement inserter and the
arrangement extractor, as defined above.
<LI>`Arr_face_extended_text_formatter<Arrangement>` operates on
arrangements whose \sc{Dcel} representation is based on the
`Arr_face_extended_dcel<Traits,FaceData>` class (see
Section \ref arr_ssecex_dcel_face). It supports reading and writing
the auxiliary data objects stored with the arrangement faces provided
that the `FaceData` class supports an inserter and an extractor.
<LI>`Arr_extended_dcel_text_formatter<Arrangement>` operates on
arrangements whose \sc{Dcel} representation is based on the
`Arr_extended_dcel<Traits,VertexData,HalfedgeData,FaceData>` class
(see Section \ref arr_ssecex_dcel_all). It supports reading and writing
the auxiliary data objects stored with the arrangement vertices, edges
and faces, provided that the `VertexData`, `HalfedgeData` and
`FaceData` classed all have inserters and extractors.
</UL>

The following example constructs the same arrangement as the example
`dcel_extension` does (see Section \ref arr_ssecex_dcel_all), depicted
in \cgalFigureRef{arr_figex_20}, and writes it to an output file. It
also demonstrates how to re-read the arrangement from a file:

\cgalExample{Arrangement_on_surface_2/dcel_extension_io.cpp}

You may develop your own own formatter classes - models of the
`ArrangementInputFormatter` and `ArrangementOutputFormatter`
concepts, as defined in the Reference Manual.
Doing so, you can define other I/O formats, such as an XML-based
format or a binary format.
\cgalAdvancedEnd

\subsection arr_ssecarr_io_hist Arrangements with Curve History

Section \ref arr_secarr_with_hist introduces the
`Arrangement_with_history_2<Traits,Dcel>` class, which saves the
set of curves inducing an arrangement and maintains the relations between
these curves and the edges they induce. Naturally, when reading or writing
an arrangement-with-history instance we would like this information to be
saved to the output stream or restored from the input stream alongside
with the basic arrangement structure.

The arrangement package supplies an inserter and an extractor for the
`Arrangement_with_history_2<Traits,Dcel>` class. The arrangement is
represented using a simple predefined ASCII format. An object of the
`Arrangement_with_history_2<Traits,Dcel>` type can be saved and
restored, as long as the `Curve_2` type defined by the traits
class---as well as the `Point_2` type and the `X_monotone_curve_2`
types---support the `<<` and`>>` operators.

The following example constructs the same arrangement as example
`curve_history` does
(see Section \ref arr_ssecarr_hist_ex), depicted in
\cgalFigureRef{arr_figex_24}, and writes it to an output file. It also
demonstrates how to re-read the arrangement-with-history from a file:

\cgalExample{Arrangement_on_surface_2/io_curve_history.cpp}

\cgalAdvancedBegin
The arrangement package also includes the free functions
`write(arr, os, formatter)` and `read(arr, os, formatter)` that
operate on a given arrangement-with-history instance `arr`.
Both functions are parameterized by a `formatter` object, which define
the I/O format. The package contains a template called,
`Arr_with_hist_text_formatter<ArranagmentFormatter>`, which extends
an arrangement formatter class (see Section \ref arr_ssecarr_io_aux_data)
and defines a simple textual input/output format.
\cgalAdvancedEnd

\section aos_sec-bgl Adapting to Boost Graphs

<span class="textsc">Boost</span>\cgalFootnote{See also <span class="textsc">Boost</span>'s homepage at: <TT>www.boost.org</TT>.}
is a collection of portable \cpp libraries that extend the Standard Template Library (<span class="textsc">Stl</span>). The <span class="textsc">Boost</span> Graph Library (<span class="textsc">bgl</span>), which one of the libraries in the collection, offers an
extensive set of generic graph algorithms parameterized through templates.
As our arrangements are embedded as planar graphs, it is only
natural to extend the underlying data structure with the interface that the
<span class="textsc">bgl</span> expects, and gain the ability to perform the operations that the <span class="textsc">bgl</span> supports, such as shortest-path computation. This section describes how apply
the graph algorithms implemented in the <span class="textsc">bgl</span> to `Arrangement_2` instances.

An instance of `Arrangement_2` is adapted to a <span
class="textsc">Boost</span> graph through the provision of a set of
free functions that operate on the arrangement features and conform
with the relevant BGL concepts. Besides the straightforward
adaptation, which associates a vertex with each \sc{Dcel} vertex and
an edge with each \sc{Dcel} halfedge, the package also offer a
<em>dual</em> adaptor, which associates a graph vertex with each
\sc{Dcel} face, such that two vertices are connected, iff there is a
\sc{Dcel} halfedge that connects the two corresponding faces.

\subsection arr_ssecbgl_primal The Primal Arrangement Representation

Arrangement instances are adapted to <span class="textsc">Boost</span>
graphs by specializing the \link BGLArgtGT `boost:graph_traits`
\endlink template for `Arrangement_2` instances. The graph-traits
states the graph concepts that the arrangement class models (see
below) and defines the types required by these concepts.

In this specialization the `Arrangement_2` vertices correspond to the
graph vertices, where two vertices are adjacent if there is at least
one halfedge connecting them. More precisely,
`Arrangement_2::Vertex_handle` is the graph-vertex type, while
`Arrangement_2::Halfedge_handle` is the graph-edge type. As halfedges
are directed, we consider the graph to be directed as well. Moreover,
as several interior-disjoint \f$x\f$-monotone curves (say circular
arcs) may share two common endpoints, inducing an arrangement with two
vertices that are connected with several edges, we allow parallel
edges in our <span class="textsc">Boost</span> graph.

Given an `Arrangement_2` instance, we can efficiently traverse its
vertices and halfedges. Thus, the arrangement graph is a model of the
concepts `VertexListGraph` and `EdgeListGraph` introduced by the <span
class="textsc">bgl</span>.  At the same time, we use an iterator
adapter of the circulator over the halfedges incident to a vertex
(`Halfedge_around_vertex_circulator` - see Section \ref
arr_sssectr_vertex), so it is possible to go over the ingoing and
outgoing edges of a vertex in linear time. Thus, our arrangement graph
is a model of the concept `BidirectionalGraph` (this concept refines
`IncidenceGraph`, which requires only the traversal of outgoing
edges).

It is important to notice that the vertex descriptors we use are
`Vertex_handle` objects and <em>not</em> vertex indices. However, in
order to gain more efficiency in most <span class="textsc">bgl</span>
algorithms, it is better to have them indexed \f$0, 1, \ldots,
(n-1)\f$, where \f$n\f$ is the number of vertices. We therefore
introduce the `Arr_vertex_index_map<Arrangement>` class-template,
which maintains a mapping of vertex handles to indices, as required by
the <span class="textsc">bgl</span>. An instance of this class must be
attached to a valid arrangement vertex when it is created. It uses the
notification mechanism (see Section \ref arr_secnotif) to
automatically maintain the mapping of vertices to indices, even when
new vertices are inserted into the arrangement or existing vertices
are removed.

In most algorithm provided by the <span class="textsc">bgl</span>, the
output is given by <em>property maps</em>, such that each map entry
corresponds to a vertex.  For example, when we compute the shortest
paths from a given source vertex \f$s\f$ to all other vertices we can
obtain a map of distances and a map of predecessors - namely for each
\f$v\f$ vertex we have its distance from \f$s\f$ and a descriptor of
the vertex that precedes \f$v\f$ in the shortest path from \f$s\f$.

If the vertex descriptors are simply indices, boost supplies tools to
easily represent property maps using vectors.
`Arr_vertex_index_map<Arrangement>` class allows create such indices,
and together with `boost::vector_property_map<Type, IndexMap>` allows
for an efficient mapping of `Vertex_handle` objects to properties of
type `Type`. Note however that unlike the `Arr_vertex_index_map`
class, the vertex property-map class is not kept synchronized with the
number of vertices in the arrangement, so it should not be reused in
calls to <span class="textsc">bgl</span> functions in case the
arrangement is modified in between these calls.

\cgalFigureBegin{arr_figex_bgl,ex_bgl.png}
An arrangement of 7 line segments, as constructed by
`bgl_primal_adapter.cpp` and `bgl_dual_adapter.cpp`. The
breadth-first visit times for the arrangement faces, starting from
the unbounded face \f$f_0\f$, are shown is brackets.
\cgalFigureEnd

In the following example we construct an arrangement of 7 line
segments, as shown in \cgalFigureRef{arr_figex_bgl}, then use
Dijkstra's shortest-paths algorithm from the <span
class="textsc">bgl</span> to compute the graph distance of all
vertices from the leftmost vertex in the arrangement \f$v_0\f$. Note
the usage of the `boost::vector_property_map<Type, IndexMap>` and the
`Arr_vertex_property_map` classes. The latter one, instantiated by the
type `double` is used to map vertices to their distances from
\f$v_0\f$.

\cgalExample{Arrangement_on_surface_2/bgl_primal_adapter.cpp}

\subsection arr_ssecbgl_dual The Dual Arrangement Representation

It is possible to give a dual graph representation for an arrangement
instance, such that each arrangement face corresponds to a graph
vertex and two vertices are adjacent iff the corresponding faces share
a common edge on their boundaries. This is done by specializing the
`boost:graph_traits` template for `Dual<Arrangement_2>` instances,
where `Dual<Arrangement_2>` is a template specialization that gives a
dual interpretation to an arrangement instance.

In dual representation, `Arrangement_2::Face_handle` is the
graph-vertex type, while `Arrangement_2::Halfedge_handle` is the
graph-edge type. We treat the graph edges as directed, such that a
halfedge `e` is directed from \f$f_1\f$, which is its incident face,
to \f$f_2\f$, which is the incident face of its twin halfedge. As two
arrangement faces may share more than a single edge on their boundary,
we allow parallel edges in our <span class="textsc">Boost</span>
graph. As is the case in the primal graph, the dual arrangement graph
is also a model of the concepts `VertexListGraph`, `EdgeListGraph` and
`BidirectionalGraph` (thus also of `IncidenceGraph`).

Since we use `Face_handle` objects as the vertex descriptors, we
define the `Arr_face_index_map<Arrangement>` class-template, which
maintains an efficient mapping of face handles to indices.  Like
vertices, `boost::vector_property_map<Type, IndexMap>` can be used for
associating arbitrary data with the arrangement faces.

In the following example we construct the same arrangement as in
example `bgl_primal_adapter.cpp` (see \cgalFigureRef{arr_figex_bgl}),
and perform breadth-first search on the graph faces, starting from the
unbounded face. We extend the \sc{Dcel} faces with an unsigned
integer, marking the discover time of the face using `boost` visitors
and a property-map class that directly accesses the extended data of
the faces:

\cgalExample{Arrangement_on_surface_2/bgl_dual_adapter.cpp}

\section aos_sec-tips How To Speed Up Your Computation

Before the specific tips, we remind you that compiling programs with
debug flags disabled and with optimization flags enabled significantly
reduces the running time.

<OL>

<LI>When the curves to be inserted into an arrangement are
\f$x\f$-monotone and pairwise disjoint in their interior to start
with, then it is more efficient (in running time) and less demanding
(in traits-class functionality) to use the non-intersection
insertion-functions instead of the general ones; e.g., `insert()`.

<LI>When the curves to be inserted into an arrangement are segments that
are pairwise disjoint in their interior, it is more efficient to use
the traits class `Arr_non_caching_segment_traits_2` rather then
the default one (`Arr_segment_traits_2`).

If the segments may intersect each other, the default traits class
`Arr_segment_traits_2` can be safely used with the somehow limited
number type `Quotient<MP_float>`.

On rare occasions the traits class `Arr_non_caching_segment_traits_2`
exhibits slightly better performance than the default one
(`Arr_segment_traits_2` even when the segments intersect each other,
due to the small overhead of the latter (optimized) traits class. (For
example, when the so called <span class="textsc">Leda</span> rational
kernel is used).

<LI>Prior knowledge of the combinatorial structure of the arrangement
can be used to accelerate operations that insert \f$x\f$-monotone
curves, whose interior is disjoint from existing edges and vertices of
the arrangement. The specialized insertion functions, i.e.,
`insert_in_face_interior()`, `insert_from_left_vertex()`,
`insert_from_right_vertex()`, and `insert_at_vertices()` can be used
according to the available information. These functions hardly involve
any geometric operations, if at all. They accept topologically related
parameters, and use them to operate directly on the \sc{Dcel} records,
thus saving algebraic operations, which are especially expensive when
high-degree curves are involved.

A polygon, represented by a list of segments along its boundary, can
be inserted into an empty arrangement as follows. First, one segment
is inserted using `insert_in_face_interior()` into the unbounded
face. Then, a segment with a common end point is inserted using either
`insert_from_left_vertex()` or `insert_from_right_vertex()`, and so on
with the rest of the segments except for the last, which is inserted
using `insert_at_vertices()`, as both endpoints of which are the
mapping of known vertices.

<LI>The main trade-off among point-location strategies, is between
time and storage. Using the naive or walk strategies, for example,
takes more query time but does not require preprocessing or
maintenance of auxiliary structures and saves storage space.

<LI>If point-location queries are not performed frequently, but other
modifying functions, such as removing, splitting, or merging edges
are, then using a point-location strategy that does not require the
maintenance of auxiliary structures, such as the naive or walk
strategies, is preferable.

<LI>There is a trade-off between two modes of the trapezoidal RIC
strategy that enables the user to choose whether preprocessing should
be performed or not. If preprocessing is not used, the creation of the
structure is faster. However, for some input sequences the structure
might be unbalanced and therefore queries and updates might take
longer, especially, if many removal and split operations are
performed.

<LI>When the curves to be inserted into an arrangement are available
in advance (as opposed to supplied on-line), it is advised to use the
more efficient aggregate (sweep-based) insertion over the incremental
insertion; e.g., `insert()`.

<LI>The various traits classes should be instantiated with an exact
number type to ensure robustness, when the input of the operations to
be carried out might be degenerate, although inexact number types
could be used at the user's own risk.

<LI>Maintaining short bit-lengths of coordinate representations may
drastically decrease the time consumption of arithmetic operations on
the coordinates. This can be achieved by caching certain information
or normalization (of rational numbers). However, both solutions should
be used cautiously, as the former may lead to an undue space
consumption, and indiscriminate normalization may considerably slow
down the overall process.

<LI>Geometric functions (e.g., traits methods) dominate the time
consumption of most operations. Thus, calls to such function should be
avoided or at least their number should be decreased, perhaps at the
expense of increased combinatorial-function calls or increased space
consumption. For example, repetition of geometric-function calls could
be avoided by storing the results obtained by the first call, and
reusing them when needed.
</OL>

\section aos_sec-design Design and Implementation History

The code of this package is the result of a long development process.
Initially (and until version 3.1), the code was spread among several
components, namely, `Topological_map`, `Planar_map_2`,
`Planar_map_with_intersections_2` and `Arrangement_2`, that were
developed by Ester Ezra, Eyal Flato, Efi Fogel, Dan Halperin, Iddo
Hanniel, Idit Haran, Shai Hirsch, Eugene Lipovetsky, Oren Nechushtan,
Sigal Raab, Ron Wein, Baruch Zukerman, and Tali Zvi.

In version 3.2, as part of the ACS project, the packages have gone
through a major re-design, resulting in an improved and unified
<em>2D Arrangements</em> package.
The code of the new package was restructured and developed by
Efi Fogel, Idit Haran, Ron Wein, and Baruch Zukerman. This
version included for the first time a new geometry-traits
class that handles circular and linear curves, and is based
on the circular kernel. The circular kernel was developed
by Monique Teillaud, Sylvain Pion, and Julien Hazebrouck.

Version 3.3 features arrangements of unbounded curves for the first
time. The design and development of this feature required yet another
restructuring of the entire package. All this was done by Eric
Berberich, Efi Fogel, Dan Halperin, Ophir Setter, and Ron
Wein. Michael Hemmer helped tuning up parts of the geometry-traits
concept related to unbounded curves.

Version 3.7 introduced a geometry-traits class
that handles planar algebraic curves of arbitrary degree.
It was developed by Eric Berberich and Michael Kerber.

Version 3.9 introduced a new geometry-traits class that handles
rational arcs. It was developed by Oren Salzman and Michael Hemmer.
It replaced an old traits, which handled the same family of
curves, developed by Ron Wein.

Version 4.1 introduces a revised implementation of the point location class
via a randomized incremental construction of the trapezoidal map.
The old class was implemented by Oren Nechushtan, while the revamp
was done by Michal Kleinbort and Michael Hemmer. The new class adds support
for unbounded curves and can now guarantee logarithmic query time in all
cases.

*/
} /* namespace CGAL */
