#! /bin/bash

# This is a script for the CGAL test suite. Such a script must obey
# the following rules:
#
# - the name of the script is cgal_test
# - for every target two one line messages are written to the file 'error.txt'
#     the first one indicates if the compilation was successful
#     the second one indicates if the execution was successful
#   if one of the two was not successful, the line should start with 'ERROR:'
# - running the script should not require any user interaction
# - the script should clean up object files and executables

# SET PARAMETERS FOR cgal_test


ERRORFILE=error.txt
DO_RUN=y
if [ -z "${MAKE_CMD}" ]; then
    MAKE_CMD=make
fi


FULL_ERROR_DESCRIPTION_FILE=ProgramOutput.error.txt

#---------------------------------------------------------------------#
#                    compile_and_run <target>
#---------------------------------------------------------------------#

# note that these values shloud match to the values in test_configuration.h file

CARTESIAN_KERNEL=0
SIMPLE_CARTESIAN_KERNEL=1
UNIVARIATE_ALGEBRAIC_KERNEL=2

SEGMENT_GEOM_TRAITS=0
NON_CACHING_SEGMENT_GEOM_TRAITS=1
POLYLINE_GEOM_TRAITS=2
NON_CACHING_POLYLINE_GEOM_TRAITS=3
POLYCURVE_CONIC_GEOM_TRAITS=14
POLYCURVE_CIRCULAR_ARC_GEOM_TRAITS=15
POLYCURVE_BEZIER_GEOM_TRAITS=16
LINEAR_GEOM_TRAITS=4
CORE_CONIC_GEOM_TRAITS=5
LINE_ARC_GEOM_TRAITS=6
CIRCULAR_ARC_GEOM_TRAITS=7
CIRCULAR_LINE_ARC_GEOM_TRAITS=8
CIRCLE_SEGMENT_GEOM_TRAITS=9
BEZIER_GEOM_TRAITS=10
GEODESIC_ARC_ON_SPHERE_GEOM_TRAITS=11
RATIONAL_ARC_GEOM_TRAITS=12
ALGEBRAIC_GEOM_TRAITS=13
POLYCURVE_CONIC_GEOM_TRAITS=14
POLYCURVE_CIRCULAR_ARC_GEOM_TRAITS=15
POLYCURVE_BEZIER_GEOM_TRAITS=16
FLAT_TORUS_GEOM_TRAITS=17

PLANAR_BOUNDED_TOPOL_TRAITS=0
PLANAR_UNBOUNDED_TOPOL_TRAITS=1
SPHERICAL_TOPOL_TRAITS=2

DOUBLE_NT=0
MP_FLOAT_NT=1
GMPZ_NT=2
LEDA_RAT_NT=3
QUOTIENT_MP_FLOAT_NT=4
QUOTIENT_CGAL_GMPZ_NT=5
CGAL_GMPQ_NT=6
LAZY_LEDA_RAT_NT=7
LAZY_CGAL_GMPQ_NT=8
LAZY_QUOTIENT_MP_FLOAT_NT=9
LEDA_REAL_NT=10
CORE_EXPR_NT=11
LAZY_GMPZ_NT=12
LEDA_INT_NT=13
CGAL_GMPZ_NT=14
CORE_INT_NT=15
CORE_RAT_NT=16

if [ -n "${CGAL_DISABLE_GMP}" ]; then
    echo GMP is disable. Try to use LEDA instead.
    GMPZ_NT=$LEDA_INT_NT
    QUOTIENT_CGAL_GMPZ_NT=$LEDA_RAT_NT
    CGAL_GMPQ_NT=$LEDA_RAT_NT
    LAZY_CGAL_GMPQ_NT=$LAZY_LEDA_RAT_NT
    LAZY_GMPZ_NT=$LAZY_LEDA_RAT_NT
    CGAL_GMPZ_NT=$LEDA_INT_NT
fi

COMPARE=1
VERTEX=2
IS_VERTICAL=3
COMPARE_Y_AT_X=4
COMPARE_Y_AT_X_LEFT=5
COMPARE_Y_AT_X_RIGHT=6
MAKE_X_MONOTONE=7
INTERSECT=8
SPLIT=9
ARE_MERGEABLE=10
MERGE=11
ASSERTIONS=12
CONSTRUCTOR=13
COMPARE_X_AT_LIMIT=14
COMPARE_X_NEAR_LIMIT=15
COMPARE_X_ON_BOUNDARY=16
COMPARE_X_NEAR_BOUNDARY=17
COMPARE_Y_NEAR_BOUNDARY=18
PARAMETER_SPACE_X=19
PARAMETER_SPACE_Y=20
X_ON_IDENTIFICATION=21
Y_ON_IDENTIFICATION=22
IS_BOUNDED=23
IS_IN_X_RANGE=24
COMPARE_Y_POSITION=25
IS_BETWEEN_CW=26
COMPARE_CW_AROUND_POINT=27
PUSH_BACK=28
PUSH_FRONT=29
NUMBER_OF_POINTS=32
COMPARE_ENDPOINTS_XY=33
CONSTRUCT_OPPOSITE=34
TRIM=35

#---------------------------------------------------------------------#
#                    configure
#---------------------------------------------------------------------#

configure()
{
  echo "Configuring... "
  rm -rf CMakeCache.txt CMakeFiles/
  echo "cmake --no-warn-unused-cli "$CMAKE_GENERATOR" -DRUNNING_CGAL_AUTO_TEST=TRUE  \
 -DCGAL_DIR=\"$CGAL_DIR\" \
 -DCGAL_CXX_FLAGS:STRING=\"$TESTSUITE_CXXFLAGS -I../../include\" \
 -DCGAL_EXE_LINKER_FLAGS=\"$TESTSUITE_LDFLAGS\" \
 -DCMAKE_BUILD_TYPE=NOTFOUND \
 ."
  if eval 'cmake --no-warn-unused-cli "$CMAKE_GENERATOR" -DRUNNING_CGAL_AUTO_TEST=TRUE  \
                                    -DCGAL_DIR="$CGAL_DIR" \
                                    -DCGAL_CXX_FLAGS:STRING="$TESTSUITE_CXXFLAGS -I../../include" \
                                    -DCGAL_EXE_LINKER_FLAGS="$TESTSUITE_LDFLAGS" \
                                    -DCMAKE_BUILD_TYPE=NOTFOUND \
                                    .' ; then

    echo "   successful configuration" >> $ERRORFILE
  else
    echo "   ERROR:    configuration" >> $ERRORFILE
  fi
}

compile_test_with_flags()
{
  local name=$1;
  local type=$2;
  local flags=$3;

  echo "Compiling $name $type ... "
  if [ "${TEST_WITH_CMAKE}" != "FALSE" ]; then
    export TESTSUITE_CXXFLAGS="$flags"
    configure
    if eval '${MAKE_CMD} VERBOSE=1 -fMakefile  \
      $name' ; then
      echo "   successful compilation of $name $type" >> $ERRORFILE;
      SUCCESS="y"
    else
      echo "   ERROR:    compilation of $name $type" >> $ERRORFILE;
      SUCCESS=""
    fi
  else
    if eval 'make CGAL_MAKEFILE=$CGAL_MAKEFILE \
      TESTSUITE_CXXFLAGS="$TESTSUITE_CXXFLAGS" \
      TESTSUITE_LDFLAGS="$TESTSUITE_LDFLAGS" $name'; then
      echo "   successful compilation of $name $type" >> $ERRORFILE;
      SUCCESS="y"
    else
      echo "   ERROR:    compilation of $name $type" >> $ERRORFILE;
      SUCCESS=""
    fi
  fi
}

run_test()
{
  # $1 - executable name

  basedata=`basename "$5"`
  OUTPUTFILE="ProgramOutput.$1"
  rm -f $OUTPUTFILE
  COMMAND="./$1"
  if [ -f $1.cmd ] ; then
    COMMAND="$COMMAND `cat $1.cmd`"
  fi
  if [ -f $1.cin ] ; then
    COMMAND="cat $1.cin | $COMMAND"
  fi
  OUTPUTFILE="$OUTPUTFILE.$PLATFORM"
  echo "Executing $1 ($2) ... "
  ulimit -t 3600 2> /dev/null
  if eval $COMMAND > $OUTPUTFILE 2>&1 ; then
    echo "   successful execution of $1" >> $ERRORFILE
  else
    echo "   ERROR:    execution of $1" >> $ERRORFILE
    cat $OUTPUTFILE >> $FULL_ERROR_DESCRIPTION_FILE
  fi
}

run_test_with_flags()
{
  # $1 - executable name
  # $2 - test substring name

  basedata=`basename "$5"`
  OUTPUTFILE="ProgramOutput.$1"
  rm -f $OUTPUTFILE
  COMMAND="./$1"
  if [ -f $1.cmd ] ; then
    COMMAND="$COMMAND `cat $1.cmd`"
  elif [ -f $1.$2.cmd ] ; then
    COMMAND="$COMMAND `cat $1.$2.cmd`"
    OUTPUTFILE=$OUTPUTFILE.`echo $2 | tr '/' '.'`
  fi
  if [ -f $1.cin ] ; then
    COMMAND="cat $1.cin | $COMMAND"
  elif [ -f $1.$2.cin ] ; then
    COMMAND="cat $1.$2.cin | $COMMAND"
    OUTPUTFILE=$OUTPUTFILE.`echo $2 | tr '/' '.'`
  fi
  OUTPUTFILE="$OUTPUTFILE.$PLATFORM"
  echo "Executing $1 ($2) ... "
  ulimit -t 3600 2> /dev/null
  if eval $COMMAND > $OUTPUTFILE 2>&1 ; then
    echo "   successful execution of $1 ($2)" >> $ERRORFILE
  else
    echo "   ERROR:    execution of $1 ($2)" >> $ERRORFILE
    cat $OUTPUTFILE >> $FULL_ERROR_DESCRIPTION_FILE
  fi
}

run_test_alt()
{
  basedata=`basename "$5"`
  OUTPUTFILE=ProgramOutput.$1.`echo $5 | tr '/' '.'`.$6
  #echo ****generating file $OUTPUTFILE
  #  dirdata=`dirname "$datafile"`
  rm -f $OUTPUTFILE
  COMMAND="./$1"
  echo "Executing $1 $5 $6 ... "
  if eval $COMMAND $2 $3 $4 $5 $6 > $OUTPUTFILE 2>&1 ; then
    echo "   successful execution of $5 $6" >> $ERRORFILE
  else
    echo "   ERROR:    execution of $5 $6" >> $ERRORFILE
    cat $OUTPUTFILE >> $FULL_ERROR_DESCRIPTION_FILE
  fi
}

run_trapped_test()
{
  #local name=$1;
  #local datafile=$2;

  if [ "${OSTYPE}" != "cygwin" ]; then
    ulimit -t 1200
    run_test_alt $1 $2 $3 $4 $5 $6
  else
    run_test_alt $1 $2 $3 $4 $5 $6 &
    WPID=$!
    trap "kill -9 $WPID" INT
    (sleep 1200; kill -9 $WPID) > /dev/null 2>&1 &
    SPID=$!
    wait $WPID > /dev/null 2>&1
    # RES=$?
    kill -9 $SPID > /dev/null 2>&1
    # return $RES
  fi
}

clean_tests()
{
  if [ "${TEST_WITH_CMAKE}" != "FALSE" ]; then
  #
  # The clean target generated by CMake under cygwin
  # always fails for some reason
  #
    if ! ( uname | grep -q "CYGWIN" ) ; then
      make -fMakefile clean
    fi
  fi
  eval "make clean > /dev/null 2>&1"
}

compile_and_run()
{
  local name=$1;

  echo "Compiling $name ... "
  if [ "${TEST_WITH_CMAKE}" != "FALSE" ]; then
    if eval '${MAKE_CMD} VERBOSE=1 -fMakefile $1' ; then
      echo "   successful compilation of $1" >> $ERRORFILE
      SUCCESS="y"
    else
      echo "   ERROR:    compilation of $1" >> $ERRORFILE
      SUCCESS=""
    fi
  else
    SUCCESS="y"
    #TESTSUITE_CXXFLAGS="$TESTSUITE_CXXFLAGS"
    TESTSUITE_CXXFLAGS=""
    TESTSUITE_LDFLAGS="$TESTSUITE_LDFLAGS"
    if eval 'make CGAL_MAKEFILE=$CGAL_MAKEFILE \
      TESTSUITE_CXXFLAGS="$TESTSUITE_CXXFLAGS" \
      TESTSUITE_LDFLAGS="$TESTSUITE_LDFLAGS" $name' ; then
      echo "   successful compilation of $name" >> $ERRORFILE
    else
      echo "   ERROR:    compilation of $name" >> $ERRORFILE
      SUCCESS=""
    fi
  fi

  if [ "${TEST_WITH_CMAKE}" != "FALSE" ]; then
    if [ -n "$DO_RUN" ] ; then
      if [ -n "${SUCCESS}" ] ; then
        run_test $1
      else
         echo "   ERROR:    not executed   $1" >> $ERRORFILE
      fi
    fi
  else
    if [ -n "${SUCCESS}" ] ; then
      OUTPUTFILE=ProgramOutput.$name.$PLATFORM
      rm -f $OUTPUTFILE
      COMMAND="./$name"
      if [ -f $name.cmd ] ; then
        COMMAND="$COMMAND `cat $name.cmd`"
      fi
      if [ -f $name.cin ] ; then
        COMMAND="cat $name.cin | $COMMAND"
      fi
      echo "Executing $name ... "
      echo " "
      if eval $COMMAND > $OUTPUTFILE 2>&1 ; then
        echo "   successful execution of $name" >> $ERRORFILE
      else
        echo "   ERROR:    execution of $name" >> $ERRORFILE
        cat $OUTPUTFILE >> $FULL_ERROR_DESCRIPTION_FILE
      fi
    else
      echo "   ERROR:    not executed $name" >> $ERRORFILE
    fi
  fi
  clean_tests
}

compile_and_run_trapped_test()
{
  local name=$1;

  if [ "${OSTYPE}" != "cygwin" ]; then
    ulimit -t 1200
    compile_and_run $1
  else
    compile_and_run $1 &
    WPID=$!
    trap "kill -9 $WPID" INT
    (sleep 1200; kill -9 $WPID) > /dev/null 2>&1 &
    SPID=$!
    wait $WPID > /dev/null 2>&1
    # RES=$?
    kill -9 $SPID > /dev/null 2>&1
    # return $RES
  fi
}

execute_commands_old_structure()
{

# at first the tests where designed in such way that all the test input was
# in one file, the points, the xcurves, the curves and the execution block
# this function is used to execute the old tests, one may use it when needed
# but you should remember that separating the input into smaller files creates
# much more modular and comfortable test suite

# the old structure is default, so this function executes all commands
# except the commands that are given as arguments


    commands_indicator[COMPARE]=1
    commands_indicator[VERTEX]=1
    commands_indicator[IS_VERTICAL]=1
    commands_indicator[COMPARE_Y_AT_X]=1
    commands_indicator[COMPARE_Y_AT_X_LEFT]=1
    commands_indicator[COMPARE_Y_AT_X_RIGHT]=1
    commands_indicator[MAKE_X_MONOTONE]=1
    commands_indicator[INTERSECT]=1
    commands_indicator[SPLIT]=1
    commands_indicator[ARE_MERGEABLE]=1
    commands_indicator[MERGE]=1
    commands_indicator[ASSERTIONS]=1
    commands_indicator[CONSTRUCTOR]=1
    i=1
    if [ $# -gt 2 ] ; then
	for arg in $* ; do
	    if [ $i -gt 2 ] ; then
		commands_indicator[$arg]=0
	    fi
	    let "i+=1"
	done
    fi
    if [ ${commands_indicator[$COMPARE]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/compare.pt data/empty.zero \
	    data/empty.zero data/compare $2
    fi
    if [ ${commands_indicator[$VERTEX]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/vertex.pt data/$1/vertex.xcv \
	    data/empty.zero data/$1/vertex $2
    fi
    if [ ${commands_indicator[$IS_VERTICAL]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/empty.zero data/$1/is_vertical.xcv data/empty.zero \
	    data/$1/is_vertical $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/compare_y_at_x.pt data/$1/compare_y_at_x.xcv \
	    data/empty.zero data/$1/compare_y_at_x $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X_LEFT]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/compare_y_at_x_left.pt data/$1/compare_y_at_x_left.xcv \
	    data/empty.zero data/$1/compare_y_at_x_left $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X_RIGHT]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/compare_y_at_x_right.pt data/$1/compare_y_at_x_right.xcv \
	    data/empty.zero data/$1/compare_y_at_x_right $2
    fi
    if [ ${commands_indicator[$MAKE_X_MONOTONE]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/empty.zero data/$1/make_x_monotone.xcv \
	    data/$1/make_x_monotone.cv data/$1/make_x_monotone $2
    fi
    if [ ${commands_indicator[$INTERSECT]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/intersect.pt data/$1/intersect.xcv \
	    data/empty.zero data/$1/intersect $2
    fi
    if [ ${commands_indicator[$SPLIT]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/split.pt data/$1/split.xcv \
	    data/empty.zero data/$1/split $2
    fi
    if [ ${commands_indicator[$ARE_MERGEABLE]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/empty.zero data/$1/are_mergeable.xcv \
	    data/empty.zero data/$1/are_mergeable $2
    fi
    if [ ${commands_indicator[$MERGE]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/empty.zero data/$1/merge.xcv \
	    data/empty.zero data/$1/merge $2
    fi
    if [ ${commands_indicator[$ASSERTIONS]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/$1/assertions.pt data/$1/assertions.xcv \
	    data/empty.zero data/$1/assertions $2
    fi
    if [ ${commands_indicator[$CONSTRUCTOR]} -ne 0 ] ; then
	run_trapped_test test_traits \
	    data/empty.zero data/$1/constructor.xcv \
	    data/$1/constructor.cv data/$1/constructor $2
    fi
}

execute_commands_new_structure()
{

# the new design for the tests includes separation of the test input into 4
# parts: points file, xcurves file, curves file and execution block file.
# one may reuse the input files for the various tests

# the new structure is not default, so this function executes only
# commands that are given as arguments

    commands_indicator[COMPARE]=0
    commands_indicator[VERTEX]=0
    commands_indicator[IS_VERTICAL]=0
    commands_indicator[COMPARE_X_ON_BOUNDARY]=0
    commands_indicator[COMPARE_X_NEAR_BOUNDARY]=0
    commands_indicator[COMPARE_Y_NEAR_BOUNDARY]=0
    commands_indicator[PARAMETER_SPACE_X]=0
    commands_indicator[PARAMETER_SPACE_Y]=0
    commands_indicator[COMPARE_Y_AT_X]=0
    commands_indicator[COMPARE_Y_AT_X_LEFT]=0
    commands_indicator[COMPARE_Y_AT_X_RIGHT]=0
    commands_indicator[MAKE_X_MONOTONE]=0
    commands_indicator[INTERSECT]=0
    commands_indicator[SPLIT]=0
    commands_indicator[ARE_MERGEABLE]=0
    commands_indicator[MERGE]=0
    commands_indicator[ASSERTIONS]=0
    commands_indicator[CONSTRUCTOR]=0
    commands_indicator[EQUAL]=0
    commands_indicator[PUSH_BACK]=0
    commands_indicator[PUSH_FRONT]=0
    commands_indicator[NUMBER_OF_POINTS]=0
    commands_indicator[COMPARE_ENDPOINTS_XY]=0
    commands_indicator[CONSTRUCT_OPPOSITE]=0
    commands_indicator[TRIM]=0
    i=1
    if [ $# -gt 2 ] ; then
	for arg in $* ; do
	    if [ $i -gt 2 ] ; then
		commands_indicator[$arg]=1
	    fi
	    let "i+=1"
	done
    fi
    if [ ${commands_indicator[$COMPARE]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare $2
    fi
    if [ ${commands_indicator[$VERTEX]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/vertex $2
    fi
    if [ ${commands_indicator[$IS_VERTICAL]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/is_vertical $2
    fi
    if [ ${commands_indicator[$COMPARE_X_ON_BOUNDARY]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_x_on_boundary $2
    fi
    if [ ${commands_indicator[$COMPARE_X_NEAR_BOUNDARY]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_x_near_boundary $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_NEAR_BOUNDARY]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_y_near_boundary $2
    fi
    if [ ${commands_indicator[$PARAMETER_SPACE_X]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/parameter_space_x $2
    fi
    if [ ${commands_indicator[$PARAMETER_SPACE_Y]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/parameter_space_y $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_y_at_x $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X_LEFT]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_y_at_x_left $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X_RIGHT]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_y_at_x_right $2
    fi
    if [ ${commands_indicator[$MAKE_X_MONOTONE]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/make_x_monotone $2
    fi
    if [ ${commands_indicator[$INTERSECT]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/intersect $2
    fi
    if [ ${commands_indicator[$SPLIT]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/split $2
    fi
    if [ ${commands_indicator[$ARE_MERGEABLE]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/are_mergeable $2
    fi
    if [ ${commands_indicator[$MERGE]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/merge $2
    fi
    if [ ${commands_indicator[$ASSERTIONS]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/assertions $2
    fi
    if [ ${commands_indicator[$CONSTRUCTOR]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/constructor $2
    fi
    if [ ${commands_indicator[$EQUAL]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/equal $2
    fi
    if [ ${commands_indicator[$PUSH_BACK]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/push_back $2
    fi
    if [ ${commands_indicator[$PUSH_FRONT]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/push_front $2
    fi
    if [ ${commands_indicator[$NUMBER_OF_POINTS]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/number_of_points $2
    fi
    if [ ${commands_indicator[$COMPARE_ENDPOINTS_XY]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/compare_endpoints_xy $2
    fi
    if [ ${commands_indicator[$CONSTRUCT_OPPOSITE]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/construct_opposite $2
    fi
    if [ ${commands_indicator[$TRIM]} -ne 0 ] ; then
	run_trapped_test test_traits data/$1/points \
	    data/$1/xcurves data/$1/curves data/$1/trim $2
    fi
}

execute_commands_traits_adaptor()
{

# the new structure is not default, so this function executes only
# commands that are given as arguments

    commands_indicator[PARAMETER_SPACE_X]=0
    commands_indicator[PARAMETER_SPACE_Y]=0
    commands_indicator[COMPARE_X_ON_BOUNDARY]=0
    commands_indicator[COMPARE_X_NEAR_BOUNDARY]=0
    commands_indicator[COMPARE_Y_NEAR_BOUNDARY]=0
    commands_indicator[COMPARE_Y_AT_X_LEFT]=0
    commands_indicator[ARE_MERGEABLE]=0
    commands_indicator[MERGE]=0
    commands_indicator[X_ON_IDENTIFICATION]=0
    commands_indicator[Y_ON_IDENTIFICATION]=0
    commands_indicator[IS_BOUNDED]=0
    commands_indicator[IS_IN_X_RANGE]=0
    commands_indicator[COMPARE_Y_POSITION]=0
    commands_indicator[IS_BETWEEN_CW]=0
    commands_indicator[COMPARE_CW_AROUND_POINT]=0

    i=1
    if [ $# -gt 2 ] ; then
	for arg in $* ; do
	    if [ $i -gt 2 ] ; then
		commands_indicator[$arg]=1
	    fi
	    let "i+=1"
	done
    fi

    if [ ${commands_indicator[$PARAMETER_SPACE_X]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/parameter_space_x $2
    fi
    if [ ${commands_indicator[$PARAMETER_SPACE_Y]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/parameter_space_y $2
    fi
    if [ ${commands_indicator[$COMPARE_X_ON_BOUNDARY]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/compare_x_on_boundary $2
    fi
    if [ ${commands_indicator[$COMPARE_X_NEAR_BOUNDARY]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/compare_x_near_boundary $2
    fi

    if [ ${commands_indicator[$COMPARE_Y_NEAR_BOUNDARY]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/compare_y_near_boundary $2
    fi
    if [ ${commands_indicator[$COMPARE_Y_AT_X_LEFT]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/compare_y_at_x_left $2
    fi
    if [ ${commands_indicator[$ARE_MERGEABLE]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/are_mergeable $2
    fi
    if [ ${commands_indicator[$MERGE]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/merge $2
    fi
    if [ ${commands_indicator[X_ON_IDENTIFICATION]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/x_on_idintification $2
    fi
    if [ ${commands_indicator[Y_ON_IDENTIFICATION]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/x_on_idintification $2
    fi
    if [ ${commands_indicator[IS_BOUNDED]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/is_bounded $2
    fi
    if [ ${commands_indicator[IS_IN_X_RANGE]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/is_in_x_range $2
    fi
    if [ ${commands_indicator[COMPARE_Y_POSITION]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/compare_y_position $2
    fi
    if [ ${commands_indicator[IS_BETWEEN_CW]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/is_between_cw $2
    fi
    if [ ${commands_indicator[COMPARE_CW_AROUND_POINT]} -ne 0 ] ; then
	run_trapped_test test_traits_adaptor data/test_adaptor/$1/points \
	    data/test_adaptor/$1/xcurves data/test_adaptor/$1/curves \
	    data/test_adaptor/$1/compare_cw_around_point $2
    fi
}

#---------------------------------------------------------------------#
# traits adaptor (segments traits)
#---------------------------------------------------------------------#
test_segment_traits_adaptor()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits_adaptor segments "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_traits_adaptor segments segments_traits_adaptor \
      COMPARE_Y_POSITION COMPARE_CW_AROUND_POINT COMPARE_Y_AT_X_LEFT \
      ARE_MERGEABLE MERGE IS_IN_X_RANGE IS_BETWEEN_CW
  else
    echo "   ERROR:    not executed test_traits_adaptor segment_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# traits adaptor (linear traits)
#---------------------------------------------------------------------#
test_linear_traits_adaptor()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits_adaptor linear "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_traits_adaptor linear linear_traits_adaptor \
      COMPARE_Y_AT_X_LEFT ARE_MERGEABLE MERGE IS_IN_X_RANGE \
      COMPARE_Y_POSITION IS_BETWEEN_CW COMPARE_CW_AROUND_POINT
  else
    echo "   ERROR:    not executed test_traits_adaptor linear_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# traits adaptor (spherical arcs traits)
#---------------------------------------------------------------------#
test_spherical_arcs_traits_adaptor()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$GEODESIC_ARC_ON_SPHERE_GEOM_TRAITS;
  local topol_traits=$SPHERICAL_TOPOL_TRAITS
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";

  compile_test_with_flags test_traits_adaptor geodesic_arcs_on_sphere "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_traits_adaptor spherical_arcs spherical_arcs_traits_adaptor \
      COMPARE_Y_AT_X_LEFT ARE_MERGEABLE MERGE IS_IN_X_RANGE \
      COMPARE_Y_POSITION IS_BETWEEN_CW COMPARE_CW_AROUND_POINT
  else
    echo "   ERROR:    not executed test_traits_adaptor spherical_arcs_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# compile and run test with traits
#---------------------------------------------------------------------#
compile_and_run_with_flags()
{
  local name=$1;
  local type=$2;
  local flags=$3;

  compile_test_with_flags $name $type "$flags"
  if [ -n "${SUCCESS}" ] ; then
    if [ -n "$DO_RUN" ] ; then
      run_test_with_flags $name $type
    fi
  else
    echo "   ERROR:    not executed construction of segments" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# construction with segments
#---------------------------------------------------------------------#
test_construction_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_construction segments "$flags"
}

#---------------------------------------------------------------------#
# construction with linear curves
#---------------------------------------------------------------------#
test_construction_linear_curves()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local topol_traits=$PLANAR_UNBOUNDED_TOPOL_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";
  compile_and_run_with_flags test_construction linear "$flags"
}

#---------------------------------------------------------------------#
# construction with geodesic arcs on the sphere
#---------------------------------------------------------------------#
test_construction_spherical_arcs()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$GEODESIC_ARC_ON_SPHERE_GEOM_TRAITS;
  local topol_traits=$SPHERICAL_TOPOL_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";
  compile_and_run_with_flags test_construction geodesic_arcs_on_sphere "$flags"
}

#---------------------------------------------------------------------#
# overlay with segments
#---------------------------------------------------------------------#
test_overlay_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_overlay segments "$flags"
}

#---------------------------------------------------------------------#
# overlay with geodesic arcs on the sphere
#---------------------------------------------------------------------#
test_overlay_spherical_arcs()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$GEODESIC_ARC_ON_SPHERE_GEOM_TRAITS;
  local topol_traits=$SPHERICAL_TOPOL_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";
  compile_and_run_with_flags test_overlay geodesic_arcs_on_sphere "$flags"
}

#---------------------------------------------------------------------#
# point location with segments
#---------------------------------------------------------------------#
test_point_location_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_point_location segments "$flags"
}

# For backward compatibility
test_point_location_segments_version()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DCGAL_ARR_POINT_LOCATION_VERSION=1";
  compile_and_run_with_flags test_point_location segments "$flags"
}

# For backward compatibility
test_point_location_segments_conversion()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DCGAL_ARR_POINT_LOCATION_CONVERSION";
  compile_and_run_with_flags test_point_location segments "$flags"
}

#---------------------------------------------------------------------#
# point location dynamic with segments
#---------------------------------------------------------------------#
test_point_location_dynamic_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_point_location_dynamic segments "$flags"
}

#---------------------------------------------------------------------#
# point location with circle segments
#---------------------------------------------------------------------#
test_point_location_circle_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$CIRCLE_SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_point_location circle_segments "$flags"
}

#---------------------------------------------------------------------#
# point location with linear objects
#---------------------------------------------------------------------#
test_point_location_linear()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_point_location linear "$flags"
}

#---------------------------------------------------------------------#
# batchecd point location with segments
#---------------------------------------------------------------------#
test_batched_point_location_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_batched_point_location segments "$flags"
}

#---------------------------------------------------------------------#
# batchecd point location with linear objects
#---------------------------------------------------------------------#
test_batched_point_location_linear()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_batched_point_location linear "$flags"
}

#---------------------------------------------------------------------#
# batchecd point location with geodesic arcs on the sphere
#---------------------------------------------------------------------#
test_batched_point_location_spherical_arcs()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$GEODESIC_ARC_ON_SPHERE_GEOM_TRAITS;
  local topol_traits=$SPHERICAL_TOPOL_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";
  compile_and_run_with_flags test_batched_point_location geodesic_arcs_on_sphere "$flags"
}

#---------------------------------------------------------------------#
# vertical decomposition with segments
#---------------------------------------------------------------------#
test_vertical_decomposition_segments()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_vertical_decomposition segments "$flags"
}

#---------------------------------------------------------------------#
# vertical decomposition with linear objects
#---------------------------------------------------------------------#
test_vertical_decomposition_linear()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";
  compile_and_run_with_flags test_vertical_decomposition linear "$flags"
}

#---------------------------------------------------------------------#
# vertical decomposition with geodesic arcs on the sphere
#---------------------------------------------------------------------#
test_vertical_decomposition_spherical_arcs()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local topol_traits=$SPHERICAL_TOPOL_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";
  compile_and_run_with_flags test_vertical_decomposition geodesic_arcs_on_sphere "$flags"
}

#---------------------------------------------------------------------#
# segment traits
#---------------------------------------------------------------------#
test_segment_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits segments "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure segments segment_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT CONSTRUCTOR \
      COMPARE_Y_AT_X_RIGHT ARE_MERGEABLE

    execute_commands_new_structure segments segment_traits \
      IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT ARE_MERGEABLE

    run_trapped_test test_traits \
      data/segments/vertex.pt data/segments/xcurves \
      data/empty.zero data/segments/vertex segment_traits
  else
    echo "   ERROR:    not executed   test_traits segment_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# non-caching segment traits
#---------------------------------------------------------------------#
test_non_caching_segment_traits()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$NON_CACHING_SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits non_caching_segments "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure segments non_caching_segment_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT CONSTRUCTOR \
      COMPARE_Y_AT_X_RIGHT ARE_MERGEABLE ASSERTIONS

    execute_commands_new_structure segments segment_traits \
      IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT

    run_trapped_test test_traits \
      data/segments/vertex.pt data/segments/xcurves \
      data/empty.zero data/segments/vertex non_caching_segment_traits
  else
    echo "   ERROR:    not executed   test_traits non_caching_segment_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# polycurve conic traits
#---------------------------------------------------------------------#
test_polycurve_conic_traits()
{
  echo polycurve test starting
  local nt=$CORE_EXPR_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$POLYCURVE_CONIC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits conic_polycurve "$flags"
  if [ -n "${SUCCESS}" ] ; then

    # The input arguments for the execute_commands_new_structure,
    # 1. Polycurve_conics is the directory name in "data"
    # 2. polycurve_conic_traits is a string
    # Execute_command_new_structure will only run the test on functors provided as the third, fourth and so on arguments.
    # To see how the input data directory should be structured for each functor, check the execute_commands_new_structure function in this file.
    execute_commands_new_structure polycurves_conics polycurve_conic_traits \
      COMPARE_Y_AT_X \
      INTERSECT \
      EQUAL \
      IS_VERTICAL \
      SPLIT \
      ARE_MERGEABLE \
      COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT \
      MAKE_X_MONOTONE \
      PUSH_BACK \
      PUSH_FRONT \
      NUMBER_OF_POINTS \
      VERTEX \
      CONSTRUCT_OPPOSITE \
      MERGE \
      COMPARE_ENDPOINTS_XY \
      TRIM

  else
    echo "   ERROR:    not executed   test_traits polyline_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# polycurve arc traits
#---------------------------------------------------------------------#
test_polycurve_circular_arc_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$POLYCURVE_CIRCULAR_ARC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits circular_arc_polycurve "$flags"
  if [ -n "${SUCCESS}" ] ; then
   execute_commands_new_structure Polycurves_circular_arcs polycurve_circular_arc_traits \
    COMPARE_Y_AT_X \
    EQUAL \
    IS_VERTICAL \
    SPLIT \
    ARE_MERGEABLE \
    COMPARE_Y_AT_X_LEFT \
    COMPARE_Y_AT_X_RIGHT \
    MAKE_X_MONOTONE \
    PUSH_BACK \
    PUSH_FRONT \
    NUMBER_OF_POINTS \
    VERTEX \
    CONSTRUCT_OPPOSITE \
    MERGE \
    COMPARE_ENDPOINTS_XY \
    INTERSECT

  else
   echo "   ERROR:    not executed   test_traits polyline_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# polycurve bezier traits
#---------------------------------------------------------------------#
test_polycurve_bezier_traits()
{
  local nt=$CORE_EXPR_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$POLYCURVE_BEZIER_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits bezier_polycurve "$flags"
  if [ -n "${SUCCESS}" ] ; then
   execute_commands_new_structure Polycurves_bezier test_polycurve_bezier_traits \
    MERGE \
    EQUAL \
    IS_VERTICAL \
    NUMBER_OF_POINTS \
    PUSH_BACK \
    PUSH_FRONT \
    VERTEX \
    ARE_MERGEABLE \
    COMPARE_ENDPOINTS_XY
    # TODO (add data for these tests)
    # COMPARE_Y_AT_X \
    # SPLIT \
    # COMPARE_Y_AT_X_LEFT \
    # COMPARE_Y_AT_X_RIGHT \
    # MAKE_X_MONOTONE \
    # CONSTRUCT_OPPOSITE \

    # INTERSECT

  else
   echo "   ERROR:    not executed   test_traits polyline_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# polyline traits
#---------------------------------------------------------------------#
test_polyline_traits()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$POLYLINE_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits test_polylines "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure polylines polyline_traits \
      CONSTRUCTOR COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT ARE_MERGEABLE
  else
    echo "   ERROR:    not executed   test_traits polyline_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# non-caching polyline traits
#---------------------------------------------------------------------#
test_non_caching_polyline_traits()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$NON_CACHING_POLYLINE_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits non_caching_polylines "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure polylines non_caching_polyline_traits \
      CONSTRUCTOR COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT ARE_MERGEABLE
  else
    echo "   ERROR:    not executed   test_traits non_caching_polyline_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# linear traits
#---------------------------------------------------------------------#
test_linear_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINEAR_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits linear "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure linear/segments linear_traits.segments \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT CONSTRUCTOR ARE_MERGEABLE

    execute_commands_new_structure linear/segments linear_traits.segments \
      IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT

    run_trapped_test test_traits \
      data/linear/segments/vertex.pt data/linear/segments/xcurves \
      data/empty.zero data/linear/segments/vertex linear_traits.segments

    execute_commands_old_structure linear/rays linear_traits.rays \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT CONSTRUCTOR ARE_MERGEABLE

    execute_commands_new_structure linear/rays linear_traits.rays \
      IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT

    run_trapped_test test_traits \
      data/linear/rays/vertex.pt data/linear/rays/xcurves \
      data/empty.zero data/linear/rays/vertex linear_traits.rays

    execute_commands_new_structure linear/lines linear_traits.lines \
      IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT INTERSECT \
      SPLIT MERGE \
      PARAMETER_SPACE_X PARAMETER_SPACE_Y \
      COMPARE_X_ON_BOUNDARY COMPARE_X_NEAR_BOUNDARY COMPARE_Y_NEAR_BOUNDARY
  else
    echo "   ERROR:    not executed   test_traits linear_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# conic traits
#---------------------------------------------------------------------#
test_conic_traits()
{
  local nt=$CORE_EXPR_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$CORE_CONIC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits conics "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure conics conic_traits \
      INTERSECT SPLIT MERGE COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT ARE_MERGEABLE

    execute_commands_new_structure conics conic_traits \
      INTERSECT SPLIT MERGE

    run_trapped_test test_traits \
      data/conics/compare.pt data/empty.zero \
      data/empty.zero data/conics/compare conic_traits
  else
    echo "   ERROR:    not executed   test_traits conic_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# "line arcs" (segments) only
#---------------------------------------------------------------------#
test_line_arc_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$LINE_ARC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits line_arcs "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure circular_lines line_arc_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT \
      ASSERTIONS COMPARE_Y_AT_X_RIGHT MERGE ARE_MERGEABLE

    execute_commands_new_structure circular_lines line_arc_traits \
      IS_VERTICAL COMPARE_Y_AT_X

    run_trapped_test test_traits \
      data/circular_lines/compare.pt data/empty.zero \
      data/empty.zero data/circular_lines/compare line_arc_traits

    run_trapped_test test_traits \
      data/circular_lines/vertex.pt data/circular_lines/xcurves \
      data/empty.zero data/circular_lines/vertex line_arc_traits
  else
    echo   "   ERROR:    not executed   test_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# circular arcs only
#---------------------------------------------------------------------#
test_circular_arc_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$CIRCULAR_ARC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits circular_arcs "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure circular_arcs circular_arc_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT \
      ASSERTIONS COMPARE_Y_AT_X_RIGHT MERGE ARE_MERGEABLE

    execute_commands_new_structure circular_arcs circular_arc_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X
  else
    echo   "   ERROR:    not executed   test_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# circular and line arcs
#---------------------------------------------------------------------#
test_circular_line_arc_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$CIRCULAR_LINE_ARC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits circular_line_arcs "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure circular_line_arcs circular_line_arc_traits \
      VERTEX IS_VERTICAL CONSTRUCTOR COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT \
      ASSERTIONS COMPARE_Y_AT_X_RIGHT MERGE ARE_MERGEABLE

    execute_commands_new_structure circular_line_arcs circular_line_arc_traits \
      IS_VERTICAL COMPARE_Y_AT_X

    run_trapped_test test_traits \
      data/circular_line_arcs/vertex.pt data/circular_line_arcs/xcurves \
      data/empty.zero data/circular_line_arcs/vertex circular_line_arc_traits
  else
    echo "   ERROR:    not executed   test_traits circular_line_arc_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# circle segment traits
#---------------------------------------------------------------------#
test_circle_segments_traits()
{
  local nt=$QUOTIENT_MP_FLOAT_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$CIRCLE_SEGMENT_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits circle_segments "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure circle_segments circle_segments_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT \
      COMPARE_Y_AT_X_RIGHT CONSTRUCTOR ARE_MERGEABLE

    run_trapped_test test_traits \
      data/circle_segments/points data/circle_segments/xcurves.8 \
      data/empty.zero data/circle_segments/vertex circle_segments_traits
    run_trapped_test test_traits \
      data/empty.zero data/circle_segments/xcurves.8 \
      data/empty.zero data/circle_segments/is_vertical circle_segments_traits
    run_trapped_test test_traits \
      data/circle_segments/points data/circle_segments/xcurves.8 \
      data/empty.zero data/circle_segments/compare_y_at_x circle_segments_traits
    run_trapped_test test_traits \
      data/circle_segments/points data/circle_segments/xcurves.16 \
      data/empty.zero data/circle_segments/compare_y_at_x_left circle_segments_traits
    run_trapped_test test_traits \
      data/circle_segments/points data/circle_segments/xcurves.16 \
      data/empty.zero data/circle_segments/compare_y_at_x_right circle_segments_traits
    run_trapped_test test_traits \
      data/empty.zero data/circle_segments/constructor.xcv \
      data/empty.zero data/circle_segments/constructor circle_segments_traits
  else
    echo "   ERROR:    not executed   test_traits circle_segments_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# bezier traits
#---------------------------------------------------------------------#
test_bezier_traits()
{
  local nt=$CORE_EXPR_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$BEZIER_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits Bezier "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure bezier bezier_traits \
      COMPARE_Y_AT_X_LEFT COMPARE_Y_AT_X_RIGHT SPLIT \
      CONSTRUCTOR ASSERTIONS ARE_MERGEABLE
  else
    echo   "   ERROR:    not executed   test_traits bezier_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# spherical arc traits
#---------------------------------------------------------------------#
test_spherical_arc_traits()
{
  local nt=$CGAL_GMPQ_NT;
  local kernel=$CARTESIAN_KERNEL;
  local geom_traits=$GEODESIC_ARC_ON_SPHERE_GEOM_TRAITS;
  local topol_traits=$SPHERICAL_TOPOL_TRAITS
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits -DTEST_TOPOL_TRAITS=$topol_traits";

  compile_test_with_flags test_traits geodesic_arcs_on_sphere "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_old_structure spherical_arcs spherical_arc_traits \
      COMPARE_Y_AT_X_LEFT COMPARE_Y_AT_X_RIGHT INTERSECT \
      CONSTRUCTOR \
      COMPARE MAKE_X_MONOTONE SPLIT MERGE ASSERTIONS ARE_MERGEABLE

    execute_commands_new_structure spherical_arcs spherical_arc_traits \
      INTERSECT \
      COMPARE_X_ON_BOUNDARY COMPARE_X_NEAR_BOUNDARY \
      COMPARE_Y_NEAR_BOUNDARY

    run_trapped_test test_traits \
      data/spherical_arcs/compare.pt data/spherical_arcs/compare.xcv \
      data/empty.zero data/spherical_arcs/compare spherical_arc_traits
  else
    echo "   ERROR:    not executed   test_traits spherical_arc_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# rational arc traits
#---------------------------------------------------------------------#
test_rational_arc_traits()
{
  local nt=$CORE_INT_NT;
  local kernel=$UNIVARIATE_ALGEBRAIC_KERNEL;
  local geom_traits=$RATIONAL_ARC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits rational_arcs "$flags"
  if [ -n "${SUCCESS}" ] ; then
    run_trapped_test test_traits \
      data/compare.pt data/empty.zero \
      data/empty.zero data/compare rational_arc_traits

    execute_commands_new_structure rational_arcs rational_arc_traits \
      VERTEX IS_VERTICAL COMPARE_Y_AT_X COMPARE_Y_AT_X_LEFT SPLIT MERGE \
      COMPARE_X_ON_BOUNDARY COMPARE_X_NEAR_BOUNDARY COMPARE_Y_NEAR_BOUNDARY
  else
    echo "   ERROR:    not executed   test_traits rational_arc_traits" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# algebraic traits with GMP/MPFI
#---------------------------------------------------------------------#
test_algebraic_traits_gmp()
{
  #TODO: Adapt

  local nt=$CGAL_GMPZ_NT;
  local kernel=$UNIVARIATE_ALGEBRAIC_KERNEL;
  local geom_traits=$ALGEBRAIC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits algebraic "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_new_structure algebraic algebraic_traits_gmp \
      COMPARE COMPARE_Y_AT_X COMPARE_Y_AT_X_RIGHT COMPARE_Y_AT_X_LEFT \
      MAKE_X_MONOTONE IS_VERTICAL VERTEX SPLIT MERGE INTERSECT \
      PARAMETER_SPACE_X PARAMETER_SPACE_Y
  else
    echo   "   ERROR:    not executed   test_traits algebraic_traits_gmp" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
# algebraic traits with LEDA
#---------------------------------------------------------------------#
test_algebraic_traits_leda()
{
  #TODO: Adapt

  local nt=$LEDA_INT_NT;
  local kernel=$UNIVARIATE_ALGEBRAIC_KERNEL;
  local geom_traits=$ALGEBRAIC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits algebraic "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_new_structure algebraic algebraic_traits_leda \
      COMPARE COMPARE_Y_AT_X COMPARE_Y_AT_X_RIGHT COMPARE_Y_AT_X_LEFT \
      MAKE_X_MONOTONE IS_VERTICAL VERTEX SPLIT MERGE INTERSECT \
      PARAMETER_SPACE_X PARAMETER_SPACE_Y
  else
    echo "   ERROR:    not executed   test_traits algebraic_traits_leda" >> $ERRORFILE
  fi
  clean_tests
}


#---------------------------------------------------------------------#
# algebraic traits with CORE
#---------------------------------------------------------------------#
test_algebraic_traits_core()
{
  #TODO: Adapt

  local nt=$CORE_INT_NT;
  local kernel=$UNIVARIATE_ALGEBRAIC_KERNEL;
  local geom_traits=$ALGEBRAIC_GEOM_TRAITS;
  local flags="-DTEST_NT=$nt -DTEST_KERNEL=$kernel -DTEST_GEOM_TRAITS=$geom_traits";

  compile_test_with_flags test_traits algebraic "$flags"
  if [ -n "${SUCCESS}" ] ; then
    execute_commands_new_structure algebraic algebraic_traits_core \
      COMPARE COMPARE_Y_AT_X COMPARE_Y_AT_X_RIGHT COMPARE_Y_AT_X_LEFT \
      MAKE_X_MONOTONE IS_VERTICAL VERTEX SPLIT MERGE INTERSECT \
      PARAMETER_SPACE_X PARAMETER_SPACE_Y
  else
    echo "   ERROR:    not executed   test_traits algebraic_traits_core" >> $ERRORFILE
  fi
  clean_tests
}

#---------------------------------------------------------------------#
#                    remove the previous error file
#---------------------------------------------------------------------#

rm -f $ERRORFILE
rm -f $FULL_ERROR_DESCRIPTION_FILE
rm -f ProgramOutput.test_*
touch $ERRORFILE

#---------------------------------------------------------------------#
#                    compile and run the tests
#---------------------------------------------------------------------#



if [ $# -ne 0 ] ; then
    case $1 in
	-cmake) TEST_WITH_CMAKE="TRUE" ;;
	*)TEST_WITH_CMAKE="FALSE" ;;
    esac
else
    TEST_WITH_CMAKE="FALSE"
fi

echo "Run all tests."

if [ "${TEST_WITH_CMAKE}" != "FALSE" ]; then
    configure
fi

if [ "${TEST_WITH_CMAKE}" != "FALSE" ]; then
    compile_and_run construction_test_suite_generator
fi

test_segment_traits
test_non_caching_segment_traits
test_polyline_traits
test_polycurve_conic_traits
test_polycurve_circular_arc_traits
test_polycurve_bezier_traits
test_non_caching_polyline_traits
test_linear_traits
test_conic_traits

test_line_arc_traits 		# "line arcs" (segments) only
test_circular_arc_traits 	# circular arcs only
test_circular_line_arc_traits 	# for both

test_circle_segments_traits
test_bezier_traits

test_spherical_arc_traits

test_rational_arc_traits

test_algebraic_traits_core
test_algebraic_traits_gmp
test_algebraic_traits_leda

compile_and_run test_insertion
compile_and_run test_unbounded_rational_insertion
compile_and_run test_unbounded_rational_direct_insertion
compile_and_run test_rational_function_traits_2
compile_and_run test_iso_verts

compile_and_run test_vert_ray_shoot_vert_segments

test_construction_segments
test_construction_linear
test_construction_spherical_arcs

test_overlay_segments
test_overlay_spherical_arcs

test_point_location_segments
test_point_location_segments_version
test_point_location_segments_conversion
test_point_location_circle_segments
test_point_location_linear

test_point_location_dynamic_segments

test_batched_point_location_segments
test_batched_point_location_linear
test_batched_point_location_spherical_arcs

test_vertical_decomposition_segments
test_vertical_decomposition_linear
# test_vertical_decomposition_spherical_arcs

compile_and_run test_dual
compile_and_run test_do_intersect
compile_and_run test_zone

compile_and_run test_observer
compile_and_run test_do_equal

test_segment_traits_adaptor
test_linear_traits_adaptor
test_spherical_arcs_traits_adaptor

compile_and_run test_removal
compile_and_run test_unbounded_removal
compile_and_run test_spherical_removal

compile_and_run test_io

# if any error occured then append the full error description file to error file

if [ -f $FULL_ERROR_DESCRIPTION_FILE ] ; then
    echo "******************** appending all error outputs ********************" >> $ERRORFILE
    cat $FULL_ERROR_DESCRIPTION_FILE >> $ERRORFILE
fi
