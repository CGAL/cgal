% =============================================================================
% The CGAL Developers' Manual
% Chapter: Namespaces
% -----------------------------------------------------------------------------
% file   : namespaces.tex
% authors: Stefan Schirra <stschirr@mpi-sb.mpg.de>
% -----------------------------------------------------------------------------
% $Id$
% $Date$
% =============================================================================

\chapter{Namespaces\label{chap:namespaces}}
\ccChapterAuthor{Stefan Schirra ({\tt stschirr@mpi-sb.mpg.de})}

Names, in particular (member) function names and class names should 
be descriptive and easily remembered. So it is not surprising that
different libraries or packages choose the same name for corresponding
or similar classes and functions. A common approach to solving the
naming problem is to add a prefix,\ccIndexMainItem{prefix} for example, 
OpenGL adds \ccc{gl}
and FLTK adds \ccc{fl}. \leda\ uses prefix \ccc{leda_}%
\ccIndexSubitem{prefix}{\ccFont leda_}
\ccIndexSubitem{\leda}{prefix}
to some extent, 
but you have to tell \leda\ not to make the corresponding unprefixed names 
available as well.\footnote{\cgal's
makefile does this by setting \ccc{-DLEDA_PREFIX}.} Initially, \cgal\ used
prefix \ccc{CGAL_}. 
At the beginning of 1999, it was decided to drop prefix \ccc{CGAL_} and to 
introduce namespace \ccc{CGAL}. 

\section{What are namespaces}
A namespace\ccIndexMainItemDef{namespace}
is a scope with a name.\footnote{There are also unnamed namespaces.
They are intented to replace file scope.} Inside the namespace, \ie, the
named scope, all names defined in that scope (and made known to the compiler) 
can be used directly. Outside a namespace, a name defined in the namespace
has to be qualified\footnote{This is a somewhat simplified view; read further
for more details.} by the namespace name, for example \ccc{CGAL::Object},%
\ccIndexSubitem{qualification}{of names} 
or they have to be made usable without qualification by a so-called 
{\em using declaration},
\ccIndexMainItem{using declaration}
\begin{verbatim}
using CGAL::Object;
Object obj;  // name is now known
\end{verbatim}
There is also a statement to make all names from a namespace available in
another scope, but this is a bad idea. Actually, in order not to set a bad
example, we recommend not to use this in \cgal's example and demo programs.

\section{Namespace std}
\ccIndexSubitem{namespace}{\ccFont std}
The names form the standard \CC\ library, especially those from the standard
template library, are in namespace \ccc{std}. This subsumes the I/O-library%
\index{IO library@I/O library!and namespace std@and namespace \texttt{std}}
and also the C-library%
\index{C standard library!and namespace std@and namespace
  \ccStyle{std}} functions. You have to qualify streams and so by
\ccc{std::}, too.  That is:
\begin{verbatim}
std::cout << "Hello CGAL" << std::endl;
\end{verbatim}
or you have to add \ccc{using} declarations for the names you want to
use without \ccc{std::} qualification.

\section{Namespace CGAL}
\ccIndexSubitem{namespace}{\ccFont CGAL}
All names introduced by \cgal\ should be in namespace \ccc{CGAL}, \eg: 
\begin{verbatim}
#include <something>

namespace CGAL {

class My_new_cgal_class {};

My_new_cgal_class 
my_new_function( My_new_cgal_class& );

} // namespace CGAL
\end{verbatim}
Make sure not to have include statements nested between 
\verb+ namespace CGAL { + and \verb+ } // namespace CGAL+.
Otherwise all names defined in the file included will be 
added to namespace \ccc{CGAL}.

\section{Namespace {\tt internal}}
\ccIndexSubitem{namespace}{\ccFont internal}
All names introduced by \cgal\ which are not documented to the user
should be under an \ccc{internal} subnamespace of \ccc{CGAL}, \eg:
\begin{verbatim}
namespace CGAL { namespace internal {

class My_undocumented_class {};

void my_new_function( My_undocumented_class& );

}} // namespace CGAL::internal

namespace CGAL { namespace Package { namespace internal { namespace tags {

class Some_further_class_local_to_Package;

}}}} // namespace CGAL::Package::internal::tags
\end{verbatim}


\section{Name lookup}
The process of searching for a definition of a name detected in
some scope is called name lookup.\ccIndexMainItemDef{name lookup}
Simply speaking, name lookup looks 
up names in the scope where the name is used, 
and if not found, the lookup proceeds in successively enclosing scope 
until the name is found. It terminates as soon as the name is found, no
matter whether the name found fits or not.
If a name is qualified by a namespace name, that namespace is searched
for the name.

\subsection{Argument-dependent name lookup}
\ccIndexSubitem{name lookup}{argument-dependent}%
\ccIndexSubitem{name lookup}{unqualified}
Unqualified name lookup, \ie, lookup when there is no namespace or class
name and no scope resolution%
\ccIndexMainItem{scope resolution} operator \verb+::+, proceeds like qualified 
name lookup, but name lookup for a function call is supposed to search also 
the namespaces of the argument types for a matching function name. 
This is sometimes called Koenig-lookup.\ccIndexMainItem{Koenig lookup}

\subsection{Point of instantiation of a template}
Name lookup in a template is slightly more complicated.
\ccIndexSubitem{name lookup}{template}
Names that do not depend on template parameters are looked up at the point
of definition of the template%
\ccIndexSubitem{template}{point of definition}
(so they must be known at the point of definition). 
Names depending on the template parameters are looked up at
the point of instantiation%
\ccIndexSubitem{template}{point of instantiation} of the template. 
The name is searched for in the
scope of the point of instantiation and the scope of the
point of definition. Here is a small example:

\ccIncludeExampleCode{Developers_manual/poi.cpp}

There is a ambiguity, because both the scope enclosing the point of 
instantiation and the scope enclosing the point of definition contain
a \ccc{mix} function. The mips compiler on {\sc IRIX} 
complains about this ambiguity: 

{\small
\begin{verbatim}
bash-2.03$ CC -64 poi.cpp 
cc-1282 CC: ERROR File = poi.cpp, Line = 11
  More than one instance of overloaded function "mix" matches the argument list.

            Function symbol function template "B::mix(const T &, const T &)"
                      is ambiguous by inheritance.
            Function symbol function template "A::mix(const T &, const T &)"
                      is ambiguous by inheritance.
            The argument types are:  (const double, const double).
  { return mix( a1, a2); }
           ^
          detected during instantiation of
                    "const double &A::use(const double &, const double &)" 

1 error detected in the compilation of "poi.cpp".
\end{verbatim}
}
There wouldn't be any problems, if \verb+B::use_use()+ would be a template
function as well, because this would move the point of instantiation
into global scope.

By the way, \verb+gcc 2.95+ uses the function defined at the 
point of definition.

\section{Namespace CGAL::NTS}

{\em \textbf{Note:} This section will be revised once the forthcoming
  revision of the \CC-standard gets into a more definite state. The
  standard library has similar problems, e.g. for \ccc{swap()},
  see\begin{ccTexOnly}\footnote{\path'http://www.open-std.org/jtc1/sc22/wg21/docs/cwg\_toc.html'}\end{ccTexOnly}
  issues% 
  \begin{ccHtmlOnly}
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#225">
  \end{ccHtmlOnly}%
  225\ccTexHtml{,}{</a>,}%
  \begin{ccHtmlOnly}
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#226">
  \end{ccHtmlOnly}%
  226\ccTexHtml{,}{</a>,} and%
  \begin{ccHtmlOnly}
    <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/lwg-defects.html#229">
  \end{ccHtmlOnly}%
  229\ccTexHtml{.}{</a>.}
  Currently, \ccc{CGAL::NTS} does not exist anymore, and the
  \ccc{CGAL_NTS} macro boils down to \ccc{CGAL::}. As the future
  interface is not yet fixed, people should still follow the
  guidelines given below.}

What are the conclusions from the previous subsection. If \ccc{A}
plays the role of \ccc{std} and \ccc{B} the role of \cgal, we can
conclude that \cgal\ should not define template
functions that are already defined in namespace \ccc{std}, especially
\ccc{min} and \ccc{max}.
Also, letting CGAL be namespace \ccc{A}, we should not define 
templates in \cgal\ that are likely to conflict with templates in 
other namespaces (playing the role of \ccc{B}): Assume that both \cgal\
and some other namespace define an \ccc{is_zero()} template. 
Then an instantiation of some \cgal\ template using \ccc{is_zero()} 
that takes place inside the other namespace causes trouble. 
For this reason, we have another namespace \ccc{NTS}%
\ccIndexSubitem{namespace}{\ccFont CGAL::NTS}
nested in \ccc{CGAL}, which contains potentially conflicting
template functions.

\subsection{Which function calls should be qualified in \cgal\ code?}
Out current policy is:
\begin{itemize}
\item
\ccc{max} should be used without qualification\ccIndexGlobalFunction{max}
\item
\ccc{min} should be used without qualification\ccIndexGlobalFunction{min}
\item
For the following functions, templates are provided in nested namespace
\ccc{NTS}:
\begin{itemize}
\item[]\ccc{abs}\ccIndexGlobalFunction{abs}
\item[]\ccc{compare}\ccIndexGlobalFunction{compare}
\item[]\ccc{gcd}\ccIndexGlobalFunction{gcd}
\item[]\ccc{is_negative}\ccIndexGlobalFunction{is_negative}
\item[]\ccc{is_positive}\ccIndexGlobalFunction{is_positive}
\item[]\ccc{is_one}\ccIndexGlobalFunction{is_one}
\item[]\ccc{is_zero}\ccIndexGlobalFunction{is_zero}
\item[]\ccc{sign}\ccIndexGlobalFunction{sign}
\item[]\ccc{square}\ccIndexGlobalFunction{square}
\end{itemize}
Calls of the above functions should be qualified using macro 
\ccc{CGAL_NTS},% 
\index{CGAL_NTS macro@{\tt CGAL\_NTS} macro}
which maps to \ccc{CGAL::NTS::}\footnote{The use of
the macro eases future changes in our policy.}: For example,
\begin{verbatim}
if ( CGAL_NTS is_zero(0) ) { /* ... */ } 
\end{verbatim}
Qualification with \ccc{CGAL} does not work.
\item
The following functions can be qualified by \ccc{CGAL_NTS} as well:
\begin{itemize} 
\item[]\ccc{to_double}\ccIndexGlobalFunction{to_double}
\item[]\ccc{is_valid}\ccIndexGlobalFunction{is_valid}
\item[]\ccc{is_finite}\ccIndexGlobalFunction{is_finite}
\item[]\ccc{sqrt}\ccIndexGlobalFunction{sqrt}\\
\item[]\ccc{div}\ccIndexGlobalFunction{div}\\
Whenever the argument of \ccc{sqrt} is a concrete type, \ie, it does
not depend on a template parameter, you should qualify the call of
\ccc{sqrt}, for example \verb+std::sqrt(2.0)+
\end{itemize}
Here, qualification with \ccc{CGAL} works as well.
\end{itemize}
Summarizing, you can always qualify functions on number types
with \ccc{CGAL_NTS} besides \ccc{min} and \ccc{max}.

\InternalOnly{

\section{Requirements and recommendations}

Requirements:
\begin{itemize}
\item all names defined by \cgal\ are in namespace \ccc{CGAL}
  (including namespaces nested in namespace \ccc{CGAL}).
\item qualify calls of \ccc{is_zero}, \ccc{is_one}, \ccc{is_negative},
  \ccc{is_positive}, \ccc{sign}, \ccc{abs}, \ccc{compare},
  \ccc{square} by \texttt{CGAL\_NTS}.
  \ccIndexSubitem{qualification}{\ccFont CGAL_NTS}%
\end{itemize}

%% Recommendations:
%% \begin{itemize}
%% \item Don't qualify calls of \ccc{max} and \ccc{min}.
%% \item Don't use \ccc{CGAL::} qualification inside namespace \ccc{CGAL},%
%% \ccIndexSubitem{qualification}{\ccFont CGAL::}
%% unless it is required by a compiler or to resolve a name conflict with a
%% local type in a scope enclosed by namespace \ccc{CGAL}.
%% \end{itemize}

}

