% =============================================================================
% The CGAL Developers' Manual
% Chapter: Geometry Kernels
% -----------------------------------------------------------------------------
% file   : kernels.tex
% authors: Stefan Schirra <stschirr@mpi-sb.mpg.de>
% -----------------------------------------------------------------------------
% $Id$
% $Date$
% =============================================================================

\chapter{Geometry Kernels\label{chap:kernels}}
\ccChapterAuthor{Olivier Devillers ({\tt olivier.devillers@inria.fr})\\
Marc Glisse ({\tt marc.glisse@inria.fr})\\
Stefan Schirra
}


The layer of geometry kernels\ccIndexMainItem[t]{kernel} provides
basic geometric entities of constant size\footnote{In dimension $d$,
an entity of size $O(d)$ is considered to be of constant size.} and
primitive operations on them. Each entity is provided as both a
stand-alone class, which is parameterized by a kernel class, and as a
type in the kernel class. Each operation in the kernel is provided via
a functor class\footnote{A class which defines a member
\ccc{operator()}.} in the \ccIndexMainItem[t]{function objects} kernel
class and also as either a member function or a global function.
See~\cite{hhkps-aegk-01} for more details about this design.
%%
\ccIndexMainItemDef[t]{kernel traits}% 
\ccIndexSubitem{traits class}{kernel as a}% 
%%
Ideally, if the kernel provides all the primitives required, you can
use any kernel as a traits class directly with your algorithm or data
structure; see also Chapter~\ref{chap:traits_classes}. If you need
primitives not provided by the kernel (yet), please read
Section~\ref{sec:NewKernelTraits} below.

\section{Different kernels\label{sec:different_kernels}}

\cgal\ provides different kernels, thay can differ by internal
representation of objects (e.g.  cartesian versus  homogeneous) 
or provide different functionalities (e.g. circular kernel).
When creating a new package, the authors have to specify clearly
the requirements needed by the kernel used.
For example they can specify the needs with respect to the arithmetic.

The authors may specify a targeted kernel in the list of predefined
kernels
(e.g.  \ccc{Exact_predicates_inexact_constructions_kernel}).

\subsection{Cartesian versus homogeneous
  computation\label{sec:CartesianHomogeneousComputation}}

Point coordinates can be represented in a homogeneous or cartesian
way.
The developer of a package can keep in mind that cartesian will be
usually more space consuming, while homogeneous can be interesting if
exact rational computations are needed.
In any way, a package has to work with both representations.


Since \cgal\ uses homogeneous representation for affine geometry  and not
for projective geometry, the homogenizing coordinate  is non zero.
The cartesian 
representation corresponding to an homogeneous point
$(x_0,x_1,...,x_d,w)$ is
$(x_0/w,x_1/w,...,x_d/w)$. Hence, homogeneous representation is not unique;
$(\alpha x,\alpha y,\alpha z,\alpha w)$ is an alternative
representation to $(x,y,z,w)$  for any $\alpha\neq 0$. 
Internally, \cgal\ always maintains a non-negative homogenizing coordinate.




\section{Kernel design and conventions}
\ccIndexSubitem{kernel}{design}%
\ccIndexSubitem{design}{kernel}%
Each kernel object is provided as both a stand-alone class, which is 
parameterized by a kernel class (\ccc{Geo_object_D<K>}), and as a type 
in the kernel class (\ccc{K::Geo_object_D}).  While the former use may
be more natural for users not interested in the flexibility of the kernel
(and is compatible with the original kernel design \cite{fgkss-dccga-00}), the
latter syntax should be used in all code distributed with the library
as it allows types in the kernel to be easily exchanged and modified.
Similarly, each operation and construction in the kernel is provided via 
a function object class in the \ccIndexMainItem[t]{function objects}
kernel class and also as either a member function or a global function; 
developers should use the function object classes to gain access to the
functionality.  See~\cite{hhkps-aegk-01} for more details about this 
design and how it is accomplished.

The classes for the geometric objects in the kernel have a 
standardized interface.%
\ccIndexSubitem{kernel}{conventions}
\begin{itemize}
\item
All classes (currently only in dimensions 2 and 3) have a \ccc{bbox()} member function computing a bounding box.%
\ccIndexMainItem[C]{ bbox}
\item
All classes have a \ccc{transform(Aff_transformation_d t)} member function
to compute the object transformed by \ccc{t}.%
\ccIndexMainItem[C]{transform}  
\item
Oriented $d-1$ dimensional objects\footnote{Note that the dimension
of an object might depend on its use. A line in the plane has dimension
$d-1$. As a halfspace, it has dimension $d$.} provide member functions
\ccc{has_on_positive_side(Point_d)}%
\ccIndexMainItem[C]{has_on_positive_side}, \ccc{has_on_boundary(Point_d)}%
\ccIndexMainItem[C]{has_on_boundary}, 
and \ccc{has_on_negative_side(Point_d)}%
\ccIndexMainItem[C]{has_on_negative_side}. Furthermore, there is a member
function \ccc{oriented_side(Point_d)}%
\ccIndexMainItem[C]{oriented_side} returning an object of type
\ccc{CGAL::Oriented_side}.\ccIndexMainItem[C]{Oriented_side}
\item
Full-dimensional bounded objects provide member functions
\ccc{has_on_bounded_side(Point_d)}%
\ccIndexMainItem[C]{has_on_bounded_side}, \ccc{has_on_boundary(Point_d)}%
\ccIndexMainItem[C]{has_on_boundary}, 
and \ccc{has_on_unbounded_side(Point_d)}%
\ccIndexMainItem[C]{has_on_unbounded_side}. Furthermore, there is a member
function \ccc{bounded_side(Point_d)}%
\ccIndexMainItem[C]{bounded_side} returning an object of type
\ccc{CGAL::Bounded_side}.\ccIndexMainItem[C]{Bounded_side}
\item
Oriented objects have a member function \ccc{opposite()}%
\ccIndexMainItem[C]{opposite} returning
the same object with opposite orientation.
\end{itemize}


\section{Number-type based predicates}
\ccIndexSubitem{predicate}{number-type based}
For a number of predicates, there are versions that operate on
the coordinates directly, not on the geometric objects. These
number-type based predicates ease re-use with non-\cgal\ types.

\section{Missing functionality\label{sec:NewKernelTraits}}
\ccIndexSubitem{predicate}{missing} 
Kernel traits should avoid 
redundant functionality, or if similar functionality is implemented
with a different API, then one should really implement the
functionality and the others call that one.

%%%  Sentence below is not true, there is right_turn and left_turn in
%%%  the global functions of the kernel
%In particular, they do not provide a right
%turn predicate, since a left turn predicate exists. A right turn
%functor can be created from the left turn functor using the function
%\ccc{boost::bind}.

Whenever you need a predicate that is not present in the current kernel
traits, you should first try to re-use the available predicates (you
might rewrite the code or implement the new predicate using existing ones).
If this is not feasible (especially for efficiency reasons), we have to 
decide on adding the new predicate to the kernel traits. 
If the new predicate is not too special, it will be added. 
Otherwise you cannot use the kernel as a traits class, but have
to use additional traits.%
\ccIndexSubitem{traits class}{additional} 

See Section \ref{sec:CartesianHomogeneousComputation} on how to derive the
homogeneous version of a predicate from the Cartesian version. 


