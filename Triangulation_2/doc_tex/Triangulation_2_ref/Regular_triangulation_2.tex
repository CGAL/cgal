% +------------------------------------------------------------------------+
% | Reference manual page: Regular_triangulation_2.tex
% +------------------------------------------------------------------------+
% | 12.04.2000   Author
% | Package: Package
% | 
\RCSdef{\RCSRegulartriangulationRev}{$Id$}
\RCSdefDate{\RCSRegulartriangulationDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}{Regular_triangulation_2<Traits,Tds>}  %% add template arg's if necessary

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition
  
The class \ccRefName\ 
is designed to maintain the
regular triangulation of a set of weighted points.


Let ${  PW} = \{(p_i, w_i), i = 1, \ldots , n \}$ be a set of 
weighted points where each $p_i$ is a point and each $w_i$
is a scalar called the weight of point $p_i$.
Alternatively, each weighted point $(p_i, w_i)$ can be regarded
as a two dimensional sphere with center $p_i$ and radius $r_i=\sqrt{w_i}$.

The power diagram of the set ${  PW}$ is a planar partition 
such that each cell corresponds to sphere $(p_i, w_i)$ of ${  PW}$
and is the locus of points  $p$ whose power with respect to $(p_i, w_i)$
is less than its power with respect to any other sphere $(p_j, w_j)$
in ${  PW}$. 
The dual of this diagram is a triangulation 
whose domain covers the convex hull of the set 
${  P}= \{ p_i, i = 1, \ldots , n \}$ of center points
and whose vertices are a subset of ${  P}$.
Such a triangulation is called a regular triangulation.
The  three points $p_i, p_j$ and $p_k$ of ${  P}$
form a triangle in the regular triangulation of ${  PW}$
iff there is a point $p$ of the plane whose
powers with respect to $(p_i, w_i)$, $(p_j, w_j)$
and $(p_k, w_k)$ are equal and less than the power of $p$
with respect to any other sphere in  ${  PW}$.

Let us defined the power product of two weighted points
$(p_i, w_i)$ and $(p_j, w_j)$ as:
\[\Pi(p_i, w_i,p_j, w_j) = p_ip_j ^2 - w_i  - w_j  .\]
$\Pi(p_i, w_i,p_j, 0)$ is simply the power of point $p_j$
with respect to the sphere $(p_i, w_i)$, and two weighted points 
are said to be orthogonal if their power product is null.
The power circle of three weighted points
 $(p_i, w_i)$, $(p_j, w_j)$
and $(p_k, w_k)$ is defined as the unique circle
$(\pi, \omega)$  orthogonal to
 $(p_i, w_i)$, $(p_j, w_j)$
and $(p_k, w_k)$.

The regular triangulation of the sets ${  PW}$
satisfies the following {\em regular property} (which just reduces to the 
Delaunay property when all the weights are null):
a triangle $p_ip_jp_k$ of the regular triangulation
of ${  PW}$ is such that the power product of any weighted point
 $(p_l, w_l)$ of ${  PW}$ with the power circle of
 $(p_i, w_i)$, $(p_j, w_j)$ is $(p_k, w_k)$ is positive or null.
We call  power test of the weighted point $(p_l, w_l)$ with respect
to the face  $p_ip_jp_k$, the predicates testing
the sign of 
the power product of $(p_l, w_l)$ with respect to
the power circle of
 $(p_i, w_i)$, $(p_j, w_j)$ is $(p_k, w_k)$. This power product
is given by the following
determinant
\[\left| \begin{array}{cccc}
1  &  x_i  &  y_i  &  x_i ^2 + y_i ^2 - w_i  \\
1  &  x_j  &  y_j  &  x_j ^2 + y_j ^2 - w_j  \\
1  &  x_k  &  y_k  &  x_k ^2 + y_k ^2 - w_k  \\
1  &  x_l  &  y_l  &  x_l ^2 + y_l ^2 - w_l
\end{array}
\right|
\]

A pair of neighboring faces $p_ip_jp_k$
and $p_ip_jp_l$ is said to be locally regular
(with respect to  the weights in ${  PW}$)
if the power test of $(p_l,w_l)$ with respect to
$p_ip_jp_k$ is positive.
A classical  result of computational geometry
establishes that a triangulation of the convex hull of ${  P}$
such that any pair of neighboring faces is regular with respect
to ${  PW}$, is a
 regular triangulation of ${  PW}$.

Alternatively, the regular triangulation
of the weighted points set ${  PW}$
can be obtained as the projection
on the two dimensional plane of the convex hull of the set of three
dimensional points 
${  P'}= \{ (p_i,p_i ^2 - w_i ), i = 1, \ldots , n \}$.

The vertices of the regular triangulation
of a set of weighted points ${  PW}$ form only a subset
of the set of center points of ${   PW}$.
Therefore the  insertion of a weighted point  in a regular triangulation
does not necessarily imply the creation of a new vertex.
If the new inserted point does not appear as a vertex in the
regular triangulation, it is said to be hidden. 

Hidden points
are  stored in special vertices called hidden vertices.
A hidden point is considered as hidden by
the facet of the triangulation where its point component is located :
in fact, the hidden point 
can appear as vertex of the triangulation
only if this facet is removed.
Each  face of a regular triangulation stores
the list of hidden vertices whose points are located in the facet.
When a facet is removed, 
points hidden by this facet are reinserted in the triangulation.





\ccInclude{CGAL/Regular_triangulation_2.h}

\ccParameters
The geometric traits parameter \ccc{Traits}  has 
to be instantiated with a model of the concept
\ccc{RegularTriangulationTraits_2}. 
The concept \ccc{RegularTriangulationTraits_2} refines the
concept \ccc{TriangulationTraits_2} by adding the type
\ccc{Weighted_point_2} to describe weighted points
and the type \ccc{Power\_test_2} to perform
power tests on weighted points.

The \ccc{Tds} parameter has to be instantiated by a model of
\ccc{TriangulationDataStructure_2}. The face base of a regular
triangulation has to be a model of the concept
\ccc{RegularTriangulationFaceBase_2}.  while
the vertex base class has to be a model
of \ccc{RegularTriangulationVertexBase_2}.
\cgal\ provides a default
instantiation for the \ccc{Tds} parameter by the class
\ccc{CGAL::Triangulation_data_structure_2 <
                       CGAL::Reugular_triangulation_vertex_base_2<Traits>,
                       CGAL::Regular_Triangulation_face_base_2<Traits> >}.
 
\ccInheritsFrom
\ccc{Triangulation_2<Traits,Tds>}


\ccTypes
\ccThree{typedef Traits::Weighted_point}{Weighted_point;}{}
\ccThreeToTwo
\ccTypedef{typedef Traits::Distance Distance;}{}

\ccTypedef{typedef Traits::Line Line;}{}
\ccGlue
\ccTypedef{typedef Traits::Ray Ray;}{}
\ccGlue
\ccTypedef{typedef Traits::Bare_point  Bare_point;}{}
\ccGlue
\ccTypedef{typedef Traits::Weighted_point  Weighted_point;}{}

\ccNestedType{All_vertices_iterator}{An iterator that allows to enumerate the
vertices that are not hidden.}
\ccNestedType{Finite_vertices_iterator}{An iterator that allows to enumerate the
finite vertices that are not hidden.}
\ccNestedType{Hidden_vertices_iterator}{An iterator that allows to enumerate the
hidden vertices.}


\ccCreation
\ccCreationVariable{rt}  %% choose variable name

\ccConstructor{Regular_triangulation_2(const Traits& gt = Traits());}
{Introduces an empty regular triangulation \ccVar.}

\ccConstructor{Regular_triangulation_2(const Regular_triangulation_2 &rt);}
{Copy constructor.}


\ccHeading{Insertion and Removal}

\ccThree{Vertex_handle}{T.push_back(const Point &p);}{}

\ccMethod{Vertex_handle insert(const Weighted_point& p, Face_handle f=Face_handle());}
{inserts  weighted point \ccc{p} in the regular triangulation.
If the point \ccc{p}  does not appear as a vertex of the triangulation,
the returned vertex is  a hidden vertex.
If given the parameter \ccc{f} is used as an hint
for the place to start the location process of point \ccc{p}.}


\ccMethod{Vertex_handle insert(const Weighted_point &p,
                       Locate_type  lt,
                       Face_handle loc, int li );}
{insert a weighted point \ccc{p} whose bare-point is assumed to be
located in  \ccc{lt,loc,li}.}

\ccMethod{Vertex_handle push_back(const Point& p);}
{Equivalent to \ccc{insert(p)}.}

\ccMethod{template < class InputIterator >
          std::ptrdiff_t
          insert(InputIterator first, InputIterator last);}
{inserts the weighted points in the range
 $\left[\right.$\ccc{first}, \ccc{last}$\left.\right)$.
 It returns the difference of the number of vertices between after and
 before the insertions (it may be negative due to hidden points).
 Note that this function is not guaranteed to insert the weighted points
 following the order of \ccc{InputIterator}, as \ccc{spatial_sort}
 is used to improve efficiency.
 \ccPrecond{The \ccc{value_type} of \ccc{first} and \ccc{last}
 is \ccc{Weighted_point}}.}

\ccMethod{template < class WeightedPointWithInfoInputIterator >
          std::ptrdiff_t
          insert(WeightedPointWithInfoInputIterator first, WeightedPointWithInfoInputIterator last);}
{
inserts the weighted points in the iterator range $\left[\right.$\ccc{first},
\ccc{last}$\left.\right)$.  
It returns the difference of the number of vertices between after and
before the insertions (it may be negative due to hidden points).
Note that this function is not guaranteed to insert the weighted points
following the order of \ccc{WeightedPointWithInfoInputIterator}, as \ccc{spatial_sort}
is used to improve efficiency.
Given a pair \ccc{(p,i)},  the vertex \ccc{v} storing \ccc{p} also stores \ccc{i}, that is 
\ccc{v.point() == p} and \ccc{v.info() == i}. If several pairs have the same point, 
only one vertex is created, one of the objects of type \ccc{Vertex::Info} will be stored in the vertex.
\ccPrecond{\ccc{Vertex} must be model of the concept \ccc{TriangulationVertexBaseWithInfo_2}.
The \ccc{value_type} of \ccc{first} and \ccc{last} is \ccc{std::pair<Weighted_point,Vertex::Info>}.}
}

\ccMethod{void   remove(Vertex_handle v);}
{removes the vertex from the triangulation.}

\ccHeading{Queries}

\ccMethod{template <class OutputItFaces, class OutputItBoundaryEdges,
  class OutputItHiddenVertices>
  CGAL::Triple<OutputItFaces,OutputItBoundaryEdges,OutputItHiddenVertices>
  get_conflicts_and_boundary_and_hidden_vertices(const Weighted_point
  &p, OutputItFaces fit, OutputItBoundaryEdges eit,
  OutputItHiddenVertices vit, Face_handle start) const;} {
  \ccc{OutputItFaces} is an output iterator with \ccc{Face_handle} as
  value type.  \ccc{OutputItBoundaryEdges} stands for an output
  iterator with \ccc{Edge} as value type.
  \ccc{OutputItHiddenVertices} is an output iterator with
  \ccc{Vertex_handle} as value type.  This member function outputs in
  the container pointed to by \ccc{fit} the faces which are in
  conflict with point \ccc{p} i. e. the faces whose power circles
  have negative power wrt.\ \ccc{p}.  It outputs in the container
  pointed to by \ccc{eit} the boundary of the zone in conflict
  with \ccc{p}.  It inserts the vertices that would be hidden by \ccc{p} 
  into the container pointed to by \ccc{vit}.  The boundary edges of
  the conflict zone are output in counter-clockwise order and each edge
  is described through its incident face which is not in conflict with
  \ccc{p}.  The function returns in a \ccc{CGAL::Triple} the resulting output
  iterators.
  \ccPrecond{\ccc{dimension()==2}.}}

\ccMethod{template <class OutputItFaces, class OutputItBoundaryEdges>
  std::pair<OutputItFaces,OutputItBoundaryEdges>
  get_conflicts_and_boundary(const Weighted_point
  &p, OutputItFaces fit, OutputItBoundaryEdges eit, Face_handle start) const;} 
{
  same as above except that only the faces in conflict with \ccc{p} and 
  the boundary edges of the conflict zone 
  are output via the corresponding output iterators. The function returns 
  in a std::pair the resulting output iterators.
  \ccPrecond{\ccc{dimension()==2}.}}

 \ccMethod{template <class OutputItFaces, 
  class OutputItHiddenVertices>
  std::pair<OutputItFaces,OutputItHiddenVertices>
  get_conflicts_and_hidden_vertices(const Weighted_point
  &p, OutputItFaces fit, OutputItHiddenVertices vit, Face_handle start) const;}
{
  same as above except that only the faces in conflict with \ccc{p} and 
  the vertices that would be hidden by \ccc{p}
  are output via the corresponding output iterators. The function returns 
  in a std::pair the resulting output iterators.
  \ccPrecond{\ccc{dimension()==2}.}}

\ccMethod{template <class OutputItBoundaryEdges, class OutputItHiddenVertices>
  std::pair<OutputItBoundaryEdges,OutputItHiddenVertices>
  get_boundary_of_conflicts_and_hidden_vertices(const Weighted_point
  &p, OutputItBoundaryEdges eit,
  OutputItHiddenVertices vit, Face_handle start) const;} 
{ same as above except that only the vertices that would be hidden
  by \ccc{p} and the boundary of the zone in conflict with \ccc{p} are
  output via the corresponding output iterators. The boundary edges of
  the conflict zone are output in counterclockwise order and each edge
  is described through the incident face which is not in conflict with
  \ccc{p}. The function returns in a std::pair the resulting output
  iterators.}

\ccMethod{template <class OutputItFaces> 
          OutputItFaces
          get_conflicts (const Point  &p, 
                         OutputItFaces fit, 
                         Face_handle start) const;}
{same as above except that only the faces in conflict with \ccc{p}
are output. The function returns the resulting output iterator.
\ccPrecond{\ccc{dimension()==2}.}}

\ccMethod{template <class OutputItBoundaryEdges>
          OutputItBoundaryEdges
          get_boundary_of_conflicts(const Point  &p, 
                                    OutputItBoundaryEdges eit,
                                    Face_handle start) const;}
{ same as above except that only the boundary edges
of the conflict zone are output in counterclockwise order
where each edge is described  through the incident face
which is not in conflict with \ccc{p}.
The function returns the resulting output iterator.}

\ccMethod{template <class OutputItHiddenVertices> 
          OutputItHiddenVertices
          get_hidden_vertices(const Point  &p, 
          OutputItHiddenVertices vit, 
          Face_handle start) const;}
        {same as above except that only the vertices that would be hidden by  \ccc{p}
          are output. The function returns the resulting output iterator.}

\ccMethod{Vertex_handle nearest_power_vertex(Bare_point p);}
{Returns the vertex of the triangulation which is nearest to \ccc{p}
  with respect to the power distance. This means that the power of the
query point \ccc{p} with respect to the weighted point in the nearest
vertex is smaller than the power of \ccc{p} with respect to the
weighted point in any other vertex. Ties are broken arbitrarily. The
default constructed handle is returned if the triangulation is empty.}

\ccHeading{Access functions}
\ccThree{Hidden_vertices_iterator}{t.finite_vertices_begin()x}{}

\ccMethod{int number_of_vertices() const;}
{returns the number of finite vertices that are not hidden.}
\ccGlue
\ccMethod{int number_of_hidden_vertices() const;}
{returns the number of hidden vertices.}
\ccGlue
\ccMethod{Hidden_vertices_iterator hidden_vertices_begin() const;}
{starts at an arbitrary hidden vertex.}
\ccGlue
\ccMethod{Hidden_vertices_iterator hidden_vertices_end() const;}
{past the end iterator for the sequence of hidden vertices.}
\ccGlue
\ccMethod{Finite_vertices_iterator finite_vertices_begin() const;}
{starts at an arbitrary unhidden finite vertex}
\ccGlue
\ccMethod{Finite_vertices_iterator finite_vertices_end()
const;}{Past-the-end iterator}
\ccGlue
\ccMethod{All_vertices_iterator all_vertices_end() const;}
{starts at an arbitrary unhidden vertex.}
\ccGlue
\ccMethod{All_vertices_iterator all_vertices_begin() const;}
{past the end iterator.}

\ccHeading{Dual power diagram}
\ccIndexMainItem{power diagram}
The following member functions provide the elements of the
dual power diagram.

\ccMethod{Point weighted_circumcenter(const Face_handle &f) const;}
{returns the center of the circle orthogonal to the three weighted
points corresponding to the vertices of face \ccc{f}.
\ccPrecond{\ccc{f} is not infinite.}}

\ccMethod{Point dual(const Face_handle &f) const;}
{same as weighted\_circumcenter}

\ccMethod{Object dual(const Edge &e) const;}
{If both incident faces are finite, returns a segment whose endpoints are the
duals of each incident face. If only one incident face is finite, returns a
ray whose endpoint is the dual of the finite incident face and supported by
the line which is the bisector of the edge's endpoints. If both incident faces
are infinite, returns the line which is the bisector of the edge's endpoints
otherwise.  }

\ccMethod{Object dual(const Edge_circulator& ec) const;}
{Idem}

\ccMethod{Object dual(const Edge_iterator& ei) const;}
{Idem}

\ccMethod{
template < class Stream>
  Stream& draw_dual(Stream & ps);}
{output the dual power diagram to stream \ccc{ps}.}

\ccPredicates
\ccThree{Oriented_side}{side_of_}{}
\ccThreeToTwo

\ccMethod{Oriented_side
  power_test(Face_handle f,
                          const Weighted_point& p) const;}
{Returns the power test of  \ccc{p} with respect to the 
power circle  associated with \ccc{f}}



\begin{ccAdvanced}
\ccHeading{Miscellaneous}
\ccThree{Vertex_handle}{T.push_back(const Point &p);}{}

\ccMethod{bool is_valid(bool verbose = false, int level = 0) const;}
{ Tests the validity of the triangulation as a \ccc{Triangulation_2}
and additionally test the regularity of the triangulation. This method is
useful to debug regular triangulation algorithms implemented by
 the user.}
\end{ccAdvanced}



\ccSeeAlso
\ccc{CGAL::Triangulation_2<Traits,Tds>}, \\
\ccc{TriangulationDataStructure_2}, \\
\ccc{RegularTriangulationTraits_2} \\
\ccc{RegularTriangulationFaceBase_2} \\
\ccc{RegularTriangulationVertexBase_2} \\
\ccc{CGAL::Regular_triangulation_face_base_2<Traits>} \\
\ccc{CGAL::Regular_triangulation_vertex_base_2<Traits>}


%\ccExample
%The following code fragment creates a regular triangulation 
%of a set of weighted points.


%\ccIncludeExampleCode{Triangulation_2/regular.cpp}


\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

