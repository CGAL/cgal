% +------------------------------------------------------------------------+
% | Reference manual page: MeshComplex_3InTriangulation_3.tex
% +------------------------------------------------------------------------+
% | 13.02.2009   Author
% | Package: Package
% |
\RCSdef{\RCSMeshComplexInTriangulationRev}{$Id$}
\RCSdefDate{\RCSMeshComplexInTriangulationDate}{$Date$}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{MeshComplex_3InTriangulation_3}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition

The concept \ccRefName\ describes a data structure 
to represent and maintain a 3D complex embedded in a 3D triangulation.
More precisely, the concept \ccRefName\  is a minimal version
designed to represent 
3D complexes that have only faces with dimension $2$ and $3$.
Embedded 3D  complexes with faces of dimension $0$, $1$, $2$ and $3$,
are more conveniently represented by the refined concept
\ccc{MeshComplexWithFeatures_3InTriangulation_3}.


The data structure includes a 3D triangulation which is itself a 3D complex.
To distinguish the faces of the embedded 3D complex from the
faces of the triangulation, we call  the faces of the embedded complex
respectively  {\em subdomains}, for 3D faces
and {\em surface patches}, for 2D faces,
while  the triangulations faces  are called respectively
cells, facets, edges and vertices.

Each subdomain of the embedded 3D complex is a union of 
triangulation cells. Cells that belong to some subdomain are said to belong
to the embedded complex.
 Each surface patch  is a union of 
triangulation facets. Triangulation facets that belong to some
surface patch are called surface facets. 
The concept \ccRefName\  handles the  marking and retrieval of the 
cells of the triangulation belonging to the subdomains
and  of the facets of the triangulation belonging to the surface patches.
The concept \ccRefName\  also  includes an index type  for vertices of the triangulation
and attaches an integer, called the {\em dimension} to each vertex.
When used by the meshing algorithm, 
the index and the dimension  of each vertex  are used to store respectively
the lowest dimensional face of the input complex including the vertex
and the dimension of this face.



In the 3D mesh generator, the concept \ccRefName\ is used
when the domain to be meshed has no feature with dimension $0$ and $1$.
Such a data structure   is used internally by the mesh generator  to maintain
the current  approximation of each subdomain
and each boundary surface patch. 
The data structure encodes the final mesh at the end of the meshing process.


% Each subdomain is approximated as the union of some
%  cells of the embedding triangulation.
% The 3D complex is always a pure 3D complex, i.e., it includes
% a subset of the cells of the triangulations as well as their subfaces.

% The data structure also represents a 2D complex, the boundary complex,
% embedded in the same 3D
% triangulation,  and  representing the boundary of the 3D complex.
%  This 2D complex includes, for each surface patch of the input domain,
%  a set of triangulation  facets, forming an approximation of the surface patch.
% Facets in the boundary complex are called {\em surface facets} or
% {\em boundary facets}.


\ccTypes

\ccNestedType{Triangulation}{Type of the
embedding 3D triangulation. 
This type must be a 3D
regular triangulation of \cgal{} when  used for 3D mesh generation.}
% Vertex and cell base class of that
% triangulation must be
% models of the concepts
% \ccc{MeshVertexBase_3} and \ccc{MeshCellBase_3} respectively.

\ccGlue
\ccTypedef{typedef Triangulation::Vertex_handle Vertex_handle;}
{ Type  \ccc{Vertex_handle} type of
the triangulation.}
\ccGlue
\ccTypedef{typedef Triangulation::Cell_handle  Cell_handle;}
{ The \ccc{Cell_handle} type  of
the triangulation.}
\ccGlue
\ccTypedef{typedef Triangulation::Facet Facet;}
{The \ccc{Facet} type of
the triangulation.}
\ccGlue
\ccTypedef{typedef Triangulation::Edge Edge;}
{The \ccc{Edge} type of
the triangulation.}
\ccGlue
\ccTypedef{typedef Triangulation::size_type size_type;}
{Size type (unsigned integral type).}

% \ccEnum{enum Face_status {NOT_IN_COMPLEX, ISOLATED, BOUNDARY, REGULAR,
% SINGULAR};}
% {A type to describe the status of a face (facet, edge, or vertex) with respect to 
% the 2D \& 3D complex. Cells can be either \ccc{NOT_IN_COMPLEX} or \ccc{REGULAR}
%   depending on whether they belong to the 3D complex or not.

% Facets can only be  \ccc{NOT_IN_COMPLEX}  or \ccc{REGULAR}
% depending on whether they belong to the 2D complex on not.


\ccNestedType{Subdomain_index}{ A type for indices of subdomains.
This type must match the type \ccc{MeshDomain_3::Subdomain_index}
when the concept is used for mesh generation.}
\ccGlue
\ccNestedType{Surface_patch_index}{A type for indices of surface patches.
This type must match the type \ccc{MeshDomain_3::Surface_patch_index}
when the concept is used for mesh generation.}
\ccGlue
\ccNestedType{Index}{ A type for indexing vertices that belong to some surface patches
or subdomains.
This type must  match the type \ccc{MeshDomain_3::Index}
when the concept is used for mesh generation.}
% \ccType{typedef MeshCellBase_3::Subdomain_index Subdomain_index;}
% {Subdomain index type.}
% \ccGlue
% \ccTypedef{typedef MeshCellBase_3::Surface_patch_index Surface_patch_index;}
% {Surface index type.}
% \ccGlue
% \ccTypedef{typedef MeshVertexBase_3::Index Index;}
% {Index type.}


\ccNestedType{Cells_in_complex_iterator}{ An iterator type to visit the cells
of the triangulation belonging to the 3D complex.}
\ccGlue
\ccNestedType{Facets_in_complex_iterator}{An iterator type to visit the surface facets.}
% \ccGlue
% \ccNestedType{Edge_iterator}{An iterator type to visit  the
% edges of the 2D complex.}
% \ccGlue
% \ccNestedType{Vertex_iterator}{An iterator type to visit 
% vertices of the 2D complex.}


\ccCreation
\ccCreationVariable{c3t3}  %% choose variable name

\ccConstructor{MeshComplex_3InTriangulation_3();}
{Builds an empty 3D complex.}
\ccGlue
\ccConstructor{MeshComplex_3InTriangulation_3(const MeshComplex_3InTriangulation_3 & rhs);}
{Copy constructor. Embedded triangulation is duplicated.}

\ccMethod{MeshComplex_3InTriangulation_3& operator= (const MeshComplex_3InTriangulation_3 & rhs);}
{Assignment operator. Embedded triangulation is duplicated, and the former triangulation of \ccc{rhs} is deleted.}

\ccMethod{void swap(MeshComplex_3InTriangulation_3 & rhs);} 
{Swaps \ccVar\ and \ccc{rhs}.}


\ccAccessFunctions
\ccMethod{const Triangulation& triangulation() const;}
{Returns a const reference to the triangulation.}

\begin{ccAdvanced}
\ccHeading{Non const access}
The responsibility of keeping a valid C3T3 belongs to the user when using
advanced operations allowing a direct manipulation of the triangulation.

\ccMethod{Triangulation& triangulation();}
{Returns a reference to the triangulation.}
\end{ccAdvanced}

\ccModifiers

\ccMethod{void add_to_complex(Cell_handle c, Subdomain_index index);}
{Sets  the cell \ccc{c} as a cell of  the subdomain  \ccc{index}.}
\ccGlue
\ccMethod{void add_to_complex(Facet f, Surface_patch_index index);}
{Adds  the facet \ccc{f} as a facet of the surface patch  \ccc{index}.)}
\ccGlue
\ccMethod{void add_to_complex(Cell_handle c, int i, Surface_patch_index index);}
{Same as above with \ccc{f=(c,i)}.}

\ccMethod{void remove_from_complex(Cell_handle c);}{Removes cell \ccc{c} from the embedded complex.}
\ccGlue
\ccMethod{void remove_from_complex(Facet f);}
{Removes facet \ccc{f} from  the embedded complex.}
\ccGlue
\ccMethod{void remove_from_complex(Cell_handle c, int i);}
{Same as above with \ccc{f=(c,i)}.}

\ccMethod{void set_dimension(Vertex_handle v, int dimension);}
{Sets the  ``dimension''  of vertex \ccc{v}.  The dimension is an integer attached to the vertex.
When the concept \ccRefName\ is used for mesh generation this integer is used to store
the dimension of the  lowest dimensional face of the input complex including the vertex.}
\ccGlue
\ccMethod{void set_index(Vertex_handle v, Index index);}
{Sets the index of a vertex.}


\ccHeading{Queries}
Queries on the  faces of the embedded complex.

\ccMethod{size_type number_of_cells();}
{Returns the number of cells that belong to the embedded complex.}
\ccGlue
\ccMethod{size_type number_of_cells(Subdomain_index index);}
{Returns the number of cells that belong to the subdomain of the embedded complex with index \ccc{index}.}


\ccMethod{size_type number_of_facets();}
{Returns the number of facets that are surface facets, i. e. belong to some surface patch
of  the embedded complex.}
\ccGlue
\ccMethod{size_type number_of_facets(Surface_patch_index index);}
{Returns the number of facets that belong to the surface patch
of  the embedded complex with index \ccc{index}.}


% \ccMethod{Face_status face_status(Cell_handle c);}
% {Returns the status of the cell \ccc{c}  with respect to  the 3D complex.}
% \ccGlue
% \ccMethod{Face_status face_status(Facet f);}
% {Returns the status of the facet \ccc{f}  with respect to the 2D complex.}
% \ccGlue
% \ccMethod{Face_status face_status(Cell_handle c, int i);}
% {Same as above with \ccc{f=(c,i)}.}
% \ccGlue
% \ccMethod{Face_status face_status(Edge e);}
% {Returns the status of edge \ccc{e} in the 2D complex.}
% \ccGlue
% \ccMethod{Face_status face_status(Cell_handle c, int
% i, int j);}
% {Returns the status of edge \ccc{(c,i,j)} in the 2D complex.}
% \ccGlue
% \ccMethod{Face_status face_status(Vertex_handle v);}
% {Returns the status of vertex \ccc{v} in the 2D complex.}


\ccMethod{bool is_in_complex(Cell_handle c);}
{Returns \ccc{true} iff the cell \ccc{c} belongs to the 3D complex.}
\ccGlue
\ccMethod{bool is_in_complex(Facet f);}
{Returns \ccc{true} iff the facet \ccc{f} belongs to the boundary 2D complex.}
\ccGlue
\ccMethod{bool is_in_complex(Cell_handle c, int i);}
{Same as above with \ccc{f=(c,i)}.}
% \ccGlue
% \ccMethod{bool is_in_complex(Edge e);}
% {Returns \ccc{true}, if the edge  \ccc{e} belongs to the 2D complex.}
% \ccGlue
% \ccMethod{bool is_in_complex(Cell_handle c, int i, int j);}
% {Returns \ccc{true}, if the edge \ccc{(c,i,j)} belongs to the 2D complex.}
% \ccGlue
% \ccMethod{bool is_in_complex(Vertex_handle v);}
% {Returns \ccc{true}, if the vertex \ccc{v} belongs to the 2D complex.}


Queries on the identifier of the face complex 
including triangulation cells, facets and vertices.

\ccMethod{Subdomain_index subdomain_index(Cell_handle c);}
{Returns the index of the subdomain containing
  the cell \ccc{c}.
The default subdomain index is returned if the cell  \ccc{c} does not belong
to the embedded complex.}

\ccMethod{Surface_patch_index surface_patch_index(Facet f);}
{For a surface facet, returns  the index of the surface patch containing the facet.
The default \ccc{Surface_patch_index} value
is returned if the facet is not a surface facet.} 


\ccMethod{Surface_patch_index surface_patch_index(Cell_handle c, int i);}
{Same as above with \ccc{f=(c,i)}.}

\ccMethod{int in_dimension( Vertex_handle v) const;}{Returns the
  dimension of  the vertex \ccc{v}.}

\ccMethod{Index index(Vertex_handle v) const;}{Returns the index of
   the vertex \ccc{v}.}


\ccHeading{Traversal of the complex}

The data structure provides iterators to visit the cells and facets of the complex.
All those iterators are bidirectional and non mutable.

\ccMethod{Cells_in_complex_iterator cells_in_complex_begin();}
{Returns a \ccc{Cell_in_complex_iterator} to visit the cells of the triangulation contained in the embedded complex.}
\ccGlue
\ccMethod{Cells_in_complex_iterator cells_in_complex_end();}
{Returns the past-the-end iterator for the above iterator.}
\ccGlue
\ccMethod{Cells_in_complex_iterator cells_in_complex_begin(Subdomain_index index);}
{Returns a \ccc{Cell_in_complex_iterator} to visit the cells of the triangulation
which belong to the approximation of subdomain of index \ccc{index}.}
\ccGlue
\ccMethod{Cells_in_complex_iterator cells_in_complex_end(Subdomain_index index);}
{Returns the past-the-end iterator for the above iterator.}

\ccMethod{Facets_in_complex_iterator facets_in_complex_begin();}
{Returns a \ccc{Facet_in_complex_iterator} to visit the facets
in the surface patches of the embedded complexes.}
\ccGlue
\ccMethod{Facets_in_complex_iterator facets_in_complex_end();}
{Returns the  past-the-end iterator for the above iterator.}
\ccGlue
\ccMethod{Facets_in_complex_iterator facets_in_complex_begin(Surface_patch_index index);}
{Returns a \ccc{Facet_in_complex_iterator} to visit the facets
of the triangulation which which belong to the approximation of surface patch of index \ccc{index}.}
\ccGlue
\ccMethod{Facets_in_complex_iterator facets_in_complex_end(Surface_patch_index index);}
{Returns the  past-the-end iterator for the above iterator.}

% \ccMethod{Edge_iterator edges_begin();}
% {Returns an iterator with value type \ccc{Edge} to visit the
% edges of the 2D complex which are not isolated.}
% \ccGlue
% \ccMethod{Edge_iterator edges_end();}
% {Returns the past the end iterator for the above iterator.}

% \ccMethod{Vertex_iterator vertices_begin();}
% {Returns an iterator with value type \ccc{Vertex_handle} to visit the
% vertices of the 2D complex.}
% \ccGlue
% \ccMethod{Vertex_iterator vertices_end();}
% {Returns the past the end iterator for the above iterator.}


\ccHasModels
\ccc{CGAL::Mesh_complex_3_in_triangulation_3<Tr,CornerIndex,CurveSegmentIndex>}


\ccSeeAlso
\ccRefConceptPage{MeshDomain_3} \\
\ccRefConceptPage{MeshComplexWithFeatures_3InTriangulation_3} \\
\ccRefIdfierPage{CGAL::make_mesh_3}






\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

