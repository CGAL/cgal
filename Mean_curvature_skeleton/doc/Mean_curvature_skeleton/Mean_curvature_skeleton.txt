namespace CGAL {
/*!
\mainpage User Manual
\anchor Chapter_3D_Mean_Curvature_Skeleton

\cgalAutoToc
\author Andreas Fabri, Xiang Gao, Sébastien Loriot and Andrea Tagliasacchi

\todo clean up the algorithm description section and publish it

\section MCFSkelSecMot Introduction

\cgalFigureBegin{Main_image_suggestion, main_image_suggestion.png}
Curve skeleton of a horse model.
\cgalFigureEnd

Skeletons are effective shape abstractions used in segmentation, shape
matching, reconstruction, virtual navigation, etc. As the name
implies, a curve skeleton is a graph of curvilinear structures (1D),
that is it is not a medial axis that for 3D geometry is composed of surfaces (2D). As
illustrated in \cgalFigureRef{Main_image_suggestion}, the curve
skeleton of a shape captures its essential topology. In this package,
we implement the <i>Mean Curvature Skeleton</i> algorithm described in
\cgalCite{tagliasacchi2012mean} that extracts a curve skeleton from a
triangulated surface mesh without borders by iteratively contracting the
input triangulated surface mesh.

\section MCFSkelSecAPI User Interface Description

\subsection MCFSkelSecAPI-IO Input and Output

The input is a triangulated surface mesh, model of the `HalfedgeGraph`
concept that has no boundary and that has only one connected component.
The skeleton is provided as a graph of type
<a href="http://www.boost.org/doc/libs/release/libs/graph/doc/adjacency_list.html"><code>boost::adjacency_list</code></a>.
Each vertex of a the skeleton is associated a 3D location point and the
set of input vertices that contracted to that skeleton vertex.
Note that due the construction process of the skeleton, a
skeleton vertex might have no corresponding input vertex.

This package needs a sparse linear solver and we recommend the use of
\ref thirdpartyEigen 3.2 or later.

The input and output are illustrated in \cgalFigureRef{MCFInputOutput}.

\cgalFigureBegin{MCFInputOutput, correspondence.png}
Left: An input triangulated surface mesh model of an octopus;
Middle: The mean curvature flow skeleton extracted using this package;
Right: Each vertex of the input surface is associated a skeleton vertex.
\cgalFigureEnd

\subsection MCFSkelSecAPI-FF Free Function
If a \cgal model of the `HalfedgeGraph` concept such as
`CGAL::Surface_mesh` or `CGAL::Polyhedron_3` is used as triangulated
input surface mesh and \ref thirdpartyEigen 3.2 or later is available
and `CGAL_EIGEN3_ENABLED` is defined, the function
`CGAL::extract_mean_curvature_flow_skeleton()` can be used to
extract a mean curvature flow skeleton from the input surface mesh
using the default parameters, which work well in most cases.

The following example shows how to extract a skeleton out of a triangulated
surface mesh and how to access the point of each skeleton vertex and the
set of input vertices associated.

\cgalExample{Mean_curvature_skeleton/simple_mcfskel_example.cpp}


\subsection MCFSkelSecAPI-AUUFO Advanced Usage with the Function Object


The class `CGAL::Mean_curvature_flow_skeletonization` enables the
usage of low level functions such as \link
CGAL::Mean_curvature_flow_skeletonization::contract_geometry()
`contract_geometry()`\endlink and \link
CGAL::Mean_curvature_flow_skeletonization::collapse_edges()
`collapse_edges()`\endlink. The class further enables to change the
parameters of the algorithm, for example by calling \link
CGAL::Mean_curvature_flow_skeletonization::is_medially_centered()
`set_is_medially_centered()`\endlink.  The class gives the user full
control over each step of the algorithm as well as the intermediate
contracted mesh (called <i>meso-skeleton</i>) as illustrated by
\cgalFigureRef{MCFMesoSkel}.

\cgalFigureBegin{MCFMesoSkel, iterations.png}
Three iterations of the mean curvature flow contraction of the horse of
\cgalFigureRef{Main_image_suggestion}. The red points indicate
vertices where the surface has locally degenerated to a curvilinear
structure.
\cgalFigureEnd

In this example, we show how to use the API from
`CGAL::Mean_curvature_flow_skeletonization` class.

\cgalExample{Mean_curvature_skeleton/MCF_Skeleton_example.cpp}


\subsection Mesh Segmentation through Skeletonization
As a proof of concept, we show how to use the skeleton and the
association of input vertices to skeleton to compute a segmentation
of the input triangulated surface mesh using the package
\ref PkgSurfaceSegmentationSummary.
The segmentation algorithm consists in computing a <i>shape diameter function</i>
for each face of the input mesh, followed by solving a graph cut problem.
Here we use the skeleton to define a new shape diameter function.
Specifically, for each face we compute the diameter value as
the average distance between its three incident vertices and their
corresponding skeletal point.
The result of this segmentation is shown in \cgalFigureRef{Segmentation}.

\cgalFigureBegin{Segmentation, segmentation.png}
Left: Curve skeleton extracted of a triangulated surface mesh;
Right: Segmentation using the skeleton to compute a shape diamater function.
\cgalFigureEnd

\cgalExample{Mean_curvature_skeleton/segmentation_example.cpp}


\section MCFSkelSecEvaluation Performance

The elephant model is used to illustrate the performance of the
mean curvature flow skeletonization procedure.
Different resolutions of the model obtained by loop subdivision are used.

As can be seen on \cgalFigureRef{MCFBenchComp}, the more sampled is the
surface, the better the skeleton is inside the model.
The Voronoi poles computed may contain noise if the sampling is not dense enough.
As the mesh quality increases, the quality of the poles computed is
improved and so is the skeleton.

\cgalFigureBegin{MCFBenchComp, comparison.png}
Skeleton of the elephant model.
Left: Using the original mesh (2,775 vertices);
Middle: After one loop subdivision step (11,112 vertices);
Right: After two loop subdivision steps (44,460 vertices).
\cgalFigureEnd

Runtime in milliseconds of `extract_mean_curvature_flow_skeleton()` using
`CGAL::Polyhedron_3<Simple_cartesian<double> >`. The code was compiled with
clang version 4.1 with <code>-O3</code> as compiling flags and was run on a
Intel(R) Core(TM) i5-3427U CPU @ 1.80GHz


<center>
Number of vertices  | Runtime in ms |
--------------------| -----------:  |
2,775               |    1,097      |
11,112              |    3,595      |
44,460              |   14,841      |
</center>

\if SKIP_FOR_SBUMISSION

\section MCFSkelSecAlgo Algorithm Description

<em>Mean Curvature Flow</em> (MCF) is a motion where each point on the
surface is moved in a direction opposite to its normal with a speed
proportional to its mean curvature. Its use in skeletonization is
connected to its area minimization and anisotropic distortion
properties; see \cgalCite{tagliasacchi2012mean} for details. In curve
skeletonization, MCF is employed to iteratively contract (i.e. by
reducing its area) the mesh geometry until it locally
<em>degenerates</em> into a curve; see \cgalFigureRef{MCFMesoSkel}. The
contraction process halts when the surface area of the whole mesh has
vanished by checking if \f$ |\mathrm{area}_{i} - \mathrm{area}_{i-1}|
\lt \mathrm{delta\_area} \times \mathrm{original\_area}\f$ (\f$
\mathrm{area}_{i} \f$ is the area in iteration \f$ i \f$, default
value for \f$ \mathrm{delta\_area} \f$ is 0.0001). Upon convergence,
the mesh is then converted into a curve skeleton by a simple shortest
edge collapse procedure.

<b>Flow discretization and control.</b>
The MCF is discretized by finite elements (discrete Laplacian
operator) and solved by a sparse solver with factorization. After each
iteration, the local curvature changes and the weights in the
Laplacian operator need to be updated. A parameter `quality_speed_tradeoff()` is
provided to control the speed of the motion. By default the value is
set to 0.1. There is a tradeoff between speed and accuracy. With
higher `quality_speed_tradeoff()`, the algorithm converges quickly, however the result
is less accurate.

<b>Medial Centering.</b>
The curve skeletons extracted by MCF only are not guaranteed to
<em>lie medially</em> within the shape. To overcome this problem, the
flow can be augmented with an attraction force that pulls the geometry
toward the shape's medial axis. The algorithm employs a sampling of
the medial axis obtained by computing the <em>Voronoi poles</em> of
the input model. These poles are known to lie on the medial axis when
the surface is sufficiently densely sampled
\cgalCite{amenta2001power}. The density of the mesh also affect the
quality of poles. If the sampling of the mesh is not dense enough, the
poles tend to contain noise, and would lead to skeletons of bad
quality as can be seen in \cgalFigureRef{MCFBenchComp}. We provide the
user a parameter `medially_centered_speed_tradeoff()` to control the degree to which the surface
is attracted to the medial axis. Some initial experiments suggest
setting `medially_centered_speed_tradeoff()` to 0.1 or 0.2 is a good choice. The medial criteria
can also be turned off by calling \link
CGAL::Mean_curvature_flow_skeletonization::is_medially_centered()
`CGAL::Mean_curvature_flow_skeletonization::set_is_medially_centered(false)`\endlink.

<b>Local remeshing.</b>
While the anisotropic effects of MCF are essential for
curve-skeletonization, this has the side effect of progressively
degrading the quality of the triangulation. As a low quality
triangulation hinders the finite element discretization, we perform
local remeshing to remove these degeneracies. After each contraction
iteration we perform two local remeshing operations. We collapse edges
shorter than `min_edge_length()` and we split edges whose opposite
angle is greater than `max_triangle_angle()`. By default `min_edge_length()` is
set to 0.002 times the length of the diagonal of the bounding box of
the original mesh while `max_triangle_angle()` is \f$ 110 ^{\circ} \f$.

The flowchart of the algorithm is shown in
\cgalFigureRef{Flowchart}. In the remaining of this section, we
describe the details of each step in the iteration.

\cgalFigureBegin{Flowchart, flowchart.png}
A flow chart of the main algorithm.
\cgalFigureEnd

\subsection MCFSkelSecContra Mesh Contraction via Mean Curvature Flow

We formulate the MCF in an implicit form with the discrete Laplacian
operator \f$ L \f$. Since the Laplacian equation \f$ LV = 0 \f$ has a
trivial solution, the following regularized version is considered
instead:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}
  \end{array}\right]
  V^{t+1} =
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}
  \end{array}\right]
  \label{eq:regularized_equation}
\end{equation}
\f]

\f$ V^{t} \f$ is the vertex embedding in iteration \f$ t \f$. The
Laplacian operator \f$ L \f$ we use here is the classic cotangent
Laplacian operator introduced in \cgalCite{desbrun1999implicit}. \f$
W_{H} \f$ is a diagonal matrix, all diagonal elements being equal and
denoted as \f$ w_{H}\f$ which is a user parameter that controls the
speed of the MCF. Slowing down the MCF is essential since as the mesh
evolves, the local curvature changes and the Laplacian operator needs
to be updated to better approximate the mean curvature.

The effect of \f$ w_{H} \f$ is illustrated in \cgalFigureRef{WHeffect}.

\cgalFigureBegin{WHeffect, WHeffect.png}
From left to right, the \f$ w_{H} \f$ is 0.1, 0.05, 0.01, 0.005
respectively.  Note that setting \f$ w_{H} \f$ too small results in a low
quality of skeleton.  By default, the \f$ w_{H} \f$ is set to 0.1,
which works well in most cases.
\cgalFigureEnd

\subsection MCFSkelSecRemesh Local Dynamic Remeshing

As shown in \cgalCite{tagliasacchi2012mean}, the MCF moves the surface
points along the maximum principal curvature directions, which could
result in very high aspect ratio triangles that stiffens the finite
element solver. To address the problem, a local remeshing is performed
at each iteration by collapsing short edges and splitting bad
triangles while maintaining the manifold property.  Specifically, an
edge \f$ e \f$ is split if in an incident triangle, the angle at the
opposite vertex in the triangle is greater than \f$ 110^{\circ}
\f$. The split point is the perpendicular projection of the opposite
vertex onto \f$ e \f$.

\subsection MCFSkelSecDegeneracy Degeneracy Detection

As the mesh contraction process continues, the collapsed branches of
the shape would be pulled away from the medial axis and the tips of
the skeletal branches could be contracted back into the shape. We
would like to stop the movement of points in a branch when a branch is
detected. If we think of a branch as infinitesimal cross-sectional
manifold, in the discrete case the problem is reduced to monitor the
%Euler characteristic of a point within a infinitesimal geodesic
neighborhood. If the local neighborhood exhibits non-disk topology, we
think the point is degenerate and fix it by setting the corresponding
diagonal element in \f$ W_{H} \f$ to a very large number.


\subsection MCFSkelSecMedial Medial Skeletonization Flow

To compute a well-centered curve skeleton (i.e. one that lies close to
the medial axis) we modify Eq.\f$\eqref{eq:regularized_equation}\f$
to:

\f[
\begin{equation}
  \left[\begin{array}{c}
  L\\
  W_{H}\\
  W_{P}
  \end{array}\right]
  V^{t+1} =
  \left[\begin{array}{c}
  0\\
  W_{H}V^{t}\\
  W_{P}P^{t}
  \end{array}\right]
  \label{eq:medial_equation}
\end{equation}
\f]

where the \f$ W_{P} \f$ are weights to control the smoothness of the
medial approximation and \f$ P^{t} \f$ are the corresponding medial
poles for each vertex.  During the collapse in local remeshing, we
need to update the pole. In particular, we position the new vertex to
the middle point of the collapsed edge and choose the closest pole
from the poles of the two incident vertices of the edge.

\endif

\section MCFSkelSecDesign Design and Implementation History

The initial implementation of this package is the result of the work
of Xiang Gao during the 2013 season of the Google Summer of Code
mentored by Andrea Tagliasacchi and Sébastien Loriot. It was finalized
by Andreas Fabri and Sébastien Loriot.

*/
} /* namespace CGAL */

