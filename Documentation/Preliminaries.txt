/*!

\page Preliminaries

\author CGAL Editorial Board

This chapter lists the licenses
under which the \cgal datastructures and algorithms are distributed.
The chapter further explains how to control inlining, thread safety,
code deprecation, checking of pre- and postconditions,
and how to alter the failure behavior.

License Issues
==============

\cgal is distributed under a dual license scheme, that is under the
\sc{Gpl}/\sc{Lgpl} open source license, as well as under commercial licenses.

\cgal consists of different parts covered by different open source licenses.
In this section we explain the essence of the different licenses, as well as
the rationale why we have chosen them.

The fact that \cgal is Open Source software does not mean that users are free
to do whatever they want with the software. Using the software means to accept
the license, which has the status of a contract between the user and the owner
of the \cgal software.

\subsection licensesGPL GPL

The \sc{Gpl} is an Open Source license that, if you distribute your software
based on \sc{Gpl}ed \cgal data structures,you are obliged to distribute the
source code of your software under the \sc{Gpl}.

The exact license terms can be found at the  Free Software Foundation
web site: http://www.gnu.org/copyleft/gpl.html.

\subsection licensesLGPL LGPL

The \sc{Lgpl} is an Open Source license that obliges you to distribute
modifications you make on \cgal software accessible to the users.
In contrast to the \sc{Gpl} , there is no obligation to make the source
code of software you build on top of \sc{Lgpl}ed \cgal data structures

The exact license terms can be found at the Free Software Foundation web site:
http://www.gnu.org/copyleft/lesser.html.

Rationale of the License Choice
------------------------------

We have chosen the \sc{Gpl} and the \sc{Lgpl} as they are well known
and well understood open source licenses. The former restricts
commercial use, and the latter allows to promote software as de facto standard
so that people can build new higher level data structures on top.

Therefore, the packages forming a foundation layer are distributed under
the \sc{Lgpl}, and the higher level packages under the \sc{Gpl}.
The package overview states for each package under which license
it is distributed.

\subsection licensesCommercial Commercial Licenses

Users who cannot comply to the Open Source license terms can buy individual
data structures under various commercial licenses from GeometryFactory:
http://www.geometryfactory.com/.  License fees paid by commercial
customers are reinvested in R\&D performed by the \cgal project partners,
as well as in evolutive maintenance.

Marking of Special Functionality
================================

In this manual you will encounter sections marked as follows.

Advanced Features
-----------------

Some functionality is considered more advanced, for example because it is
relatively low-level, or requires special care to be properly used.

\advanced Such functionality is identified this way in the manual.

Debugging Support Features
--------------------------

Usually related to advanced features that for example may not guarantee
class invariants, some functionality is provided that helps debugging,
for example by performing invariants checks on demand.

\debug Such functionality is identified this way in the manual.

Deprecated Code
---------------

Sometimes, the \cgal project decides that a feature is deprecated.  This means
that it still works in the current release, but it will be removed in the next,
or a subsequent release.  This can happen when we have found a better way to do
something, and we would like to reduce the maintenance cost of \cgal at some
point in the future.  There is a trade-off between maintaining backward
compatibility and implementing new features more easily.

In order to help users manage the changes to apply to their code, we attempt
to make \cgal code emit warnings when deprecated code is used.  This can be
done using some compiler specific features.  Those warnings can be disabled
by defining the macro `CGAL_NO_DEPRECATION_WARNINGS`.  On top of this, we
also provide a macro, `CGAL_NO_DEPRECATED_CODE`, which, when defined,
disables all deprecated features.  This allows users to easily test if their
code relies on deprecated features.

\deprecated Such functionality is identified this way in the manual.

Namespace CGAL
==============

All names introduced by \cgal, especially those documented in these
manuals, are in a namespace called `CGAL`, which is in global
scope. A user can either qualify names from \cgal by adding
`CGAL::`, e.g., `CGAL::Point_2< CGAL::Exact_predicates_inexact_constructions_kernel >`,
make a single name from \cgal visible in a scope via a `using`
statement, e.g., `using CGAL::Point_2;`, and then use this name
unqualified in this scope, or even make all names from namespace
`CGAL` visible in a scope with `using namespace CGAL;`. The
latter, however, is likely to give raise to name conflicts and is
therefore not recommended.


Inclusion Order of Header Files
===============================

Not all compilers fully support standard header names. \cgal provides
workarounds for these problems in `CGAL/basic.h`. Consequently, as a
golden rule, you should always include `CGAL/basic.h` first in your
programs (or `CGAL/Cartesian.h`, or `CGAL/Homogeneous.h`, since they
include `CGAL/basic.h` first).


Thread Safety
=============

\cgal is progressively being made thread-safe.  The guidelines which are followed
are:

- it should be possible to use different objects in different threads at the same time (of the same type or not),
- it is not safe to access the same object from different threads at the same time, unless otherwise specified in the class documentation.

If the macro `CGAL_HAS_THREADS` is not defined, then \cgal assumes it can use
any thread-unsafe code (such as static variables).  By default, this macro is not
defined, unless `BOOST_HAS_THREADS` or `_OPENMP` is defined.  It is possible
to force its definition on the command line, and it is possible to prevent its default
definition by setting `CGAL_HAS_NO_THREADS` from the command line.


C++0x Support
=============

\cgal is based on the \CC\ standard released in 1998 (and later refined in 2003).
A new major version of this standard is being prepared, and is refered to as C++0x.
Some compilers and standard library implementations already provide some of the
functionality of this new standard, as a preview.  For example, \gcc\ provides
a command-line switch `-std=c++0x` which enables some of those features.

\cgal attempts to support this mode progressively, and already makes use of
some of these features if they are available, although no extensive support has
been implemented yet.

Functor Return Types
====================

\cgal functors support the
\ccAnchor{http://www.boost.org/doc/libs/release/libs/utility/utility.htm#result_of}{result\_of}
protocol. If a functor `F` has the same return type across all
overloads of `operator()`, the nested type
`F::result_type` is defined to be that type. Otherwise the
return type of calling the functor with an argument of type
`Arg` can be accessed through
`boost::result_of<F(Arg)>::type`.

\ccSetThreeColumns{Failure_behaviour }{}{\hspace*{8.5cm}}

\section secchecks Checks

Much of the \cgal code contains checks.
For example, all checks used in the kernel code are prefixed by
`CGAL_KERNEL`.
Other packages have their own prefixes, as documented in the corresponding
chapters.
Some are there to check if the kernel behaves correctly, others are there to
check if the user calls kernel routines in an acceptable manner.

There are five types of checks.
The first three are errors and lead to a halt of the program if they fail.
The fourth only leads to a warning, and the last one is compile-time only.

<DL>
<DT>Preconditions</DT>
<DD>
check if the caller of a routine has called it in a proper fashion.
If such a check fails it is the responsibility of the caller (usually the user of the library).
</DD>
<DT>Postconditions</DT>
<DD>
check if a routine does what it promises to do.
If such a check fails it is the fault of this routine, so of the library.
</DD>
<DT>Assertions</DT>
<DD>
are other checks that do not fit in the above two
categories.
</DD>
<DT>Warnings</DT>
<DD>
are checks for which it is not so severe if they fail.
</DD>
<DT>Static assertions</DT>
<DD>
are compile-time assertions, used e.g. to verify
the values of compile-time constants or compare types for (in)equality.
</DD>
</DL>

By default, all of these checks are performed.
It is however possible to turn them off through the use of compile time
switches.
For example, for the checks in the kernel code, these switches are the
following:
`CGAL_KERNEL_NO_PRECONDITIONS`,
`CGAL_KERNEL_NO_POSTCONDITIONS`,
`CGAL_KERNEL_NO_ASSERTIONS` and
`CGAL_KERNEL_NO_WARNINGS`.

So, in order to compile the file `foo.cpp` with the postcondition checks
off, you can do:

`CC -DCGAL_KERNEL_NO_POSTCONDITIONS foo.cpp`

This is also preferably done by modifying your makefile by adding
`-DCGAL_KERNEL_NO_POSTCONDITIONS` to the `CXXFLAGS` variable.

The name `KERNEL` in the macro name can be replaced by a package
specific name in order to control assertions done in a given package.
This name is given in the documentation of the corresponding package,
in case it exists.

Note that global macros can also be used to control the behavior over the
whole \cgal library:

- `CGAL_NO_PRECONDITIONS`,
- `CGAL_NO_POSTCONDITIONS`,
- `CGAL_NO_ASSERTIONS`,
- `CGAL_NO_WARNINGS` and
- `CGAL_NDEBUG`.


Setting the macro `CGAL_NDEBUG` disables all checks.
Note that the standard flag `NDEBUG` sets `CGAL_NDEBUG`, but it also
affects the standard `assert` macro.
This way, adding `-DCGAL_NDEBUG` to your compilation flags removes
absolutely all checks.  This is the default recommended setup for performing
timing benchmarks for example.

Not all checks are on by default.
The first four types of checks can be marked as expensive or exactness checks
(or both).
These checks need to be turned on explicitly by supplying one or both of
the compile time switches `CGAL_KERNEL_CHECK_EXPENSIVE` and
`CGAL_KERNEL_CHECK_EXACTNESS`.

Expensive checks are, as the word says, checks that take a considerable
time to compute.
Considerable is an imprecise phrase.
Checks that add less than 10 percent to the execution time of the routine
they are in are not expensive.
Checks that can double the execution time are.
Somewhere in between lies the border line.
Checks that increase the asymptotic running time of an algorithm are always
considered expensive.
Exactness checks are checks that rely on exact arithmetic.
For example, if the intersection of two lines is computed, the postcondition
of this routine may state that the intersection point lies on both lines.
However, if the computation is done with doubles as number type, this may not
be the case, due to round off errors.
So, exactness checks should only be turned on if the computation is done
with some exact number type.

By definition, static assertions are both inexpensive and unaffected by precision
management. Thus, the categories do not apply for static assertions.

Altering the Failure Behavior
----------------------------

As stated above, if a postcondition, precondition or assertion is
violated, an exception is thrown, and if nothing is done to catch it,
the program will abort.
This behavior can be changed by means of the following function.

\ccInclude{CGAL/assertions_behaviour.h}

\ccGlueBegin
\ccGlobalFunction{Failure_behaviour
set_error_behaviour(Failure_behaviour eb);}
\ccGlueEnd

The parameter should have one of the following values.

\ccGlobalEnum{enum Failure_behaviour
{ ABORT, EXIT, EXIT_WITH_SUCCESS, CONTINUE, THROW_EXCEPTION };}
The `THROW_EXCEPTION` value is the default, which throws an exception.

If the `EXIT` value is set, the program will stop and return a value
indicating failure, but not dump the core.
The `CONTINUE` value tells the checks to go on after diagnosing the error.
Note that since \cgal 3.4, `CONTINUE` has the same effect as
`THROW_EXCEPTION` for errors (but it keeps its meaning for warnings), it is
not possible anymore to let assertion failures simply continue (except by
totally disabling them).

\beginadvanced
If the `EXIT_WITH_SUCCESS` value is set, the program will stop and
return a value corresponding to successful execution and not dump the core.
\endadvanced

The value that is returned by `set_error_behaviour` is the value that was in use before.

For warnings there is a separate routine, which works in the same way.
The only difference is that for warnings the default value is
`CONTINUE`.

`Failure_behaviour set_warning_behaviour(Failure_behaviour eb);`

Control at a Finer Granularity
------------------------------

The compile time flags as described up to now all operate on the whole
library.
Sometimes you may want to have a finer control.
\cgal offers the possibility to turn checks on and off with a bit finer
granularity, namely the module in which the routines are defined.
The name of the module is to be appended directly after the \cgal prefix.
So, the flag `CGAL_KERNEL_NO_ASSERTIONS` switches off assertions in
the kernel only, the flag `CGAL_CH_CHECK_EXPENSIVE` turns on
expensive checks in the convex hull module.
The name of a particular module is documented with that module.

\beginadvanced

Customizing how Errors are Reported
-----------------------------------

Normally, error messages are written to the standard error output.
It is possible to do something different with them.
To that end you can register your own handler.
This function should be declared as follows.

`void my_failure_function( const char *type, const char *expression,
const char *file, int line, const char *explanation);`

Your failure function will be called with the following parameters.
`type` is a string that contains one of the words precondition,
postcondition, assertion or warning.
The parameter `expression` contains the expression that was violated.
`file` and `line` contain the place where the check was made.
The `explanation` parameter contains an explanation of what was
checked.
It can be `NULL`, in which case the `expression` is thought
to be descriptive enough.

There are several things that you can do with your own handler.
You can display a diagnostic message in a different way, for instance in
a pop up window or to a log file (or a combination).
You can also implement a different policy on what to do after an error.
For instance, you can throw an exception or ask the user in a dialog
whether to abort or to continue.
If you do this, it is best to set the error behavior to
`CONTINUE`, so that it does not interfere with your policy.

You can register two handlers, one for warnings and one for errors.
Of course, you can use the same function for both if you want.
When you set a handler, the previous handler is returned, so you can restore
it if you want.

\ref CGAL/assertions.h

- `Failure_function set_error_handler(Failure_function handler);`
- `Failure_function set_warning_handler(Failure_function handler);`

### Example ###

\code{.cpp}
#include <CGAL/assertions.h>

void my_failure_handler(
    const char *type,
    const char *expr,
    const char* file,
    int line,
    const char* msg)
{
    /* report the error in some way. */
}

void foo()
{
    CGAL::Failure_function prev;
    prev = CGAL::set_error_handler(my_failure_handler);
    /* call some routines. */
    CGAL::set_error_handler(prev);
}
\endcode

\endadvanced

\section seccgal_version Identifying the Version of CGAL

\ref CGAL/config.h

Every release of \cgal defines the following preprocessor macros:

<DL>
<DT>`CGAL_VERSION`</DT>
<DD> a textual description of the current release (e.g., or 3.3 or 3.2.1 or 3.2.1-I-15) </DD>
<DT>CGAL_VERSION_STR</DT>
<DD>same as `CGAL_VERSION` but as a string constant token</DD>
<DT>CGAL_VERSION_NR</DT>
<DD>
a numerical description of the current release such that more recent
releases have higher number.
More precisely, it is defined as `1MMmmbiiii`, where `MM` is
the major release number (e.g. 03), `mm` is the minor release
number (e.g. 02), `b` is the bug-fix release number (e.g. 0),
and `iiii` is the internal release number (e.g. 0001). For
public releases, the latter is defined as 1000.  Examples: for the
public release 3.2.4 this number is 1030241000; for internal release
3.2-I-1, it is 1030200001.  Note that this scheme was modified around
3.2-I-30.
</DD>
<DT>`CGAL_VERSION_NUMBER(M,m,b)`</DT>
<DD> a function macro computing the version number macro from the
M.m.b release version. Note that the internal release number is
dropped here. Example: `CGAL_VERSION_NUMBER(3,2,4)` is equal to
1030241000.
</DD>
<DL>

\beginadvanced

Compile-time Flags to Control Inlining
======================================

Making functions inlined can, at times, improve the efficiency of your code.
However this is not always the case and it can differ for a single function
depending on the application in which it is used. Thus \cgal defines a set
of compile-time macros that can be used to control whether certain functions
are designated as inlined functions or not.  The following table lists the
macros and their default values, which are set in one of the \cgal include
files.

| macro name                   | default |
| :---------                   | :------ |
| `CGAL_KERNEL_INLINE`         | inline  |
| `CGAL_KERNEL_MEDIUM_INLINE`  |         |
| `CGAL_KERNEL_LARGE_INLINE`   |         |
| `CGAL_MEDIUM_INLINE`         | inline  |
| `CGAL_LARGE_INLINE`          |         |
| `CGAL_HUGE_INLINE`           |         |

If you wish to change the value of one or more of these macros,
you can simply give it a new value when compiling.  For example, to make
functions that use the macro `CGAL_KERNEL_MEDIUM_INLINE` inline functions,
you should set the value of this macro to `inline` instead of the
default blank.

Note that setting inline manually is very fragile, especially in a template
context.  It is usually better to let the compiler select by himself which
functions should be inlined or not.

\endadvanced
