/*!

\page tuto_reconstruction Surface Reconstruction
\cgalAutoToc

\author Simon Giraudot

Surface reconstruction from point clouds is a wide research topic in
geometry processing and can be achieved in many different ways. This
tutorials explains how to use the different algorithms of \cgal to
perform reconstruction in the most relevant way.

\section TutorialsReconstruction_algorithms Which algorithm should I use?

\cgal offers three different algorithms for surface reconstruction:

- \ref Chapter_Poisson_Surface_Reconstruction "Poisson Surface Reconstruction"
- \ref Chapter_Advancing_Front_Surface_Reconstruction "Advancing Front Surface Reconstruction"
- \ref Chapter_Scale_space_reconstruction "Scale Space Surface Reconstruction"

Choosing one or the other of these methods is strongly dependent on
the input properties and the output requirement. For example, Poisson
always generates closed shapes (surrounding a volume) and requires
normals but does not interpolate input points (the output surface does
not pass exactly through the input points). The following table lists
different properties of the input and output to help you choose which
method is more suited for your work:

<center>
|                                          | Poisson | Advancing front  | Scale space      |
|------------------------------------------|:-------:|:----------------:|:----------------:|
| Are normals required?                    | Yes     | No               | No               |
| Is noise handled?                        | Yes     | By preprocessing | Yes              |
| Is variable sampling handled?            | Yes     | Yes              | By preprocessing |
| Are input points exactly on the surface? | No      | Yes              | Yes              |
| Is the output always closed?             | Yes     | No               | No               |
| Is the output always smooth?             | Yes     | No               | No               |
| Is the output always manifold?           | Yes     | Yes              | Optional         |
| Is the output always orientable?         | Yes     | Yes              | No               |
</center>

\cgalFigureBegin{TutorialsReconstructionFigComparisons, compare_reconstructions.png}

__Comparison of reconstruction methods applied to the same input (full shape and close-up).__

From left to right: original point cloud; poisson; advancing front; scale space.

\cgalFigureEnd

More information on these different methods can be found on their
respective manual pages and on section \ref TutorialsReconstruction_reconstruction.

\section TutorialsReconstruction_overview Pipeline Overview

This tutorial aims at providing a more comprehensive view of the
possibilities offered by \cgal for treating point clouds for surface
reconstruction purposes. The following diagram shows an overview of
typical reconstruction steps using \cgal tools.


\image html reconstruction.png "Pipeline Overview" 

We now review some of these steps in more details.


\section TutorialsReconstruction_input Reading Input

The reconstruction algorithms on \cgal take a range of iterators on a
container as input and use property maps to access the points (and the
normals if they are needed). Points are typically stored in plain text
format (denoted as 'xyz' format), each point separated by a newline
character and each coordinate separated by a white space. \cgal
provides functions to read such a format:

- `read_xyz_points()`
- `read_xyz_points_and_normals()`

Point may also be stored in an 'off' container, for which we also
provide function:

- `read_off_points()`
- `read_off_points_and_normals()`

Using these functions is pretty straightforward, as can be seen on the
following example:

\code{.cpp}
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/IO/read_xyz_points.h>

#include <vector>
#include <fstream>

// types
typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::Point_3 Point;

int main(int argc, char*argv[])
{
  std::vector<Point> points;

  char* filename = "my_file.xyz";
  std::ifstream stream(filename);
  
  if (!stream ||
      !CGAL::read_xyz_points(stream, std::back_inserter(points)))
  {
    std::cerr << "Error: cannot read file " << filename << std::endl;
    return -1;
  }
  
  std::cout << "Read " << points.size () << " point(s)" << std::endl;
\endcode


\section TutorialsReconstruction_preprocessing Preprocessing

Because reconstruction algorithms have some specific requirements that
point clouds do not always meet, some preprocessing might be necessary
to get the best results.

Note that this _preprocessing_ step is optional: if your input point
cloud is already well shaped, reconstruction may be directly applied
to it.

\subsection TutorialsReconstruction_preprocessing_outliers Outlier removal

Some acquisition techniques generate points that are far away from the
surface have no relevance for reconstruction. They are usually
referred to as 'outliers'. Using the \cgal reconstruction algorithms
on outlier-ridden point clouds produce overly distorted output, it is
therefore strongly advised to filter these outliers _before_
performing reconstruction.

\code{.cpp}
  // Identify outliers
  std::vector<Point>::iterator it
   = CGAL::remove_outliers (points.begin(), points.end(),
                            24, // Number of neighbors considered for evaluation
                            5.0); // Percentage of points to remove

  // Outlier removal function changes the order of the point container
  // and returns an iterator to the first point considered as outlier.
  // These points can either be ignored or removed.
  std::cout << std::distance (points.begin (), it)
	    << " point(s) are inliers." << std::endl;

  points.erase (it, points.end());
\endcode


\subsection TutorialsReconstruction_preprocessing_simplification Simplification

Some laser scanners generate points with widely variable
sampling. Typically, lines of scan are very densely sampled but the
gap between two lines of scan is much larger. This type of input point
cloud might generate badly shaped output for algorithms which, in
general, only accept small variations of sampling density.

\cgal provides several simplification algorithms. In addition to
reducing the size of the input and therefore decreasing computation
time, some of them can help making the input more uniform. This is the
case of the function `grid_simplify_point_set()` which defines a grid
of a user-specified size and only keeps one point per cell.

\code{.cpp}
  // Compute average spacing using neighborhood of 6 points
  double spacing = CGAL::average_spacing (points.begin (), points.end (), 6);

  // Simplify using a grid of size 2 * average spacing
  std::vector<Point>::iterator it
    = CGAL::grid_simplify_point_set (points.begin (), points.end (), 2. * spacing);

  // Simplification functions change the order of the point container
  // and return an iterator to the first point that is not part of the
  // simplified point set. These points can either be ignored or removed.
  std::cout << std::distance (points.begin (), it)
	    << " point(s) remaining after simplification." << std::endl;

  points.erase (it, points.end());
\endcode


\subsection TutorialsReconstruction_preprocessing_smoothing Smoothing

Although reconstructions via 'Poisson' or 'Scale space' handle noise
internally, one may want to get tighter control over the smoothing
step. For example, a slightly noisy point cloud can benefit from some
reliable smoothing algorithms and be reconstructed via 'Advancing
front' which provides interesting output properties (oriented mesh
with boundaries).

Two functions are provided to smooth a noisy point cloud with a good
approximation (i.e. without degrading curvature, for example):

- `jet_smooth_point_set()`
- `bilateral_smooth_point_set()`

These functions directly modify the container:

\code{.cpp}
  // Jet smoothing takes advantage of a larger neighborhood
  CGAL::jet_smooth_point_set (points.begin(), points.end(), 24);
\endcode

\subsection TutorialsReconstruction_preprocessing_normal Normal Estimation

\ref Chapter_Poisson_Surface_Reconstruction "Poisson Surface Reconstruction"
requires points with oriented normal vectors. To apply the algorithm
to a raw point cloud, normals must be estimated first with one of
these two functions:

- `pca_estimate_normals()`
- `jet_estimate_normals()`

PCA is faster but jet is more accurate in the presence of high
curvatures. These function only estimates the _direction_ of the
normals, not their orientation (the orientation of the vectors might
not be locally consistent). To properly orient the normals, the
function `mst_orient_normals()` can be used. Notice that it can also
be used directly on input normals if their orientation is not
consistent.

\code{.cpp}
  // Point with normal vector stored in a std::pair.
  typedef std::pair<Point, Vector> PointVectorPair;

  // Use a container with normals
  std::vector<PointVectorPair> points_with_normals;
  for (std::vector<Point>::iterator it = points.begin (); it != points.end (); ++ i)
    points_with_normals.push_back (std::make_pair (*it, Vector (0., 0., 0.)));

  CGAL::jet_estimate_normals(points_with_normals.begin(), points_with_normals.end(),
			     CGAL::First_of_pair_property_map<PointVectorPair>(),
			     CGAL::Second_of_pair_property_map<PointVectorPair>(),
			     24); // Use 24 neighbors

  // Orientation of normals, returns iterator to first unoriented point
  // (can be deleted
  std::vector<PointVectorPair>::iterator unoriented_points_begin =
    CGAL::mst_orient_normals(points_with_normals.begin(), points_with_normals.end(),
			     CGAL::First_of_pair_property_map<PointVectorPair>(),
			     CGAL::Second_of_pair_property_map<PointVectorPair>(),
			     24); // Use 24 neighbors

  points_with_normals.erase (unoriented_points_begin, points_with_normals.end ());
\endcode


\section TutorialsReconstruction_reconstruction Reconstruction

\subsection TutorialsReconstruction_reconstruction_poisson Poisson

Poisson reconstruction consists in computing an indicator function
whose gradient matches the input normal vector field: this indicator
function has opposite signs inside and outside of the inferred shape
(hence the need for closed shapes). This method thus requires normals
and produces smooth closed surfaces. It is not appropriate if the
surface is expected to pass exactly on the input points. On the
contrary, it performs well if the aim is to approximate a noisy point
cloud with a smooth surface.

Notice that it does not generate directly a mesh but computes an
_implicit function_ (that can later be used to generate a mesh):

\code{.cpp}
CGAL::Poisson_reconstruction_function<Kernel> function
  (points_with_normals.begin(), points_with_normals.end(),
   CGAL::make_first_of_pair_property_map(PointVectorPair()),
   CGAL::make_second_of_pair_property_map(PointVectorPair()));

if ( ! function.compute_implicit_function() ) 
  return -1;
\endcode

To produce a mesh out of this implicit function, the \cgal Mesher can
be used:

\code{.cpp}
    // Gets one point inside the implicit surface
    // and computes implicit function bounding sphere radius.
    Point inner_point = function.get_inner_point();
    Sphere bsphere = function.bounding_sphere();
    FT radius = std::sqrt(bsphere.squared_radius());

    // Defines the implicit surface: requires defining a
    // conservative bounding sphere centered at inner point.
    FT sm_sphere_radius = 1.5 * radius;
    FT sm_dichotomy_error = sm_distance*average_spacing/1000.0; // Dichotomy error must be << sm_distance
    Surface_3 surface(function,
                      Sphere(inner_point,sm_sphere_radius*sm_sphere_radius),
                      sm_dichotomy_error/sm_sphere_radius);

    // Defines surface mesh generation criteria
    CGAL::Surface_mesh_default_criteria_3<STr> criteria(sm_angle,  // Min triangle angle (degrees)
                                                        sm_radius*average_spacing,  // Max triangle size
                                                        sm_distance*average_spacing); // Approximation error


    // Generates surface mesh with manifold option
    STr tr; // 3D Delaunay triangulation for surface mesh generation
    C2t3 c2t3(tr); // 2D complex in 3D Delaunay triangulation
    CGAL::make_surface_mesh(c2t3,                                 // reconstructed mesh
                            surface,                              // implicit surface
                            criteria,                             // meshing criteria
                            CGAL::Manifold_with_boundary_tag());  // require manifold mesh

\endcode


\subsection TutorialsReconstruction_reconstruction_advancing Advancing Front

Advancing front is a Delaunay-based approach that generates triples of
point indices that describe the triangular facets of the
reconstruction: it uses a priority queue to sequentially pick the
Delaunay facet the most likely to be part of the surface, based on a
size criterion (to favor the small facets) and an angle criterion (to
favor smoothness). Its main asset is to generate oriented manifold
surfaces with boundaries: contrary to Poisson, it does not require
normals and is not bound to reconstruct closed shapes. However, it
requires preprocessing if the point is noisy.

The \ref Chapter_Advancing_Front_Surface_Reconstruction "Advancing Front"
package provides several ways of constructing the function. Here is
a simple example:

\code{.cpp}
typedef CGAL::cpp11::array<std::size_t,3> Facet; // Triple of indices
std::vector<Facet> facets;
CGAL::advancing_front_surface_reconstruction(points.begin(),
                                             points.end(),
                                             std::back_inserter(facets));
\endcode

\subsection TutorialsReconstruction_reconstruction_scale_space Scale Space

Scale space reconstruction aims at producing a surface that
interpolates the input points (interpolant) while offering some
robustness to noise. More specifically, it first applies several times
a smoothing filter to the input point set to produce a scale space;
then, the smoothest scale is meshed using an alpha shape; finally, the
resulting connectivity between smoothed points is propagated to the
original raw input point set. This method is the right choice if the
input point cloud is noisy but the user still wants the surface to
pass exactly through the points.

Notice that although there is an option to force the output to be
manifold, it is not guaranteed to be orientable (contrary to _Poisson_
and _Avdancing front_).

\code{.cpp}
CGAL::Scale_space_surface_reconstruction_3<Kernel> reconstruct
  (10, // Number of neighborhood points
   300); // Number of samples used to estimate neighborhood radius

reconstruct.reconstruct_surface(points.begin (), points.end (),
                                4, // Number of iterations
                                false, // Do not separate connected components
                                true); // Force manifold output
\endcode


\section TutorialsReconstruction_postprocessing Output and Postprocessing

Each of these methods produce a triangle mesh stored in different
ways. If this output mesh is not satisfactory enough, we provide
several algorithms to post-process it (hole filling, remeshing,
etc.) in the package \ref Chapter_PolygonMeshProcessing "Polygon Mesh Processing".

We do not discuss these functions here as there are many
postprocessing possibilities whose relevance strongly depend on the
user's expectations on the output mesh.

The mesh (postprocessed or not) can easily be saved in the OFF format:

\code{.cpp}
// Poisson
std::ofstream f ("out.off");
CGAL::output_facet_to_off(f, c2t3);
f.close ();
\endcode

\code{.cpp}
// Advancing Front
std::ofstream f ("out.off");
f << "OFF" << std::endl << points.size () << " " << facets.size () << " 0" << std::endl;

for (std::size_t i = 0; i < points.size (); ++ i) 
  f << points[i] << std::endl;

for (std::size_t i = 0; i < facets.size (); ++ i)
  {
    f << "3";
    for (std::size_t j = 0; j < 3; ++ j)
      f << " " << facets[i][j];
    f << std::endl;
  }

f.close ();
\endcode

\code{.cpp}
// Scale space
std::ofstream f ("out.off");
f << "OFF" << std::endl << points.size () << " " << facets.size () << " 0" << std::end;

for (std::size_t i = 0; i < points.size (); ++ i) 
  f << points[i] << std::endl;

typedef typename Scale_space_surface_reconstruction_3<Kernel>::Triple_iterator Triple_iterator;
for (Triple_iterator it = reconstruct.shell_begin (shell); it != reconstruct.shell_end (shell); ++it)
  out << "3 "<< *it << std::endl;

f.close ();
\endcode

\section TutorialsReconstruction_recap Full Code Example

All the code snippets used in this tutorial can be assembled to create
a full algorithm pipeline (provided the correct _includes_ are
used). We give a full code example which achieves the following steps:

- Reading an .xyz file
- Simplifying it
- Smoothing it
- Reconstructing it by advancing front
- Writing the output .off file

\code{.cpp}
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/IO/read_xyz_points.h>
#include <CGAL/compute_average_spacing.h>
#include <CGAL/grid_simplify_point_set.h>
#include <CGAL/jet_smooth_point_set.h>
#include <CGAL/Advancing_front_surface_reconstruction.h>

#include <vector>
#include <fstream>

// types
typedef CGAL::Exact_predicates_inexact_constructions_kernel Kernel;
typedef Kernel::Point_3 Point;
typedef CGAL::cpp11::array<std::size_t,3> Facet; // Triple of indices


int main(int argc, char*argv[])
{
  std::vector<Point> points;

  if (argc < 2)
    {
      std::cerr << "Usage: " << argv[0] << " [input.xyz] (output.off)" << std::endl;
      return -1;
    }

  const char* input_file = argv[1];
  std::ifstream stream (input_file);
  if (!stream ||
      !CGAL::read_xyz_points(stream, std::back_inserter(points)))
    {
      std::cerr << "Error: cannot read file " << input_file << std::endl;
      return -1;
    }
  
  std::cout << "Read " << points.size () << " point(s)" << std::endl;

  // Compute average spacing using neighborhood of 6 points
  double spacing = CGAL::compute_average_spacing (points.begin (), points.end (), 6);

  // Simplify using a grid of size 2 * average spacing
  std::vector<Point>::iterator it
    = CGAL::grid_simplify_point_set (points.begin (), points.end (), 2. * spacing);

  // Simplification functions change the order of the point container
  // and return an iterator to the first point that is not part of the
  // simplified point set. These points can either be ignored or removed.
  std::cout << std::distance (points.begin (), it)
	    << " point(s) remaining after simplification." << std::endl;

  points.erase (it, points.end());

  // Smoothing
  CGAL::jet_smooth_point_set (points.begin(), points.end(), 24);


  std::vector<Facet> facets;

  // Reconstruction
  CGAL::advancing_front_surface_reconstruction(points.begin(),
					       points.end(),
					       std::back_inserter(facets));
  std::cout << facets.size ()
	    << " facet(s) generated by reconstruction." << std::endl;
  

  const char* output_file = (argc > 2) ? argv[2] : "out.off";
  
  std::ofstream f (output_file);
  
  f << "OFF" << std::endl << points.size () << " " << facets.size () << " 0" << std::endl;

  for (std::size_t i = 0; i < points.size (); ++ i) 
    f << points[i] << std::endl;

  for (std::size_t i = 0; i < facets.size (); ++ i)
    {
      f << "3";
      for (std::size_t j = 0; j < 3; ++ j)
	f << " " << facets[i][j];
      f << std::endl;
    }

  f.close ();

  
  return 0;
}
\endcode




*/
