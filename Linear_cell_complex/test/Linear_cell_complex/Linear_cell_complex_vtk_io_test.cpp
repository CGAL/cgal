#include <CGAL/Linear_cell_complex_for_combinatorial_map.h>
#include <CGAL/Linear_cell_complex/IO/VTK.h>
#include <cassert>
#include <vector>
#include <cstdlib>

typedef CGAL::Linear_cell_complex_for_combinatorial_map<3, 3> LCC;

bool test_file(const char* filename)
{
  LCC lcc1, lcc2;
  std::vector<float>        vertex_scalars1, vertex_scalars2;
  std::vector<std::size_t>  volume_scalars1, volume_scalars2;

  bool res=CGAL::IO::read_VTK(lcc1, filename);
  if(!res)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK in test_file"<<std::endl;
    return false;
  }

  std::size_t nb_vertices=lcc1.number_of_vertex_attributes();
  vertex_scalars1.resize(nb_vertices);
  for(std::size_t i=0;i<nb_vertices;++i)
  { vertex_scalars1[i]=static_cast<float>(i); }

  std::size_t nb_volumes=0;
  for(auto itvol=lcc1.one_dart_per_cell<3>().begin(),
       itvolend=lcc1.one_dart_per_cell<3>().end(); itvol!=itvolend; ++itvol)
  { ++nb_volumes; }

  volume_scalars1.reserve(nb_volumes);
  for(auto itvol=lcc1.one_dart_per_cell<3>().begin(),
       itvolend=lcc1.one_dart_per_cell<3>().end(); itvol!=itvolend; ++itvol)
  {
    std::size_t nbv=lcc1.template one_dart_per_incident_cell<0,3>(itvol).size();
    volume_scalars1.push_back(nbv);
  }

  res=CGAL::IO::write_VTK(lcc1, "output.vtk",
                          &vertex_scalars1, &volume_scalars1);
  if(!res)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error write_VTK in test_file"<<std::endl;
    return false;
  }

  res=CGAL::IO::read_VTK(lcc2, "output.vtk",
                         &vertex_scalars2, &volume_scalars2);
  if(!res)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 2 in test_file"<<std::endl;
    return false;
  }

  if(!lcc1.is_isomorphic_to(lcc2, false, true, true))
  {
    std::cout<<"LCC1: ";
    lcc1.display_characteristics(std::cout)<<std::endl;
    std::cout<<"LCC2: ";
    lcc2.display_characteristics(std::cout)<<std::endl;
    std::cerr<<"[ERROR] LCC_vtk_io_test error lcc1 and lcc2 are not isomorphic in test_file"<<std::endl;
    res=false;
  }
  if(vertex_scalars1!=vertex_scalars2)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error vertex_scalars1 and vertex_scalars2 are different in test_file"<<std::endl;
    res=false;
  }
  if(volume_scalars1!=volume_scalars2)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error volume_scalars1 and volume_scalars2 are different in test_file"<<std::endl;
    res=false;
  }
  return res;
}

bool test_different_scalars()
{
  bool res=true;
  LCC lcc;
  std::vector<float>        vertex_scalars;
  std::vector<std::size_t>  volume_scalars;

  /// Read the last file generated by test_file("data/beam-with-mixed-cells.vtk")
  /// i.e. beam-with-mixed-cells.vtk with point and cells scalars.
  if(!CGAL::IO::read_VTK(lcc, "output.vtk",
                          &vertex_scalars, &volume_scalars) ||
      vertex_scalars.size()!=719 || volume_scalars.size()!=615)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK in test_different_scalars"<<std::endl;
    return false;
  }

  /// Test write with and without scalars
  if(!CGAL::IO::write_VTK(lcc, "output_vol.vtk", nullptr, &volume_scalars))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error write_VTK 1 in test_different_scalars"<<std::endl;
    return false;
  }

  if(!CGAL::IO::write_VTK(lcc, "output_vertex.vtk", &vertex_scalars))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error write_VTK 2 in test_different_scalars"<<std::endl;
    return false;
  }

  if(!CGAL::IO::write_VTK(lcc, "output_none.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error write_VTK 3 in test_different_scalars"<<std::endl;
    return false;
  }

  /// test read with only some scalars
  if(!CGAL::IO::read_VTK(lcc, "output.vtk", &vertex_scalars) ||
      vertex_scalars.size()!=719)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 2 in test_different_scalars"<<std::endl;
    return false;
  }

  if(!CGAL::IO::read_VTK(lcc, "output.vtk",
                          nullptr, &volume_scalars) ||
      volume_scalars.size()!=615)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 3 in test_different_scalars"<<std::endl;
    return false;
  }

  if(!CGAL::IO::read_VTK(lcc, "output.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 4 in test_different_scalars"<<std::endl;
    return false;
  }

  /// test read all scalars when they are not in the file
  if(!CGAL::IO::read_VTK(lcc, "output_vertex.vtk", &vertex_scalars, &volume_scalars) ||
      vertex_scalars.size()!=719 || volume_scalars.size()!=0)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 5 in test_different_scalars"<<std::endl;
    return false;
  }

  if(!CGAL::IO::read_VTK(lcc, "output_vol.vtk", &vertex_scalars, &volume_scalars) ||
      vertex_scalars.size()!=0 || volume_scalars.size()!=615)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 6 in test_different_scalars"<<std::endl;
    return false;
  }

  if(!CGAL::IO::read_VTK(lcc, "output_none.vtk", &vertex_scalars, &volume_scalars) ||
      vertex_scalars.size()!=0 || volume_scalars.size()!=0)
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error read_VTK 7 in test_different_scalars"<<std::endl;
    return false;
  }

  return res;
}

int main()
{
  bool res=true;
  if(!test_file("data/2tetra.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error for file data/2tetra.vtk"<<std::endl;
    res=false;
  }
  if(!test_file("data/2hexa.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error for file data/2hexa.vtk"<<std::endl;
    res=false;
  }
  if(!test_file("data/2prism.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error for file data/2prism.vtk"<<std::endl;
    res=false;
  }
  if(!test_file("data/2pyramid.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error for file data/2pyramid.vtk"<<std::endl;
    res=false;
  }
  if(!test_file("data/2generic_cell.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error for file data/2generic_cell.vtk"<<std::endl;
    res=false;
  }
  if(!test_file("data/beam-with-mixed-cells.vtk"))
  {
    std::cerr<<"[ERROR] LCC_vtk_io_test error for file data/beam-with-mixed-cells.vtk"<<std::endl;
    res=false;
  }

  if(!test_different_scalars())
  { res=false; }

  if(!res) { return EXIT_FAILURE; }

  std::cout<<"[OK] all tests in Linear_cell_complex_vtk_io_test.cpp"<<std::endl;
  return EXIT_SUCCESS;
}
