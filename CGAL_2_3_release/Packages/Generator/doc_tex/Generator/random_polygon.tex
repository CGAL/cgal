%% ==============================================================
%% Specification: Random Simple Polygons
%% --------------------------------------------------------------
%% author: Susan Hert
%% ==============================================================

\newpage

\ccParDims

\section{Random Simple Polygons}
\label{sec:random_simple_polygons}
\ccIndexMainItemBegin[c]{random simple polygon}
\ccIndexSubitemBegin[c]{generator}{simple polygon}

This section describes a function to compute a random simple polygon
from points that are drawn from a specific domain.

\ccInclude{CGAL/random_polygon_2.h}


\ccFunction{
template < class OutputIterator, class PointGenerator, class Traits > 
OutputIterator random_polygon_2( int n, OutputIterator result, 
                    const PointGenerator& pg, Traits t = Default_traits);
}
{
computes a random simple polygon by writing its vertices (oriented
counterclockwise) to \ccc{result}. The polygon generated will have a number
of vertices equal to the number of unique points in the first $n$ points
generated by \ccc{pg}. Though each simple polygon defined on this set of 
points has a non-zero probability of being constructed, some polygons may 
have higher probabilities than others.  The overall distribution of the
generated polygons is not known since it depends on the generated points.
}

\ccHeading{Preconditions}
\ccIndexSubitem[C]{random_polygon_2}{preconditions}
\begin{enumerate}
\item \ccc{Traits} satisfies the requirements stated in
      section \ref{req_random_polygon_2_traits} and \ccc{Traits::Point_2} 
      is the same as \ccc{PointGenerator::value_type},
\item \ccc{OutputIterator} accepts \ccc{PointGenerator::value_type} as its
      value type.
\end{enumerate}

%The default traits class \ccc{Default_traits} is
%\ccc{Random_polygon_traits_2}.%
%\ccIndexTraitsClassDefault{random_polygon_2}

\ccSeeAlso \ccc{Random_points_in_square_2} and
\ccc{Random_points_in_disc_2}.

\ccImplementation 
The implementation is based on the method of eliminating self-intersections in
a polygon by using so-called ``2-opt'' moves.  Such a move eliminates an 
intersection between two edges by reversing the order of the vertices between 
the edges.  No more than $O(n^3)$ such moves are required to simplify a polygon
defined on $n$ points \cite{ls-utstp-82}.
Intersecting edges are detected using a simple sweep through the vertices
and then one intersection is chosen at random to eliminate after each sweep. 
The worse-case running time is therefore $O(n^4 \log n)$.
\ccIndexMainItemEnd[c]{random simple polygon}
\ccIndexSubitemEnd[c]{generator}{simple polygon}

\ccExample

The following program displays a random simple polygon with up to 50
vertices, where the vertex coordinates are drawn uniformly from the 
unit square centered at the origin.

\ccIncludeExampleCode{Generator/random_poly_manual_demo.C}

\begin{ccAdvanced}
\ccAutoIndexingOff
\ccHtmlNoIndex\ccHtmlNoClassLinks\begin{ccClass}{Random_Polygon_Traits}
\ccCreationVariable{t}
\subsection{Requirements for Random Simple Polygon Traits Classes}
\label{req_random_polygon_2_traits}
\ccIndexSubitem[C]{random_polygon_2}{traits requirements}

\ccDefinition
A class \ccClassName\ has to provide the following type and operations in
order to qualify as a traits class for \ccc{random_polygon_2}.

\ccTypes
\ccNestedType{FT}{ The coordinate type of the points of the polygon 
                   ({\em i.e.}, a field type)}
\ccNestedType{Point_2}{The point type of the polygon.}
\ccNestedType{Vector_2}{The vector type that can be constructed from the
                        difference of two objects of type \ccc{Point_2}.}
\ccNestedType{Orientation_2}{orientation type}
\ccNestedType{Less_xy_2}
       {Binary predicate object type comparing \ccc{Point_2}s lexicographically.
        It must provide \ccc{bool operator()(Point_2 p, Point_2 q)} that 
        returns \ccc{true} iff $p <_{xy} q$.
        We have $p<_{xy}q$, iff $p_x < q_x$ or $p_x = q_x$ and $p_y < q_y$,
        where $p_x$ and $p_y$ denote the $x$ and $y$ coordinates of point $p$,
        resp.
       }
\ccNestedType{Less_yx_2} 
       {Same as \ccc{Less_xy_2} with the roles of $x$ and $y$ reversed.}
                        

\ccOperations

\ccMemberFunction{ Less_xy_2 less_xy_2_object();}{}
\ccMemberFunction{ Orienation_2 orientation_2_object();}{}

\ccMemberFunction{
    Comparison_result compare_x(const Point_2 &p, const Point_2 &q) const;
}
{
\lcTex{
Returns
$
  \left\{
  \begin{array}{lll}
     \ccStyle{SMALLER} & \mbox{if} & p_x < q_x \\
     \ccStyle{EQUAL}   & \mbox{if} & p_x = q_x \\
     \ccStyle{LARGER}  & \mbox{if} & p_x > q_x
  \end{array}
  \right.%}
$
}
\lcHtml{
Returns SMALLER if p_x < q_x, EQUAL if p_x = q_x and LARGER if p_x > q_x
}
}



\ccMemberFunction{
    Comparison_result compare_y(const Point_2 &p, const Point_2 &q) const;
}
{
\lcTex{
Returns
$
  \left\{
  \begin{array}{lll}
     \ccStyle{SMALLER} & \mbox{if} & p_y < q_y \\
     \ccStyle{EQUAL}   & \mbox{if} & p_y = q_y \\
     \ccStyle{LARGER}  & \mbox{if} & p_y > q_y
  \end{array}
  \right.%}
$
}
\lcHtml{
Returns SMALLER if p_y < q_y, EQUAL if p_y = q_y and LARGER if p_y > q_y
}
}

\ccMemberFunction{
    FT cross_product_2(const Vector_2& p, const Vector_2& q) const;
}
{
Returns $p_x q_y - p_y q_x$.
}
\ccMemberFunction{
    bool do_intersect(const Point_2& p1,
                      const Point_2& q1,
                      const Point_2& p2,
                      const Point_2& q2) const;
}
{
Returns \ccc{true} iff the segments \ccStyle{[p1,q1]} and \ccStyle{[p2,q2]} 
intersect.
}

\ccMemberFunction{
    bool have_equal_direction(const Vector_2& v1,
                              const Vector_2& v2 ) const;
}
{
Returns \ccc{true} iff the vectors \ccStyle{v1} and \ccStyle{v2} have the
same direction.
}

\ccMemberFunction{
    bool is_negative(const FT& x) const;
}
{
Returns \ccStyle{true} iff \ccStyle{x<0}.
}

\ccMemberFunction{
    bool lexicographically_yx_smaller_or_equal(const Point_2& p,
                                               const Point_2& q) const;
}
{
Returns \ccc{true} iff $p_y \leq q_y$ or $p_y = q_y$ and $p_x \leq q_x$.
}


\end{ccClass}
\ccAutoIndexingOn
\end{ccAdvanced}
