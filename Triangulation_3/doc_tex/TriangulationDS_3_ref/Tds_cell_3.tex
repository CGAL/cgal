% +------------------------------------------------------------------------+
% | Reference manual page: Tds_cell_3.tex
% +------------------------------------------------------------------------+
% | 29.3.2000   Monique Teillaud
% | Package: Triangulation3
% | 
\RCSdef{\RCSTdscellRev}{$Id$}
\RCSdefDate{\RCSTdscellDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefConcept}[TriangulationDataStructure_3::]{Cell}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
The concept \ccRefName\ stores
four \ccc{Vertex_handle}s to its four vertices and four \ccc{Cell_handle}s
to its four neighbors. The vertices are indexed 0, 1, 2, and 3 in consistent
order.  The neighbor indexed $i$ lies opposite to vertex \ccc{i}.

In degenerate dimensions, cells are used to store faces of maximal
dimension: in dimension~2, each cell represents only one
facet of index 3, and 3 edges $(0,1)$, $(1,2)$ and $(2,0)$; in
dimension~1, each cell represents one edge $(0,1)$. (See also
Section~\ref{TDS3-sec-intro}.) 

\ccTypes
\ccThree{typedef TriangulationDataStructure_3::Vertex_handle}{Facet }{}
\ccThreeToTwo
The class \ccRefName\ defines the following types.

\ccTypedef{typedef TriangulationDataStructure_3 Triangulation_data_structure;}{}
\ccGlue
\ccTypedef{typedef TriangulationDataStructure_3::Vertex_handle Vertex_handle;}{}
\ccGlue
\ccTypedef{typedef TriangulationDataStructure_3::Cell_handle Cell_handle;}{}

\ccCreation
\ccCreationVariable{c}  %% choose variable name
\ccThree{Vertex_handle}{c.set_vertices(Vertex_handle v)xxxxxxx;}{}

In order to obtain new cells or destruct unused cells, the user must call the
\ccc{create_cell()} and \ccc{delete_cell()} methods of the triangulation data
structure.

\ccOperations

\ccAccessFunctions

\ccMethod{Vertex_handle vertex(int i) const;}
{Returns the vertex \ccc{i} of \ccVar.
\ccPrecond{$i \in \{0, 1, 2, 3\}$.}}
\ccGlue
\ccMethod{int index(Vertex_handle v) const;}
{Returns the index of vertex \ccc{v} in \ccVar.
\ccPrecond{\ccc{v} is a vertex of \ccVar}.}
\ccGlue
\ccMethod{bool has_vertex(Vertex_handle v) const;}
{Returns \ccc{true} if  \ccc{v} is a vertex of \ccVar.}
\ccGlue
\ccMethod{bool has_vertex(Vertex_handle v, int & i) const;}
{Returns \ccc{true} if \ccc{v} is a vertex of \ccVar, and
computes its index \ccc{i} in \ccVar.}

\ccMethod{Cell_handle neighbor(int i) const;}
{Returns  the neighbor \ccc{i} of \ccVar.
\ccPrecond{$i \in \{0, 1, 2, 3\}$.}}
\ccGlue
\ccMethod{int index(Cell_handle n) const;}
{Returns the index corresponding to neighboring cell \ccc{n}.
\ccPrecond{\ccc{n} is a neighbor of \ccVar.}}
\ccGlue
\ccMethod{bool has_neighbor(Cell_handle n) const;}
{Returns \ccc{true} if \ccc{n} is a neighbor of \ccVar.}
\ccGlue
\ccMethod{bool has_neighbor(Cell_handle n, int & i) const;}
{Returns \ccc{true} if \ccc{n} is a neighbor of \ccVar,  and
computes its index \ccc{i} in \ccVar.}

\ccHeading{Setting}

\ccMethod{void set_vertex(int i, Vertex_handle v);}
{Sets vertex \ccc{i} to \ccc{v}.
\ccPrecond{$i \in \{0, 1, 2, 3\}$.}}
\ccGlue
\ccMethod{void set_vertices(Vertex_handle v0,
			Vertex_handle v1,
		    	Vertex_handle v2,
		    	Vertex_handle v3);}
{Sets the vertex pointers.}

\ccMethod{void set_neighbor(int i, Cell_handle n);}
{Sets neighbor \ccc{i} to \ccc{n}.
\ccPrecond{$i \in \{0, 1, 2, 3\}$.}}
\ccGlue
\ccMethod{void set_neighbors(Cell_handle n0,
			     Cell_handle n1,
			     Cell_handle n2,
			     Cell_handle n3);}
{Sets the neighbors pointers.}

\begin{ccDebug}
\ccHeading{Checking}
\ccThree{Vertex_handle}{c.set_vertices(v);}{}

\ccMethod{bool is_valid(bool verbose = false, int level = 0) const;}
{User defined local validity checking function.}
\end{ccDebug}

\ccSeeAlso

\ccc{TriangulationDataStructure_3::Vertex}.

\end{ccRefConcept}
