\begin{ccRefClass}{Filtered_exact<CT, ET>} %, Cache_t = No_Filter_Cache>}
%\subsection{Robust filtered predicates}
\label{filter}


\ccDefinition


The class \ccc{Filtered_exact<CT,ET>} is a wrapper type for the number
type \ccc{CT}, with the difference
that all predicates are specialized such that they are guaranteed to be exact.
Speed is achieved via a filtering scheme using interval arithmetic (see
Section~\ref{interval-adv}).  Here are the necessary requirements:

\begin{itemize}
\item \ccc{CT} is the construction and storage type.  The only data member of
      the class \ccc{Filtered_exact<CT,ET>} is the \ccc{value} of type
      \ccc{CT}.  All arithmetic operations performed {\em outside} of the
      predicates will be executed with this number type.  You can disallow
      these operations compiling with the flag
      \ccc{CGAL_DENY_INEXACT_OPERATIONS_ON_FILTER} (it allows you
      to spot the inexact operations that should be incorporated in the
      predicates).
      The arithmetic operations called from inside the predicates are always
      computed exactly.
\item The \ccc{ET} type must be able to compute exactly the operations involved
      in the predicates called.
\item A \ccc{to_interval(CT)} function must
      be provided, that returns an interval containing the value of the
      argument of type \ccc{CT}, see Section~\ref{interval}.
\item A \ccc{convert_to<ET>(CT)} function must also be provided, that
      returns a number of type \ccc{ET} representing exactly the argument of
      type \ccc{CT}.  It's a conversion function that is used for the exact
      computation, when the filter fails.
      This conversion has to be done exactly to ensure robustness.
\end{itemize}

\ccInclude{CGAL/Filtered_exact.h}

\ccIsModel
FieldNumberType

\ccCreationVariable{ntvar}
\ccOperations

The following member functions are used to access the numerical value for the
different number types:

\ccMethod{CT value();} {returns the wrapped value.}
\ccMethod{ET exact();} {returns the converted value to \ccc{ET}.}
\ccMethod{Interval_nt_advanced interval();} {returns the converted value
                                             to \ccc{Interval_nt_advanced}.}

% For efficiency reasons, the conversion of the \ccc{value} to an
% \ccc{Interval_nt_advanced} may be cached using \ccc{Filter_Cache} as
% optionnal third template parameter of the class.  This is only wishful if
% \ccc{CT} is a complicated type for which the conversion to an interval takes
% a somewhat long time, and is asked for the same variable several times.  You
% might want to experiment with this feature, depending on your needs.

This type actually has additional parameters for experimental features.  They
will be documented when they will be considered stable, in a next release.

\ccExample

You might use at the beginning of your program a \ccc{typedef} as follows:

\begin{verbatim}
    #include<CGAL/Filtered_exact.h>
    #include<CGAL/leda_real.h>
    #include<CGAL/double.h>
    typedef Filtered_exact<double, leda_real> NT;
\end{verbatim}

Or if you are sure that the predicates involved do not use divisions nor
square roots:

\begin{verbatim}
    #include<CGAL/Filtered_exact.h>
    #include<CGAL/Gmpz.h>
    #include<CGAL/int.h>
    typedef Filtered_exact<int, Gmpz> NT;
\end{verbatim}

And if you know that the double variables contain integer values, you can
use:

\begin{verbatim}
    #include<CGAL/Filtered_exact.h>
    #include<CGAL/Gmpz.h>
    #include<CGAL/double.h>
    typedef Filtered_exact<double, Gmpz> NT;
\end{verbatim}

As a general rule, we advise the use of
\ccc{Filtered_exact<double, leda_real>}.

% If you need exact computations also outside the predicates, you can use the
% following:
% 
% \begin{verbatim}
    % #include<CGAL/Filtered_exact.h>
    % #include<CGAL/lera_real.h>
    % typedef Filtered_exact<leda_real, leda_real, Filter_Cache> NT;
% \end{verbatim}


\ccImplementation

The template definition of the low level predicates of {\cgal} are overloaded
for the type \ccc{Filtered_exact<CT,ET>}.  It is a partial specialisation,
which implies that this is not supported by the compilers that do not support
correctly this C++ feature (for which we set \ccc{CGAL_CFG_MATCHING_BUG_2}).
A workaround is in place that allows you to use
one such filtered number type at once, by explicitely fully specializing the
predicates for it.  To do so, just define the macros \ccc{CGAL_IA_CT} and
\ccc{CGAL_IA_ET} to the corresponding number types before any inclusion of
{\cgal} files, as well as \ccc{CGAL_IA_CACHE}.  For example~:

\begin{verbatim} 
#define CGAL_IA_CT double
#define CGAL_IA_ET leda_real
#define CGAL_IA_CACHE No_Filter_Cache
#define CGAL_IA_PROTECTED true
\end{verbatim}

Note that you may run into other problems if you use Visual C++.  We recommend
that you use \ccc{Filtered_kernel} if you run into compilation problems with
Visual C++.

For each predicate file, the overloaded code is generated automatically by a
\ccc{PERL} script (\ccc{scripts/filtered_predicates_generator.pl}) that you can
use for your own predicates.
This script parses the template functions and generates the
overloaded code the following way:
\begin{itemize}
\item convert the entries to intervals using
    \ccc{to_interval(CT)}, via the \ccc{interval()} member function,
\item call the original template function with the type
    \ccc{Interval_nt_advanced},
\item if no exception is thrown, return the value,
\item if an exception is thrown (the filter failed), convert the original
    entries using \ccc{convert_to<ET>(CT)}, using the \ccc{exact()} member
    function,
\item and call the original template function with the type \ccc{ET}.
\end{itemize}

\ccExample

The low level template predicates of {\cgal} are in files named
\ccc{CGAL/predicates/kernel_ftC2.h} (resp. ftC3), the script is used
to produce the files \ccc{CGAL/Arithmetic_filter/predicates/kernel_ftC2.h}
(resp. ftC3).

At the moment, only the predicates of the Cartesian and Simple\_cartesian
kernels are supported, as well as the power tests used by the regular
triangulations.

\end{ccRefClass}
