// ======================================================================
//
// Copyright (c) 1998 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// source        : 
// file          : include/CGAL/Arithmetic_filter/predicates_on_rtH2.h
// package       : Interval_arithmetic
// revision      : 1.2.3
// revision_date :
// author(s)     : Sylvain.Pion@sophia.inria.fr
//
// coordinator   : MPI, Saarbruecken
// ======================================================================


#ifndef CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H
#define CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H

// This file is automatically generated with the script for filtering
// predicates, using Interval arithmetic.

#include <CGAL/Interval_arithmetic.h>

template < class CT, class ET >
// CGAL_KERNEL_MEDIUM_INLINE
CGAL_Orientation
CGAL_orientationH2( const CGAL_Filtered_exact<CT,ET>& phx,
	const CGAL_Filtered_exact<CT,ET>& phy,
	const CGAL_Filtered_exact<CT,ET>& phw,
	                    const CGAL_Filtered_exact<CT,ET>& qhx,
	const CGAL_Filtered_exact<CT,ET>& qhy,
	const CGAL_Filtered_exact<CT,ET>& qhw,
	                    const CGAL_Filtered_exact<CT,ET>& rhx,
	const CGAL_Filtered_exact<CT,ET>& rhy,
	const CGAL_Filtered_exact<CT,ET>& rhw )
{ // This is the default filter (specialisation).

  typedef CGAL_Interval_nt_advanced IA;

  CGAL_Orientation result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = CGAL_orientationH2(
		CGAL_convert_to<IA>(phx.value),
		CGAL_convert_to<IA>(phy.value),
		CGAL_convert_to<IA>(phw.value),
		CGAL_convert_to<IA>(qhx.value),
		CGAL_convert_to<IA>(qhy.value),
		CGAL_convert_to<IA>(qhw.value),
		CGAL_convert_to<IA>(rhx.value),
		CGAL_convert_to<IA>(rhy.value),
		CGAL_convert_to<IA>(rhw.value));
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = CGAL_orientationH2(
		CGAL_convert_to<ET>(phx.value),
		CGAL_convert_to<ET>(phy.value),
		CGAL_convert_to<ET>(phw.value),
		CGAL_convert_to<ET>(qhx.value),
		CGAL_convert_to<ET>(qhy.value),
		CGAL_convert_to<ET>(qhw.value),
		CGAL_convert_to<ET>(rhx.value),
		CGAL_convert_to<ET>(rhy.value),
		CGAL_convert_to<ET>(rhw.value));
  }
  return result;
}

template < class CT, class ET >
// CGAL_KERNEL_MEDIUM_INLINE
bool
CGAL_leftturnH2( const CGAL_Filtered_exact<CT,ET>& phx,
	const CGAL_Filtered_exact<CT,ET>& phy,
	const CGAL_Filtered_exact<CT,ET>& phw,
	                 const CGAL_Filtered_exact<CT,ET>& qhx,
	const CGAL_Filtered_exact<CT,ET>& qhy,
	const CGAL_Filtered_exact<CT,ET>& qhw,
	                 const CGAL_Filtered_exact<CT,ET>& rhx,
	const CGAL_Filtered_exact<CT,ET>& rhy,
	const CGAL_Filtered_exact<CT,ET>& rhw )
{ // This is the default filter (specialisation).

  typedef CGAL_Interval_nt_advanced IA;

  bool result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = CGAL_leftturnH2(
		CGAL_convert_to<IA>(phx.value),
		CGAL_convert_to<IA>(phy.value),
		CGAL_convert_to<IA>(phw.value),
		CGAL_convert_to<IA>(qhx.value),
		CGAL_convert_to<IA>(qhy.value),
		CGAL_convert_to<IA>(qhw.value),
		CGAL_convert_to<IA>(rhx.value),
		CGAL_convert_to<IA>(rhy.value),
		CGAL_convert_to<IA>(rhw.value));
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = CGAL_leftturnH2(
		CGAL_convert_to<ET>(phx.value),
		CGAL_convert_to<ET>(phy.value),
		CGAL_convert_to<ET>(phw.value),
		CGAL_convert_to<ET>(qhx.value),
		CGAL_convert_to<ET>(qhy.value),
		CGAL_convert_to<ET>(qhw.value),
		CGAL_convert_to<ET>(rhx.value),
		CGAL_convert_to<ET>(rhy.value),
		CGAL_convert_to<ET>(rhw.value));
  }
  return result;
}

template < class CT, class ET >
// CGAL_KERNEL_MEDIUM_INLINE
bool
CGAL_rightturnH2(const CGAL_Filtered_exact<CT,ET>& phx,
	const CGAL_Filtered_exact<CT,ET>& phy,
	const CGAL_Filtered_exact<CT,ET>& phw,
	                 const CGAL_Filtered_exact<CT,ET>& qhx,
	const CGAL_Filtered_exact<CT,ET>& qhy,
	const CGAL_Filtered_exact<CT,ET>& qhw,
	                 const CGAL_Filtered_exact<CT,ET>& rhx,
	const CGAL_Filtered_exact<CT,ET>& rhy,
	const CGAL_Filtered_exact<CT,ET>& rhw )
{ // This is the default filter (specialisation).

  typedef CGAL_Interval_nt_advanced IA;

  bool result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = CGAL_rightturnH2(
		CGAL_convert_to<IA>(phx.value),
		CGAL_convert_to<IA>(phy.value),
		CGAL_convert_to<IA>(phw.value),
		CGAL_convert_to<IA>(qhx.value),
		CGAL_convert_to<IA>(qhy.value),
		CGAL_convert_to<IA>(qhw.value),
		CGAL_convert_to<IA>(rhx.value),
		CGAL_convert_to<IA>(rhy.value),
		CGAL_convert_to<IA>(rhw.value));
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = CGAL_rightturnH2(
		CGAL_convert_to<ET>(phx.value),
		CGAL_convert_to<ET>(phy.value),
		CGAL_convert_to<ET>(phw.value),
		CGAL_convert_to<ET>(qhx.value),
		CGAL_convert_to<ET>(qhy.value),
		CGAL_convert_to<ET>(qhw.value),
		CGAL_convert_to<ET>(rhx.value),
		CGAL_convert_to<ET>(rhy.value),
		CGAL_convert_to<ET>(rhw.value));
  }
  return result;
}

template < class CT, class ET >
// CGAL_KERNEL_MEDIUM_INLINE
bool
CGAL_collinearH2(const CGAL_Filtered_exact<CT,ET>& phx,
	const CGAL_Filtered_exact<CT,ET>& phy,
	const CGAL_Filtered_exact<CT,ET>& phw,
	                 const CGAL_Filtered_exact<CT,ET>& qhx,
	const CGAL_Filtered_exact<CT,ET>& qhy,
	const CGAL_Filtered_exact<CT,ET>& qhw,
	                 const CGAL_Filtered_exact<CT,ET>& rhx,
	const CGAL_Filtered_exact<CT,ET>& rhy,
	const CGAL_Filtered_exact<CT,ET>& rhw )
{ // This is the default filter (specialisation).

  typedef CGAL_Interval_nt_advanced IA;

  bool result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = CGAL_collinearH2(
		CGAL_convert_to<IA>(phx.value),
		CGAL_convert_to<IA>(phy.value),
		CGAL_convert_to<IA>(phw.value),
		CGAL_convert_to<IA>(qhx.value),
		CGAL_convert_to<IA>(qhy.value),
		CGAL_convert_to<IA>(qhw.value),
		CGAL_convert_to<IA>(rhx.value),
		CGAL_convert_to<IA>(rhy.value),
		CGAL_convert_to<IA>(rhw.value));
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = CGAL_collinearH2(
		CGAL_convert_to<ET>(phx.value),
		CGAL_convert_to<ET>(phy.value),
		CGAL_convert_to<ET>(phw.value),
		CGAL_convert_to<ET>(qhx.value),
		CGAL_convert_to<ET>(qhy.value),
		CGAL_convert_to<ET>(qhw.value),
		CGAL_convert_to<ET>(rhx.value),
		CGAL_convert_to<ET>(rhy.value),
		CGAL_convert_to<ET>(rhw.value));
  }
  return result;
}
template < class CT, class ET >
// CGAL_KERNEL_MEDIUM_INLINE
CGAL_Bounded_side
CGAL_side_of_bounded_circleH2( const CGAL_Filtered_exact<CT,ET>& qhx,
	const CGAL_Filtered_exact<CT,ET>& qhy,
	const CGAL_Filtered_exact<CT,ET>& qhw,
	                               const CGAL_Filtered_exact<CT,ET>& rhx,
	const CGAL_Filtered_exact<CT,ET>& rhy,
	const CGAL_Filtered_exact<CT,ET>& rhw,
	                               const CGAL_Filtered_exact<CT,ET>& shx,
	const CGAL_Filtered_exact<CT,ET>& shy,
	const CGAL_Filtered_exact<CT,ET>& shw,
	                               const CGAL_Filtered_exact<CT,ET>& thx,
	const CGAL_Filtered_exact<CT,ET>& thy,
	const CGAL_Filtered_exact<CT,ET>& thw )
{ // This is the default filter (specialisation).

  typedef CGAL_Interval_nt_advanced IA;

  CGAL_Bounded_side result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = CGAL_side_of_bounded_circleH2(
		CGAL_convert_to<IA>(qhx.value),
		CGAL_convert_to<IA>(qhy.value),
		CGAL_convert_to<IA>(qhw.value),
		CGAL_convert_to<IA>(rhx.value),
		CGAL_convert_to<IA>(rhy.value),
		CGAL_convert_to<IA>(rhw.value),
		CGAL_convert_to<IA>(shx.value),
		CGAL_convert_to<IA>(shy.value),
		CGAL_convert_to<IA>(shw.value),
		CGAL_convert_to<IA>(thx.value),
		CGAL_convert_to<IA>(thy.value),
		CGAL_convert_to<IA>(thw.value));
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = CGAL_side_of_bounded_circleH2(
		CGAL_convert_to<ET>(qhx.value),
		CGAL_convert_to<ET>(qhy.value),
		CGAL_convert_to<ET>(qhw.value),
		CGAL_convert_to<ET>(rhx.value),
		CGAL_convert_to<ET>(rhy.value),
		CGAL_convert_to<ET>(rhw.value),
		CGAL_convert_to<ET>(shx.value),
		CGAL_convert_to<ET>(shy.value),
		CGAL_convert_to<ET>(shw.value),
		CGAL_convert_to<ET>(thx.value),
		CGAL_convert_to<ET>(thy.value),
		CGAL_convert_to<ET>(thw.value));
  }
  return result;
}

template < class CT, class ET >
// CGAL_KERNEL_MEDIUM_INLINE
CGAL_Oriented_side
CGAL_side_of_oriented_circleH2(const CGAL_Filtered_exact<CT,ET>& qhx,
	const CGAL_Filtered_exact<CT,ET>& qhy,
	const CGAL_Filtered_exact<CT,ET>& qhw,
	                               const CGAL_Filtered_exact<CT,ET>& rhx,
	const CGAL_Filtered_exact<CT,ET>& rhy,
	const CGAL_Filtered_exact<CT,ET>& rhw,
	                               const CGAL_Filtered_exact<CT,ET>& shx,
	const CGAL_Filtered_exact<CT,ET>& shy,
	const CGAL_Filtered_exact<CT,ET>& shw,
	                               const CGAL_Filtered_exact<CT,ET>& thx,
	const CGAL_Filtered_exact<CT,ET>& thy,
	const CGAL_Filtered_exact<CT,ET>& thw )
{ // This is the default filter (specialisation).

  typedef CGAL_Interval_nt_advanced IA;

  CGAL_Oriented_side result;
  CGAL_FPU_set_rounding_to_infinity();
  try
  {
    result = CGAL_side_of_oriented_circleH2(
		CGAL_convert_to<IA>(qhx.value),
		CGAL_convert_to<IA>(qhy.value),
		CGAL_convert_to<IA>(qhw.value),
		CGAL_convert_to<IA>(rhx.value),
		CGAL_convert_to<IA>(rhy.value),
		CGAL_convert_to<IA>(rhw.value),
		CGAL_convert_to<IA>(shx.value),
		CGAL_convert_to<IA>(shy.value),
		CGAL_convert_to<IA>(shw.value),
		CGAL_convert_to<IA>(thx.value),
		CGAL_convert_to<IA>(thy.value),
		CGAL_convert_to<IA>(thw.value));
    CGAL_FPU_set_rounding_to_nearest();
  } 
  catch (IA::unsafe_comparison)
  {
    CGAL_FPU_set_rounding_to_nearest();
    result = CGAL_side_of_oriented_circleH2(
		CGAL_convert_to<ET>(qhx.value),
		CGAL_convert_to<ET>(qhy.value),
		CGAL_convert_to<ET>(qhw.value),
		CGAL_convert_to<ET>(rhx.value),
		CGAL_convert_to<ET>(rhy.value),
		CGAL_convert_to<ET>(rhw.value),
		CGAL_convert_to<ET>(shx.value),
		CGAL_convert_to<ET>(shy.value),
		CGAL_convert_to<ET>(shw.value),
		CGAL_convert_to<ET>(thx.value),
		CGAL_convert_to<ET>(thy.value),
		CGAL_convert_to<ET>(thw.value));
  }
  return result;
}


#endif // CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H
