// ======================================================================
//
// Copyright (c) 1999 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// source        : 
// file          : include/CGAL/Arithmetic_filter/predicates_on_rtH2.h
// package       : Interval_arithmetic
// revision      : 2.1
// revision_date :
// author(s)     : Sylvain.Pion@sophia.inria.fr
//
// coordinator   : MPI, Saarbruecken
// ======================================================================


#ifndef CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H
#define CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H

// This file is automatically generated by the script for filtering
// predicates, using Interval arithmetic.

CGAL_BEGIN_NAMESPACE

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Orientation
orientationH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                    
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                    
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Orientation result = orientationH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return orientationH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
  CGAL_assertion(false);
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
leftturnH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = leftturnH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return leftturnH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
  CGAL_assertion(false);
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
rightturnH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = rightturnH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return rightturnH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
  CGAL_assertion(false);
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
collinearH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = collinearH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return collinearH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
  CGAL_assertion(false);
}
#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Bounded_side
side_of_bounded_circleH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Bounded_side result = side_of_bounded_circleH2(
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval(),
		shx.interval(),
		shy.interval(),
		shw.interval(),
		thx.interval(),
		thy.interval(),
		thw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return side_of_bounded_circleH2(
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact(),
		shx.exact(),
		shy.exact(),
		shw.exact(),
		thx.exact(),
		thy.exact(),
		thw.exact());
  }
  CGAL_assertion(false);
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Oriented_side
side_of_oriented_circleH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shw,
                               
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& thw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Oriented_side result = side_of_oriented_circleH2(
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval(),
		shx.interval(),
		shy.interval(),
		shw.interval(),
		thx.interval(),
		thy.interval(),
		thw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return side_of_oriented_circleH2(
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact(),
		shx.exact(),
		shy.exact(),
		shw.exact(),
		thx.exact(),
		thy.exact(),
		thw.exact());
  }
  CGAL_assertion(false);
}
#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Comparison_result
compare_lexicographically_xyH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                                    
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw)
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Comparison_result result = compare_lexicographically_xyH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return compare_lexicographically_xyH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact());
  }
  CGAL_assertion(false);
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Comparison_result
compare_xH2( 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                  
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Comparison_result result = compare_xH2(
		phx.interval(),
		phw.interval(),
		qhx.interval(),
		qhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return compare_xH2(
		phx.exact(),
		phw.exact(),
		qhx.exact(),
		qhw.exact());
  }
  CGAL_assertion(false);
}

// No compare_yH2; use compare_xH2( py, pw, qy, qw)

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
Comparison_result
compare_deltax_deltayH2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
                             
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
                             
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw,
                             
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& shw )
  
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>  tbc1 = abs(phx*qhw - qhx*phw) * rhw*shw;
  
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>  tbc2 = abs(rhy*shw - shy*rhw) * phw*qhw;
  return (tbc2 < tbc1) ? LARGER
                       : (tbc1 == tbc2) ? EQUAL : SMALLER;


template <class Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>>
// CGAL_KERNEL_INLINE
bool
collinear_are_ordered_along_lineH2(
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw
                                       )
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    Comparison_result result = collinear_are_ordered_along_lineH2(
		phx.interval(),
		phw.interval(),
		qhx.interval(),
		qhw.interval(),
		rhy.interval(),
		rhw.interval(),
		shy.interval(),
		shw.interval(),
		phw.interval(),
		s.interval(),
		rhw.interval(),
		q.interval(),
		tbc1.interval(),
		LARGER.interval(),
		tbc2.interval(),
		S.interval(),
		.interval());		CGAL_KERNEL_INLINE.interval(),
		bool.interval(),
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval(),
		.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return collinear_are_ordered_along_lineH2(
		phx.exact(),
		phw.exact(),
		qhx.exact(),
		qhw.exact(),
		rhy.exact(),
		rhw.exact(),
		shy.exact(),
		shw.exact(),
		phw.exact(),
		s.exact(),
		rhw.exact(),
		q.exact(),
		tbc1.exact(),
		LARGER.exact(),
		tbc2.exact(),
		S.exact(),
		.exact());		CGAL_KERNEL_INLINE.exact(),
		bool.exact(),
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact(),
		.exact());
  }
  CGAL_assertion(false);
}

#ifndef CGAL_CFG_NO_EXPLICIT_TEMPLATE_FUNCTION_ARGUMENT_SPECIFICATION
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#endif
// CGAL_KERNEL_INLINE
bool
collinear_are_strictly_ordered_along_lineH2(
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& phw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& qhw,
     
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhx, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhy, 
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, CGAL_IA_CACHE>& rhw)
{
  FPU_CW_t backup = FPU_get_cw();
  FPU_set_cw(FPU_cw_up);
  try
  {
    bool result = collinear_are_strictly_ordered_along_lineH2(
		phx.interval(),
		phy.interval(),
		phw.interval(),
		qhx.interval(),
		qhy.interval(),
		qhw.interval(),
		rhx.interval(),
		rhy.interval(),
		rhw.interval());
    FPU_set_cw(backup);
    return result;
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    FPU_set_cw(backup);
    return collinear_are_strictly_ordered_along_lineH2(
		phx.exact(),
		phy.exact(),
		phw.exact(),
		qhx.exact(),
		qhy.exact(),
		qhw.exact(),
		rhx.exact(),
		rhy.exact(),
		rhw.exact());
  }
  CGAL_assertion(false);
}



CGAL_END_NAMESPACE


#ifdef CGAL_ARITHMETIC_FILTER_H
#include <CGAL/Arithmetic_filter/predicates_on_rtH2.h>
#endif // CGAL_ARITHMETIC_FILTER_H

#endif // CGAL_ARITHMETIC_FILTER_PREDICATES_ON_RTH2_H
