#! /bin/bash

# ============================================================================
# Copyright (c) 2004  Max-Planck-Institute Saarbruecken (Germany), 
# All rights reserved.
#
# This file is part of CGAL (www.cgal.org); you can redistribute it and/or
# modify it under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation; version 2.1 of the License.
# See the file LICENSE.LGPL distributed with CGAL.
#
# Licensees holding a valid commercial license may use this file in
# accordance with the commercial license agreement provided with the software.
#
# This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
# WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# $Source$
# $Revision$ $Date$
# $Name$
#
# Author(s)     : Lutz Kettner
#
# ============================================================================
# 
# Specification: cgal_manual
# --------------------------
# 
# It is called in a ./doc_tex/ directory of a CGAL Package or internal release.
# 
# This script is the driver program for creating CGAL manuals.
# It makes use of LaTeX, BiBTeX, makeindex, latex_to_html, and other
# tools to create the PostScript, PDF (later), and HTML manuals for
# individual CVS Packages as well as custom Modules. It encodes the 
# conventions of how CGAL manuals are organized and how the general 
# purpose tools need to be called to create the manuals. We specify these
# conventions here briefly. See the developers manual for more details.
# Both documentations need to be kept synchronized!
#
# - CVS Package: 
# 
#     Development unit in CGAL hosted on our CVS server. A package has a 
#     fixed directory directory structure. Let's assume the package is 
#     called 'Geom', then the documentation must reside in a directory
#     ./doc_tex/ withing the package Geom. Here, individual subdirectories, 
#     typically ./Geom/ and ./Geom_ref/, contain the user and the reference 
#     manual respectively. The individual subdirectories contain a main.tex 
#     that contains the manual chapter, possibly several and possibly using 
#     several other input files, but all included with relative paths
#     from the ./doc_tex/ directory, where the tools and this script will
#     run.
#        In general, all individual subdirectories that contain a main.tex
#     are processed. ./doc_tex/*/main.tex and ./doc_tex/*_ref/main.tex are
#     assumed to form corresponding user and reference manual entries in the 
#     table of contents.
#        The main.tex files are not stand-alone LaTeX files. They are
#     chapters, i.e., do not contain \begin{document} etc. This script 
#     provides the necessary LaTeX wrapper file.
#
# - Modules:
# 
#     Presentation unit of modularity towards the user, assembled from
#     CVS packages. For a module of name 'Algo' it is assumed that in the
#     ./doc_tex/ directory exists the necessary LaTeX driver file Algo.tex .
#     This driver is a complete LaTeX file incl. \begin{document} and 
#     such. It can in itself then include the various chapters from 
#     packages.
# 
# This script can create individual package documentation given the name of
# the individual subdirectories in ./doc_tex/. It creates module 
# documentations given the name of the module LaTeX driver file.
# 
# The default is to create package manuals for all ./*/main.tex files,
# where ./*/main.tex and corresponding ./*_ref/main.tex are kept in 
# one manual., and for all *_[Mm]anual.tex files for modules.
# 
# This script can be used in three different environments of CGAL sources.
# It decides automatically in which situation it is and adapts the necessary
# search paths for style files and bibliographies.
# 
# - 1. CGAL Internal Release
# 
#     The style and bibliography files are in ./Manual/.
# 
# - 2. Individual CGAL Packages + CGAL Package 'Manual'
# 
#     The style and bibliography files are in ../../Manual/doc_tex/Manual/.
# 
# - 3. All other environments
# 
#     The style and bibliography files need to be installed properly
#     from the CVS package Manual, such that the tools can find them, for
#     example through the search paths defined in the environment variables 
#     TEXINPUTS, BIBINPUTS, and LATEX_CONV_INPUTS.
# 
# This script properly adds entries in TEXINPUTS, BIBINPUTS, and 
# LATEX_CONV_INPUTS so that bib and style files are found. It also 
# adds ../examples:../demo to access the example source codes.
#
#
# When the -testsuite option is used the script will copy all the manuals
# and logfiles to $TestSuiteResultPath/CGAL-$CgalVersion/ and creates an
# HTML summary page index.html in that subdirectory. The latest results
# is also always accessible at $TestSuiteResultPath/last/index.html .
#    Futhermore, the script will cleanup old results. For the most recent
# number $TestSuiteFullHistory of test suites the full results including
# the manuals are kept. Older test suites will have their manuals deleted
# to save space. Int total only $TestSuiteHistory many test suites are kept.
#    The history of test suites is managed in a shift register like fashion
# using files in $TestSuiteResultPath of defined names History.<i> that 
# contain the name of the i-th test suite subdirectory. The 1st is the 
# most recent test suite and corresponds to the 'last' directory.
#    If the test suite is repeated for the same internal release number,
# the new results will overwrite the old results.
# ============================================================================

shopt -s nullglob

# =====================================================================
# Begin of Configuration Section: ...
# =====================================================================

Latex="latex"
# idea, not finished: if $Latex --help | grep file-line-error-style
Bibtex="bibtex -terse"
MakeIndex="makeindex -q"
DvipsA4="dvips -q -D 600 -t a4 -P pdf"
Gzip="gzip"
LatexToHtml="latex_to_html"
Sendmail=mail

ResourceFile="$HOME/.cgalmanualrc"

#---------------------------------------------------------------------#
# Global variables, default initialization
#---------------------------------------------------------------------#

# Selects the different output formats supported
MakePS=1
MakePDF=0
MakeHTML=1

# Selects that only the LaTeX wrapper files for packages are created
MakeWrapperOnly=0

# Selects if the results are collected and formatted for the test-suite
# result pages on the web and copies them there
MakeTestSuiteResult=0

# The corresponding address in the file space for copying the 
# test-suite result pages. Needs to be in the file system, because
# not only are pages copied, but the script manages also a clever 
# history of up to $TestSuiteHistory many test-suite results and
# deletes older ones.
TestSuiteResultPath="/www/pub/www.cgal.org/Members/Manual_test"

# Number of older test-suite results kept. Test-suite results beyond this 
# number are deleted.
TestSuiteHistory=8

# Number of older test-suites for which the full results will be kept. Older
# test suites will have their manuals removed to save space.
TestSuiteFullHistory=3

# Email address to send the end-of-testsuite announcement to. If this 
# variable is empty, no email will be send.
TestSuiteResultEmail="cgal-develop-l@postino.mpi-sb.mpg.de"

# The url prefix of the result web page
TestSuiteResultUrl="http://www.cgal.org/Members/Manual_test"

# =====================================================================
# ... End of Configuration Section.
# =====================================================================

# Determines if we currently make a Module or Package manual.
# Only one is set to 1.
MakeModule=0
MakePackage=0

# Name of this script, without leading path
ProgName=${0##*/}

# We keep some statistics for the protocol
TotalStartTime=$SECONDS
Date="`date '+%d %b %Y'`"
Time="`date '+%T %Z'`"

# Try to determine the CGAL version (works only for internal/external releases)
# Otherwise use date.
if [ -r version.tex ]; then
    CgalVersion="`cat version.tex | grep cgalversion | sed 's/[}]$//' | sed 's/.*[{]//'`"
else
    CgalVersion=`echo ${Date} | sed 's/ /_/g'`
fi

# Selects no console output except error messages
Quiet=0

# Selects no console output at all, not even error messages
RealQuiet=0

# Selects detailed console output, includes the logfile output
Verbose=0

# By default, the log file will be deleted at the end if there were no errors.
# With $KeepLog one can keep the log in any case. With $NoLog it will
# be deleted in any case.
KeepLog=0
NoLog=0

# Selects to keep the summary lines of the console output also in a sumary file
Sum=0

# Read the resource file
ReturnStatus=0
if [ -r $ResourceFile ] ; then
  source $ResourceFile
fi
if [ $ReturnStatus -ne 0 ] ; then
  exit $ReturnStatus
fi

# Color changing control sequences. Makes protocols more readable.
# There is a translation to HTML format in the corresponding code below.
BlueColor=""
BoldColor=""
OkColor=""
ErrorColor=""
WarnColor=""
ResetColor=""
if [ -t 2 ] ; then # is stderr connected to a terminal
  case "$TERM" in
    xterm* | vt100* | console* ) # terminals believed to have color capability
      BlueColor='[1m[34m'    # blue boldface
      BoldColor='[1m'          # boldface
      OkColor='[32m'           # green
      ErrorColor='[1m[31m'   # red boldface
      WarnColor='[35m'         # magenta
      ResetColor='[30m[00m'  # black, reset attribute
      ;;
  esac
fi


#---------------------------------------------------------------------#
# version
#---------------------------------------------------------------------#

version_no() {
    echo '$Revision$' | sed 's/[$]Revision: //' | sed 's/ [$]//g'
}

version_date() {
    echo '$Date$' | sed 's/[$]Date: //' | \
        sed 's/ [0-9][0-9]:[0-9][0-9]:[0-9][0-9] [$]//'
}

version() {
    echo "${BoldColor}${ProgName}:${ResetColor} ${BlueColor}Revision `version_no` [`version_date`]"\
        "   (c) Lutz Kettner${ResetColor}"  1>&2
}

#---------------------------------------------------------------------#
# usage
#---------------------------------------------------------------------#

usage() {
    version
    cat  1>&2 <<EOF
${BoldColor}Usage: ${ProgName} [<options>] [<module-files...>] [<package-dirs...>]${ResetColor}
    Creates CGAL manuals from CGAL packages or modules. It should be called in
    the ./doc_tex/ directory of a CGAL internal release or CVS checkout.
       ${BoldColor}CGAL packages${ResetColor} are given as a subdirectory that contains a main.tex file;
    a wrapper file that includes main.tex is automatically generated and 
    deleted at the end. Use -wrapper to create a wrapper file permanently.
       ${BoldColor}CGAL modules${ResetColor} are given as an explict LaTeX file, e.g., generated with 
    -wrapper.
       The result are the specified manuals in the corresponding ../doc_ps,
    ../doc_pdf, and ../doc_html directories. A logfile .cgallog is created
    with a logfile summary from the individual logfiles .log, .blg, .ilg,
    and .hlg. The logfiles are kept in case of warnings and error messages.
       The screen output reports the progress and result status of each
    module (abbrev. as Mod) and package (abbrev. as Pck) and each manual type.
${BoldColor}Options:${ResetColor}
    ${BoldColor}-ps${ResetColor}                 PostScript manuals only.
    ${BoldColor}-pdf${ResetColor}                PDF manuals only (not yet supported).
    ${BoldColor}-html${ResetColor}               HTML manuals only (incl. a LaTeX run).
    ${BoldColor}-wrapper${ResetColor}            creates the LaTeX wrapper files only.
    ${BoldColor}-testsuite${ResetColor}          runs testsuite, installs results and sends email. Use
                        only after reading the config section of this script.
    ${BoldColor}-h${ResetColor}                  help (this text).
    ${BoldColor}-V${ResetColor}                  version.
    ${BoldColor}-v${ResetColor}                  verbose: repeats logfiles on stserr.
    ${BoldColor}-k${ResetColor}                  keep logfiles (default: delete after a clean run).
    ${BoldColor}-n${ResetColor}                  no logfile: delete logfiles always.
    ${BoldColor}-s${ResetColor}                  create a summary logfile .sum .
    ${BoldColor}-quiet${ResetColor}              no progress messages.
    ${BoldColor}-realquiet${ResetColor}          suppresses also error messages.
EOF
}


#---------------------------------------------------------------------#
# summary <strings> ....
#     - writes '<strings> ...' in a single line to stdout and the $LogFile
#     - if <string> is '-n' then the line break is suppressed.
#     - if $Quiet is set the output to stdout gets suppressed
#     - We keep an (accumulated) copy of all output done with -n.
#       We use that in the error() function if the -q (quiet) switch 
#       was used to actually print what was not printed so far.
#---------------------------------------------------------------------#

NBuffer=""

update_nbuffer() {
  if [ "$1" == "-n" ] ; then
    shift
    NBuffer="$NBuffer""$*"
  else
    NBuffer=""
  fi
}

pad_nbuffer() {
  # output '. . . . ' pattern up to column $1 taking NBuffer into account
  # make length even first
  declare -i len=$1-${#NBuffer}
  declare -i even="$len%2"
  if [ $even -ne 0 ] ; then
    echo -n " "
    len=$len-1
  fi
  while [ $len -gt 0 ] ;
  do
    echo -n ". "
    len=$len-2
  done
}

summary() {
  update_nbuffer "$@"
  if [ $Verbose -eq 0 ] ; then
    if [ $Quiet -eq 0 ] ; then
      echo "$@"
    fi
  fi
  echo "$@" | sed 's/[[][^m]*m//g;' >> $LogFile
}

#---------------------------------------------------------------------#
# error <strings> ....
#     - writes '<strings> ...' in a single line to stdout and the $LogFile
#     - if <string> is '-n' then the line break is suppressed
#     - if $RealQuiet is set the output to stdout gets suppressed
#     - works together with summary to not loose stuff from NBuffer 
#       where output used the -n flag.
#---------------------------------------------------------------------#

error() {
  if [ $RealQuiet -eq 0 ] ; then
    if [ $Verbose -eq 0 ] ; then
      if [ $Quiet -eq 1 ] ; then
        echo -n "$NBuffer"
      fi
      echo "$@"
    fi
  fi
  echo "$@" | sed 's/[[][^m]*m//g;' >> $LogFile
  NBuffer=""
}

#---------------------------------------------------------------------#
# log <strings> ....
#     - writes '<strings> ...' in a single line to the $TmpLogFile
#     - if <string> is '-n' then the line break is suppressed
#     - if $Verbose is set it echos the output also to stdout
#---------------------------------------------------------------------#

log() {
  if [ $Verbose -eq 1 ] ; then
    echo "$@"
  fi
  echo "$@" >> $TmpLogFile
}

#---------------------------------------------------------------------#
# log_divider <string>
#     - writes '--------------- <strings> ---' to log file
#     - formatted to 78 columns
#---------------------------------------------------------------------#

log_divider() {
  Pad=""
  Aux="$*"
  declare -i len=51-${#Aux}
  while [ $len -gt 0 ] ;
  do
    Pad="-$Pad"
    len=$len-1
  done
  log "------------------------- $* $Pad"
}

#---------------------------------------------------------------------#
# print_time <start-time> <end-time>
#     - <start-time> and <end-time> are in seconds
#     - format printed is hh:mm:ss
#---------------------------------------------------------------------#

print_time() {
  declare -i DiffTime=$2-$1
  declare -i Hours="$DiffTime/3600"
  declare -i Minutes="($DiffTime/60)%60"
  declare -i Seconds="$DiffTime%60"
  printf "%02d:%02d:%02d" $Hours $Minutes $Seconds
}

#---------------------------------------------------------------------#
# is_in_list <name> <list...>
#     - Returns 0 if <name> is contained in <list...> and 1 otherwise
#---------------------------------------------------------------------#

is_in_list() {
    N=$1
    shift
    for f in $@ ; do
        if [[ $N == $f ]]; then return 0; fi
    done
    return 1
}

#---------------------------------------------------------------------#
# create_wrapper <rootname> [<package-ref-name>]
#     - Writes LaTeX wrapper file <rootname>.tex for CGAL package
#     - CGAL package has name <rootname>, an optional second argument
#       gives the name of a reference manual part put side-by-side
#       in the table of contents.
#---------------------------------------------------------------------#

create_wrapper() {
    cat <<EOF
% +------------------------------------------------------------------------+
% | $1.tex
% | LaTeX Wrapper File for CGAL User and Reference Manual
% | Automatically generated by 'cgal_manual' for CGAL Packages
% +------------------------------------------------------------------------+

\documentclass{book}
\usepackage{cgal_manual}

\makeindex
EOF
    if [ $# -ne 1 ]; then
        echo ""
        echo "% Make the table of contents use two columns"
        echo "\lcHtml{\lcTwoColumnToc}"
    fi
    cat <<EOF

\begin{document}

EOF
    echo "\\cgalTitlePage{$1 Package}" | sed 's/_/\\_/g'
    cat <<EOF

\cgalchapters{
EOF
    if [ $# -eq 1 ]; then
        if [[ $1 == *_ref ]]; then
            echo "    %\entryleft{\part{Reference Manual}}"
            echo "    \lcTex{\entryleft{\listofrefpages}}"
        else
            echo "    %\entryleft{\part{User Manual}}"
        fi
        echo "    \packageleft{$1}"
    else
        echo "    %\entryleftright{\part{User Manual}}{\part{Reference Manual}}"
        echo "    \lcTex{\entryright{\listofrefpages}}"
        echo "    \packageleftright{$1}{$2}"
    fi
    cat <<EOF
}
\bibliographystyle{alpha}
\bibliography{cgal_manual,geom}

\printindex

\end{document}
EOF
}

#---------------------------------------------------------------------#
# report_latex <wrapper-rootname>
#     - Reports summary of error messages and warnings from LaTeX, BibTeX,
#       and makeindex log files.
#---------------------------------------------------------------------#

report_latex() {
    echo ""
    echo "Summary LaTeX"
    echo "-------------"
    echo "For the full logfile see $1.log"
    if [ $MakePackage -eq 1 ]; then
        echo "Since this is a CGAL Package manual, one can probably ignore "
        echo "warnings about undefined references."
    fi
    egrep -i '((error)|(^[!]))' $1.log | grep -v "operatorerror"
    grep -i warn $1.log 
    if [ $MakeTestSuiteResult -eq 1 ]; then mv $1.log testsuite/$1.log.txt ; fi
    if [ -r $1.blg ]; then 
        echo ""
        echo "Summary BibTeX"
        echo "--------------"
        echo "For the full logfile see $1.blg"
        grep -i error $1.blg 
        grep -i warn $1.blg | grep -v 'warning[$]'
        if [ $MakeTestSuiteResult -eq 1 ]; then 
            mv $1.blg testsuite/$1.blg.txt
        fi
    fi
    if [ -r $1.ilg ]; then 
        echo ""
        echo "Summary makeindex"
        echo "-----------------"
        echo "For the full logfile see $1.ilg"
        egrep -i '((error)|(reject))' $1.ilg 
        grep -i warn $1.ilg
        if [ $MakeTestSuiteResult -eq 1 ]; then
            mv $1.ilg testsuite/$1.ilg.txt
        fi
    fi
    echo ""
    return
}

#---------------------------------------------------------------------#
# cleanup_latex <wrapper-rootname>
#     - Removes all temporaries
#---------------------------------------------------------------------#

cleanup_latex() {
    rm -f $1.toc $1.mtc* $1.idx $1.ind $1.dvi
    if [ $MakeHTML -eq 0 ] ; then 
        rm -f $1.aux $1.bbl
    fi
    # in case the log was not asked for, delete it
    if [[ $NoLog -eq 1 || ( $KeepLog -eq 0 && $RetCode -eq 0 ) ]] ; then
      rm -f $1.log $1.blg $1.ilg
    fi
    return
}

#---------------------------------------------------------------------#
# check_latex_warn <wrapper-rootname>
#     - Checks if latex logfile contains valid warnings
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_latex_warn() {
    if [ $MakePackage -eq 0 ]; then
        if egrep -v "((Rerun to get cross-references right)|(warning[$]))" \
            $1.log | grep -i warn > /dev/null ; then
            return 0
        fi
    else # for CGAL Packages, also ignore warnings of undef. references
        if egrep -v "((Rerun to get cross-references right)|(warning[$])|(LaTeX Warning: Reference)|(undefined references))" $1.log | grep -i warn > /dev/null ; then
            return 0
        fi
    fi
    return 1
}

#---------------------------------------------------------------------#
# check_bibtex_warn <wrapper-rootname>
#     - Checks if bibtex logfile contains valid warnings
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_bibtex_warn() {
    if grep -v "warning[$]" $1.blg | grep -i warn > /dev/null ; then
        return 0
    fi
    return 1
}

#---------------------------------------------------------------------#
# check_index_warn <wrapper-rootname>
#     - Checks if makeindex logfile contains valid warnings
#     - Returns 0 if there are valid warnings, 1 otherwise
#---------------------------------------------------------------------#

check_index_warn() {
    if grep -v "lines written, 0 warnings" $1.ilg \
        | grep -i warn > /dev/null ; then
        return 0
    fi
    return 1
}

#---------------------------------------------------------------------#
# testsuite_entry <exit-code> <log-filename>
#     - writes a single <td> cell in HTML report table to stdout
#     - reports exit code results: 0 = ok, 1 = error, 2 = warning, 3 = n.a.
#---------------------------------------------------------------------#

SP="&nbsp;&nbsp;&nbsp;&nbsp;"

testsuite_entry() {
  if [ $1 -eq 0 ]; then
    echo "  <td align=\"center\" class=\"ok\"><a href=\"$2\">${SP}y${SP}</a></td>"
  elif [ $1 -eq 1 ]; then
    echo "  <td align=\"center\" class=\"error\"><a href=\"$2\">${SP}n${SP}</a></td>"
  elif [ $1 -eq 2 ]; then
    echo "  <td align=\"center\" class=\"warning\"><a href=\"$2\">${SP}w${SP}</a></td>"
  else
    echo "  <td align=\"center\" class=\"void\">-</td>"
  fi
}


#---------------------------------------------------------------------#
# run_latex <wrapper-rootname>
#     - Runs LaTeX, either brief for HTML, or full for stable PS/PDF
#     - Includes BiBTeX and makeindex if needed.
#     - Returns in $RetCode: 1 = error, 2 = warning
#     - Prints logfile summary result in stdout
#---------------------------------------------------------------------#

run_latex() {
    # codes memorized for the different passes:
    # 0 = ok, 1 = error, 2 = warning, 3 = n.a.
    LatexExit=0
    BibtexExit=4
    IndexExit=4
    RetCode=0 # total return code
    # first run
    $Latex --interaction batchmode $1
    if [ $? -ne 0 ]; then LatexExit=1 ; fi
    # see if we need BiBTeX and run it
    if grep '[\\]bibdata'  $1.aux > /dev/null ; then
        if $Bibtex $1 ; then BibtexExit=0 ; else BibtexExit=1 ; fi
        # Run LaTeX to get citations into the auxfile.
        $Latex --interaction batchmode $1
        if [ $? -ne 0 ]; then LatexExit=1 ; fi
    fi
    # see if we need full LaTeX results, or if suffices what we have so far
    if [ ${MakePS} -eq 1 ] ; then
        # Run LaTeX until their is no rerun necessary anymore
        while grep "Rerun to get cross-references right" $1.log > /dev/null; do
            # Run makeindex as well if requested
            if [ -r $1.idx ]; then
              if ${MakeIndex} $1.idx; then IndexExit=0 ; else IndexExit=1 ; fi
            fi
            $Latex --interaction batchmode $1
            if [ $? -ne 0 ]; then LatexExit=1 ; fi
        done
        if [ -r $1.dvi ]; then
            if ! ${DvipsA4} $1 -o $1.ps ; then RetCode=1; fi
        fi
        if [ -r $1.ps ]; then
            if ! ${Gzip} $1.ps ; then RetCode=1; fi
        fi
        if [ $MakeTestSuiteResult -eq 1 ]; then 
            mv $1.ps.gz testsuite
        else
            if [ ! -d ../doc_ps ]; then mkdir ../doc_ps; fi
            if [ ! -d ../doc_ps ]; then
                echo "ERROR: Something is wrong, I cannot create directory '../doc_ps' ."
                RetCode=1
            else
                mv $1.ps.gz ../doc_ps
            fi
        fi
    fi
    if [ $LatexExit  -eq 0 ]; then
        if check_latex_warn  $1 ; then LatexExit=2;  fi
    fi
    if [ $BibtexExit -eq 0 ]; then
        if check_bibtex_warn $1 ; then BibtexExit=2; fi
    fi
    if [ $IndexExit  -eq 0 ]; then
        if check_index_warn  $1 ; then IndexExit=2;  fi
    fi
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        testsuite_entry $LatexExit  $1.log.txt >  testsuite/index_row
        testsuite_entry $BibtexExit $1.blg.txt >> testsuite/index_row
        testsuite_entry $IndexExit  $1.ilg.txt >> testsuite/index_row
    fi
    if [ $RetCode -eq 0 ] ; then
      if [[ $LatexExit -eq 1 || $BibtexExit -eq 1 || $IndexExit -eq 1 ]]; then
          RetCode=1
      fi
    fi
    if [ $RetCode -eq 0 ] ; then
      if [[ $LatexExit -eq 2 || $BibtexExit -eq 2 || $IndexExit -eq 2 ]]; then
          RetCode=2
      fi
    fi
    report_latex $1
    cleanup_latex $1
    return $RetCode
}

#---------------------------------------------------------------------#
# report_html <wrapper-rootname>
#     - Reports summary of error messages and warnings from HTML conversion
#---------------------------------------------------------------------#

report_html() {
    echo ""
    echo "Summary LaTeX_to_HTML"
    echo "---------------------"
    echo "For the full logfile see $1.hlg"
    grep -i error $1.hlg 
    grep -i rejected $1.hlg 
    grep -i warn $1.hlg 
    echo ""
    return
}

#---------------------------------------------------------------------#
# cleanup_html <wrapper-rootname>
#     - Removes all temporaries
#---------------------------------------------------------------------#

cleanup_html() {
    rm -f $1.ref $1.aux $1.bbl
    # in case the log was not asked for, delete it
    if [[ $NoLog -eq 1 || ( $KeepLog -eq 0 && $RetCode -eq 0 ) ]] ; then
      rm -f $1.hlg
    fi
    return
}

#---------------------------------------------------------------------#
# run_html <wrapper-rootname>
#     - Runs LaTeX_to_HTML
#     - Returns in $RetCode: 1 = error, 2 = warning
#     - Prints logfile summary result in stdout
#---------------------------------------------------------------------#

run_html() {
    RetCode=0
    ${LatexToHtml} -nocolor -V # list version number in summary    
    # first run
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        ${LatexToHtml} -quiet -o testsuite/$1 $1
    else
        ${LatexToHtml} -quiet -o ../doc_html/$1 $1
    fi
    if [ $? -ne 0 ]; then
        RetCode=1
        report_html $1
        cleanup_html $1
        return $RetCode
    fi
    if [ $RetCode -eq 0 ] ; then
        if grep -v 'lines written' $1.hlg | \
            grep -i warn > /dev/null ; then RetCode=2; fi
    fi
    report_html $1
    cleanup_html $1
    return $RetCode
}

#---------------------------------------------------------------------#
# try_command <description> <command ...>
#     - executes command and logs output of stdout and stderr in $TmpLogFile
#     - includes execution timing in output
#     - if $Verbose is set, it also echos the output to stdout
#     - Return codes of <command ...> are also returned and $ExitCode set
#         1 = error, 2 = warning
#---------------------------------------------------------------------#

try_command() {
  ExitCode=0
  local StartTime=$SECONDS
  local Text="$1"
  shift
  summary -n "$Text "
  log_divider "start $Text"
  rm -f $TmpLogFile.2
  if [ $Verbose -eq 1 ] ; then
    { 
      # I need to pass the exitcode through the pipe and set $ExitCode.
      # That does not work easily with a pipe and I just use a file instead.
      eval "$@" 2>&1
      echo $? > $TmpLogFile.3
      cat $TmpLogFile.3
    } | tee $TmpLogFile.2
    ExitCode=`cat $TmpLogFile.3`
    rm -f $TmpLogFile.3
  else
    eval "$@" > $TmpLogFile.2  2>&1
    ExitCode=$?
  fi
  local EndTime=$SECONDS
  cat $TmpLogFile.2 >> $TmpLogFile
  rm -f $TmpLogFile.2
  log_divider "end $Text"

  # padding up to column 54
  if [ $ExitCode -eq 1 ] ; then
    error "`pad_nbuffer 54`[${ErrorColor}ERROR${ResetColor}]  time = `print_time $StartTime $EndTime`"
  elif [ $ExitCode -eq 2 ] ; then
    error "`pad_nbuffer 54`[${WarnColor}WARNG${ResetColor}]  time = `print_time $StartTime $EndTime`"
  else
    summary "`pad_nbuffer 54`.  [${OkColor}ok${ResetColor}]  time = `print_time $StartTime $EndTime`"
  fi
  return $ExitCode
}


#---------------------------------------------------------------------#
# is_module <name>
#     - returns 0 if <name> is name of a CGAL Module, and 1 otherwise
#---------------------------------------------------------------------#

is_module () {
    if [ -r $1.tex ]; then return 0; fi
    if [ -d $1 ]; then return 1; fi
    return 0
}

#---------------------------------------------------------------------#
# make_manual <package or module name> [<package_ref name>]
#     - Manages the logfiles
#     - Creates all selected output formats
#     - For packages with user and reference manual, the second optional
#       argument is used to give the reference manual directory.
#---------------------------------------------------------------------#

make_manual() {
    ReturnStatus=0

    if [ $MakeWrapperOnly -eq 1 ]; then 
        if [ -r $1.tex ]; then
            echo "" 1>&2
            echo "${ErrorColor}ERROR${ResetColor}: Wrapper file '$1.tex' exists already." 1>&2
            echo "" 1>&2
            GlobalReturnStatus=1
            return 1
        fi
        create_wrapper $@ > $1.tex
        if [ ! -r $1.tex ]; then
            echo "" 1>&2
            echo "${ErrorColor}ERROR${ResetColor}: Something went wrong creating '${1}.tex'." 1>&2
            echo "" 1>&2
            GlobalReturnStatus=1
            return 1
        fi
        return 0; 
    fi

    #---------------------------------------------------------------------#
    # decide between Module and Package
    MakeName="Err"
    if is_module $1 ; then
        MakeName="Mod"
        MakeModule=1
        MakePackage=0
        if [ -r $1.tex ]; then 
            WrapperName=$1.tex
        else
            WrapperName=$1
        fi
    elif [[ -d $1 && -r $1/main.tex ]]; then
        MakeName="Pck"
        MakeModule=0
        MakePackage=1
        WrapperName=$1.tex
        create_wrapper $@ > ${WrapperName}
    else
        echo "" 1>&2
        echo "${ErrorColor}ERROR${ResetColor}: '$1' is neither a CGAL Package nor Module." 1>&2
        echo "" 1>&2
        GlobalReturnStatus=1
        return 1
    fi
    # Fail safe check against unexpected problems (file system full etc.)
    if [ ! -r ${WrapperName} ]; then
        echo "" 1>&2
        echo "${ErrorColor}ERROR${ResetColor}: Something went wrong creating '${WrapperName}'." 1>&2
        echo "" 1>&2
        GlobalReturnStatus=1
        return 1
    fi

    #---------------------------------------------------------------------#
    # Prepare logfiles
    WrapperRootName=${WrapperName%.*}
    LogFile=${WrapperRootName}.cgallog
    TmpLogFile=$LogFile.tmp
    TmpOutFile=$LogFile.cout

    rm -f $LogFile
    touch $LogFile

    #---------------------------------------------------------------------#
    # run LaTeX, needed always, either brief or full
    try_command "${MakeName} ${WrapperRootName} LaTeX" run_latex ${WrapperRootName}
    if [ $ExitCode -ne 0 ] ; then ReturnStatus=$ExitCode; fi


    #---------------------------------------------------------------------#
    # run LaTeX_to_HTML
    HtmlExit=3
    if [ ${MakeHTML} -eq 1 ]; then
      try_command "${MakeName} ${WrapperRootName} HTML " run_html ${WrapperRootName}
      HtmlExit=$ExitCode
      if [[ $ExitCode -ne 0 && ${ReturnStatus} -ne 1 ]]; then
          ReturnStatus=$ExitCode ; 
      fi
      if [ $MakeTestSuiteResult -eq 1 ]; then 
          mv ${WrapperRootName}.hlg testsuite/${WrapperRootName}.hlg.txt
      fi
    fi
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        testsuite_entry $HtmlExit ${WrapperRootName}.hlg.txt >> testsuite/index_row
    fi

    #---------------------------------------------------------------------#
    # remove wrapper file if it is a CGAL package
    if [ ${MakePackage} -eq 1 ]; then rm ${WrapperName}; fi

    #---------------------------------------------------------------------#
    # echo summary in verbose mode and provide summary file
    rm -f $SumFile

    if [[ $Verbose -eq 1 && -r $LogFile ]] ; then cat $LogFile; fi

    if [[ $Sum -eq 1 && -r $LogFile ]] ; then cat $LogFile > $SumFile; fi

    #---------------------------------------------------------------------#
    # collect logfile

    echo "" >> $LogFile
    if [ -r $TmpLogFile ] ; then 
        cat $TmpLogFile >> $LogFile
    fi
    rm -f $TmpLogFile
    echo "==============================================================================" >> $LogFile

    mv $LogFile $TmpLogFile
    TotalEndTime=$SECONDS

    echo "==============================================================================" > $LogFile
    echo "$0 $CommandLineArgs" >> $LogFile
    echo "Date: $Date,   Time: $Time"  >> $LogFile
    echo "Pwd : `pwd`"  >> $LogFile
    echo "Time: `print_time $TotalStartTime $TotalEndTime` total runtime." >> $LogFile
    echo "" >> $LogFile
    cat $TmpLogFile >> $LogFile
    rm -f $TmpLogFile

    #---------------------------------------------------------------------#
    # report testsuite results
    if [ $MakeTestSuiteResult -eq 1 ]; then 
        mv $LogFile testsuite/${LogFile}.txt
        echo "<tr>" >> testsuite/index.html
        echo "  <td align=\"left\" class=\"name\">${WrapperRootName}</td>" >> testsuite/index.html
        if [ $ReturnStatus -eq 2 ]; then
            echo "  <td align=\"center\" class=\"warning\"><a href=\"${LogFile}.txt\">&nbsp;&nbsp;&nbsp;&nbsp;w&nbsp;&nbsp;&nbsp;&nbsp;</a></td>" >> testsuite/index.html
        elif [ $ReturnStatus -eq 0 ]; then
            echo "  <td align=\"center\" class=\"ok\"><a href=\"${LogFile}.txt\">&nbsp;&nbsp;&nbsp;&nbsp;y&nbsp;&nbsp;&nbsp;&nbsp;</a></td>" >> testsuite/index.html
        else
            echo "  <td align=\"center\" class=\"error\"><a href=\"${LogFile}.txt\">&nbsp;&nbsp;&nbsp;&nbsp;n&nbsp;&nbsp;&nbsp;&nbsp;</a></td>" >> testsuite/index.html
        fi
        cat testsuite/index_row >> testsuite/index.html
        rm testsuite/index_row
        echo "  <td align=\"center\" class=\"manual\"><a href=\"${WrapperRootName}.ps.gz\">PS</a></td>" >> testsuite/index.html
        echo "  <td align=\"center\" class=\"manual\"><a href=\"${WrapperRootName}/contents.html\">HTML</a></td>" >> testsuite/index.html
        echo "</tr>" >> testsuite/index.html
    fi

    #---------------------------------------------------------------------#    
    # in case the log was not asked for, delete it
    if [ $NoLog -eq 1 ] ; then rm -f $LogFile ; fi

    # in case there was no error and the option to keep the log is not set,
    # delete the log
    if [[ $KeepLog -eq 0 && $ReturnStatus -eq 0 ]] ; then rm -f $LogFile ; fi

    if [[ $ReturnStatus -ne 0 && ${GlobalReturnStatus} -ne 1 ]]; then
        GlobalReturnStatus=$ReturnStatus; 
    fi
    return $ReturnStatus
}

#---------------------------------------------------------------------#
# testsuite_begin
#     - Creates 'testsuite' subdir
#     - Starts index.html until first table (Modules)
#     - Creates CSS file
#---------------------------------------------------------------------#

testsuite_begin () {
    if [ ! -d testsuite ]; then mkdir testsuite ; fi
    cat > testsuite/testresult.css <<EOF
BODY {background-image:url(http://www.cgal.org/images/cgal-bg2.gif);
color:black}

P {
width: 80ex
}

.contact { font-family:arial,sans-serif; font-size:10pt}

TABLE.result {background-color: white}

TD.ok {background-color: rgb(50%,100%,50%)}
TD.warning {background-color: rgb(100%,100%,50%)}
TD.error {background-color: rgb(100%,50%,50%)}

TH.ok {background-color: rgb(50%,100%,50%)}
TH.warning {background-color: rgb(100%,100%,50%)}
TH.error {background-color: rgb(100%,50%,50%)}


TD.void A {font-size:large; text-decoration: none}
TD.name A {font-size:large; text-decoration: none}

TD.manual A {font-size:large; text-decoration: none}
TD.manual A:link {color: rgb(0%,0%,100%)}
TD.manual A:visited {color: rgb(0%,80%,100%)}

TD.ok A {font-size:large; text-decoration: none}
TD.ok A:link {color: rgb(0%,0%,100%)}
TD.ok A:visited {color: rgb(0%,80%,100%)}

TD.warning A {font-size:large; text-decoration: none}
TD.warning A:link {color: rgb(0%,0%,100%)}
TD.warning A:visited {color: rgb(80%,80%,100%)}

TD.error A {font-size: large; text-decoration: none}
TD.error A:link {color: rgb(0%,0%,100%)}
TD.error A:visited {color: rgb(80%,0%,100%)}
EOF
    cat > testsuite/index.html <<EOF
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html><head><title>CGAL Manual Test-Suite Results</title>
<link href="testresult.css" rel="stylesheet"></head>
<body>

<h1>CGAL-${CgalVersion} Manual Test-Suite Results</h1>

<p><b>Program Test-Suite:</b> [<a href="https://www-sop.inria.fr/geometrica/CGAL/Members/testsuite/">All Releases</a>]<br>
<b>Older Manual Tests: </b>
EOF
    declare -i count=1
    declare -i lastcount=${TestSuiteHistory}
    if [ -d ${TestSuiteResultPath}/CGAL-${CgalVersion} ]; then
        count=2
        lastcount=${lastcount}+1
    fi
    while [ $count -lt ${lastcount} ] ; do
        if [ -r ${TestSuiteResultPath}/History.${count} ]; then
          subdir=`cat ${TestSuiteResultPath}/History.${count}`
          echo "    [<a href=\"../${subdir}/index.html\">${subdir#CGAL-}</a>]"\
                >> testsuite/index.html 
        fi
        count=$count+1
    done
    cat  >> testsuite/index.html <<EOF
</p>

<p>This page shows the results of creating the manuals for
CGAL-${CgalVersion}.  Each Module and each CGAL Package is tested for
problems with LaTeX, BibTeX, makeindex, and latex_to_html
conversions. The success of the conversions and the logfiles are
accessible in the tables below. A 'y' means no blatant errors
occurred, which may be loosely interpreted as 'success', a 'w' means
there was a warning, a 'n' means 'failure', and a '-' means that this part 
was not applicable to this manual. A click on the letter
gives the corresponding logfiles. The first column contains a summary
logfile for a quick overview. </p>

<p><b>The tools are currently under development, please report all
problems to Lutz Kettner and Peter Hachenberger.</b></p>

<ul>
   <li> Due to the separate testing of each package, some references in the 
        LaTeX manual may remain unresolved by the individual package 
        tests. Thus undefined references are not reported as 'w' for packages. 
        Please check the log files, for example, the summary log file, for
        undefined references in packages yourself. For Modules, undefined 
        references are reported as 'w'.</b><p>
   </li><li> <b>The detection of errors is not (yet) exact.  Please check the
        log files even when a 'y' appears suggesting that everything is 
        OK.</b><p>
   </li><li> Suggestions for improving the summary are also welcome.<p>
</li></ul>
<p></p>

<h2>Module Manual Test-Suite for CGAL-${CgalVersion}</h2>

<table cellpadding="5" cellspacing="2" border="1">
<tr align="center">
  <td rowspan="2" align="left"><b>Module</b></td>
  <td colspan="5" align="center"><b>Click to see Logfile</b></td>
  <td colspan="2" align="center"><b>Manuals</b></td>
</tr>
<tr align="center">
  <td><b>Summary</b></td>
  <td><b>LaTeX</b></td>
  <td><b>BibTeX</b></td>
  <td><b>make_index</b></td>
  <td><b>latex_to_html</b></td>
  <td><b>PostScript</b></td>
  <td><b>HTML</b></td>
</tr>
EOF
}

#---------------------------------------------------------------------#
# testsuite_middle
#     - Continues index.html from first (Modules) to second table (Packages)
#---------------------------------------------------------------------#

testsuite_middle () {
    cat >> testsuite/index.html <<EOF
</table>
<p></p>


<h2>Package Manual Test-Suite for CGAL-${CgalVersion}</h2>

<table cellpadding="5" cellspacing="2" border="1">
<tr align="center">
  <td rowspan="2" align="left"><b>Package</b></td>
  <td colspan="5" align="center"><b>Click to see Logfile</b></td>
  <td colspan="2" align="center"><b>Manuals</b></td>
</tr>
<tr align="center">
  <td><b>Summary</b></td>
  <td><b>LaTeX</b></td>
  <td><b>BibTeX</b></td>
  <td><b>make_index</b></td>
  <td><b>latex_to_html</b></td>
  <td><b>PostScript</b></td>
  <td><b>HTML</b></td>
</tr>
EOF
}

#---------------------------------------------------------------------#
# testsuite_end
#     - Creates 'testsuite' subdir
#     - Finishes index.html after second table (Packages)
#     - Moves everything to the testsuite target directory
#       (logfiles, PostScript and HTML results are already copied)
#---------------------------------------------------------------------#

testsuite_end () {
    cat >> testsuite/index.html <<EOF
</table>
<hr>

<div class="contact">
Last modified on <!--#echo var="LAST_MODIFIED" -->.
See <a href="http://www.cgal.org/">http://www.cgal.org/</a> and 
<a HREF="mailto:infoATcgal.org" subject="Mail from cgal.org web page">info at cgal dot org</a>
</div>
</body></html>
EOF
    if [ ! -d ${TestSuiteResultPath} ]; then
        echo "${ErrorColor}ERROR${ResetColor}: The directory '${TestSuiteResultPath}' for the testsuite results does not exist." 1>&2
        GlobalReturnStatus=1
    else

        # When the -testsuite option is used the script will copy all
        # the manuals and logfiles to
        # $TestSuiteResultPath/CGAL-$CgalVersion/ and creates an HTML
        # summary page index.html in that subdirectory. The latest
        # results is also always accessible at
        # $TestSuiteResultPath/last/index.html .  
        #    Futhermore, the script will cleanup old results. For the
        # most recent number $TestSuiteFullHistory of test suites the
        # full results including the manuals are kept. Older test
        # suites will have their manuals deleted to save space. Int
        # total only $TestSuiteHistory many test suites are kept.  
        #    The history of test suites is managed in a shift register
        # like fashion using files in $TestSuiteResultPath of defined
        # names History.<i> that contain the name of the i-th test
        # suite subdirectory. The 1st is the most recent test suite
        # and corresponds to the 'last' directory.
        #    If the test suite is repeated for the same internal 
        # release number, the new results will overwrite the old results.
        pushd ${TestSuiteResultPath} > /dev/null
        Target=CGAL-${CgalVersion}
        if [ ! -d ${Target} ]; then
            # do all the shifting only if test suite is new
            declare -i count=${TestSuiteHistory}
            if [ -r History.${count} ]; then
                subdir=`cat History.${count}`
                if [ -d $subdir ]; then \rm -fr $subdir ; fi
                \rm -f History.${count}
            fi
            while [ $count -gt 1 ] ; do
                oldcount=$count
                count=$count-1
                if [ -r History.${count} ]; then
                    subdir=`cat History.${count}`
                    if [[ ${oldcount} -gt ${TestSuiteFullHistory} && \
                            -d $subdir ]]; then 
                        \rm -f $subdir/*.ps.gz ; 
                        for f in ${subdir}/* ; do
                            if [ -d $f ]; then \rm -fr $f ; fi 
                        done
                        # also eliminate dead links in index.html to doc.
                        \mv ${subdir}/index.html ${subdir}/bak
                        \cat ${subdir}/bak | sed 's/\(class=\"manual\">\).*\(<\/td>\)/\1 -- \2/g' > ${subdir}/index.html
                    fi
                    \mv History.${count} History.${oldcount}
                fi
            done
            echo -n "${Target}" > History.1
            \mkdir ${Target}
            if [ -h LAST ]; then \rm -f LAST ; fi
            \ln -s ${Target} LAST
        fi
        popd  > /dev/null
        cp -r testsuite/* ${TestSuiteResultPath}/${Target}
        rm -r testsuite
        # send email notification
        if [ "${TestSuiteResultEmail}" != "" ]; then
            # Use this line on Sun Solaris systems
            # printf "Subject: New manual test results ${Target}\n\n\n${TestSuiteResultUrl}/${Target}\n" | ${Sendmail} ${TestSuiteResultEmail}
            # use this line on Linux systems
            printf "\n${TestSuiteResultUrl}/${Target}\n" | ${Sendmail} -s "Subject: New manual test results ${Target}" ${TestSuiteResultEmail}            
        fi
    fi
}

#_____________________________________________________________________.
#=====================================================================#
#                                                                     #
# main: read resource file and initialize globals                     #
#                                                                     #
#_____________________________________________________________________#
#=====================================================================#

# Selects the different output formats supported. If any option is
# given, reset all Make<format>'s and set them explicitly only.
SetMakePS=0
SetMakePDF=0
SetMakeHTML=0
Parameters=""

while [ $# -gt 0 ] ; do
  case "$1" in
    -h | --help) 
        usage
        exit 0
        ;;
    -V | --version)
        version
        exit 0
        ;;
    -ps) SetMakePS=1
        ;;
    -pdf) SetMakePDF=1
        ;;
    -html) SetMakeHTML=1
        ;;
    -wrapper) MakeWrapperOnly=1
        ;;
    -testsuite)
        MakeTestSuiteResult=1
        ;;
    -k) KeepLog=1
        NoLog=0
        ;;
    -n) NoLog=1
        KeepLog=0
        ;;
    -q) Quiet=1
        ;;
    -qq) RealQuiet=1
        Quiet=1
        ;;
    -s) Sum=1 ;;
    -v) Verbose=1 ;;
    -*) echo "${ErrorColor}ERROR${ResetColor}: Unknow option '$1'." 1>&2
        usage
        exit 2
        ;;
    *)  Parameters="${Parameters} `echo $1 | sed 's/[/]$//'`"
        # a trailing / (typical for directories) was removed
        if [[ ! -r $1 && ! -d $1 && ! -r $1.tex ]]; then
            echo "${ErrorColor}ERROR${ResetColor}: '$1' must be a Module (tex-file) or Package (directory)." 1>&2
            usage
            exit 2
        fi
        ;;
  esac
  shift
done

# Selects the different output formats supported. If any option is
# given, reset all Make<format>'s and set them explicitly only.
if [[ ${SetMakePS} -eq 1 || ${SetMakePDF} -eq 1 || ${SetMakeHTML} -eq 1 ]]; then
  MakePS=${SetMakePS}
  MakePDF=${SetMakePDF}
  MakeHTML=${SetMakeHTML}
fi
if [ $MakeTestSuiteResult -eq 1 ]; then
  NoLog=0
  KeepLog=1
fi

# Prepare TEXINPUTS and LATEX_CONV_INPUTS
if [ -r Manual/cgal_manual.sty ]; then # case 1: internal release
  export TEXINPUTS=".:Manual:../examples:../demo:${TEXINPUTS}"
  export LATEX_CONV_INPUTS=".:Manual:../examples:../demo:${LATEX_CONV_INPUTS}"
elif [ -r ../../Manual/doc_tex/Manual/cgal_manual.sty ]; then # case 2: package
  export TEXINPUTS=".:../../Manual/doc_tex/Manual:../examples:../demo:${TEXINPUTS}"
  export LATEX_CONV_INPUTS=".:../../Manual/doc_tex/Manual:../examples:../demo:${LATEX_CONV_INPUTS}"
else
  export TEXINPUTS=".:../examples:../demo:${TEXINPUTS}"
  export LATEX_CONV_INPUTS=".:../examples:../demo:${LATEX_CONV_INPUTS}"
  # case 3: all others, need to be checked if it is already in searchpath
  echo "${WarnColor}WARNING${ResetColor}: Could not find cgal_manual.sty. I continue assuming it's in TEXINPUTS," 1>&2
  echo "${WarnColor}WARNING${ResetColor}: and in LATEX_CONV_INPUTS." 1>&2
fi

# Prepare BIBINPUTS
if [ -r Manual/cgal_manual.bib ]; then # case 1: internal release
  export BIBINPUTS="Manual:${BIBINPUTS}"
elif [ -r ../../Manual/doc_tex/Manual/cgal_manual.bib ]; then # case 2: package
  export BIBINPUTS="../../Manual/doc_tex/Manual:${BIBINPUTS}"
else
  # case 3: all others, need to be checked if it is already in searchpath
  echo "${WarnColor}WARNING${ResetColor}: Could not find cgal_manual.bib. I continue assuming it's in BIBINPUTS." 1>&2
fi

GlobalReturnStatus=0
if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_begin ; fi
if [[ "$Parameters" == "" ]]; then
    # no arguments, make Module manuals first
    for m in *[Mm]anual.tex ; do
        make_manual $m
    done
    if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_middle ; fi

    # make Package manuals second
    ManRefList=""
    for m in * ; do
        if [[ -d $m && -r $m/main.tex ]]; then  # it's a package
            # make sure that Manual and Manual_ref are matched up
            if [[ -d ${m}_ref && -r ${m}_ref/main.tex ]]; then
                ManRefList="$ManRefList ${m}_ref"
                make_manual $m ${m}_ref
            elif ! is_in_list $m $ManRefList ; then 
                # check that we did not handle it already as ${m}_ref
                make_manual $m
            fi
        fi
    done
else
    # make manuals given explicitly in the argumentlist
    # make Module manuals first
    for m in ${Parameters} ; do
        if is_module $m ; then
            make_manual $m
        fi
    done
    if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_middle ; fi

    # make Package manuals second
    ManRefList=""
    for m in ${Parameters} ; do
        if ! is_module $m ; then
            # make sure that Manual and Manual_ref are matched up
            if is_in_list ${m}_ref ${Parameters} ; then 
                ManRefList="$ManRefList ${m}_ref"
                make_manual $m ${m}_ref
            elif ! is_in_list $m $ManRefList ; then
                # check that we did not handle it already as ${m}_ref
                make_manual $m
            fi
        fi
    done
fi
if [ $MakeTestSuiteResult -eq 1 ]; then testsuite_end ; fi
exit $GlobalReturnStatus
