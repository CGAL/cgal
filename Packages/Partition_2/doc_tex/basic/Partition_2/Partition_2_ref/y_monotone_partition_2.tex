\begin{ccRefFunction}{y_monotone_partition_2}

\ccDefinition

Function that produces a set of $y$-monotone polygons that 
represent a partitioning of a polygon defined on a sequence of points.
\ccIndexSubitem{polygon partitioning}{y-monotone}

\ccInclude{CGAL/partition_2.h}

\ccFunction{
template <class InputIterator, class OutputIterator, class Traits>
OutputIterator y_monotone_partition_2(InputIterator first, 
                                      InputIterator beyond,
                                      OutputIterator result, 
                                      const Traits& traits = Default_traits);
}
{
computes a partition of the simple, counterclockwise-oriented polygon defined 
by the points in the range [\ccc{first}, \ccc{last}) into $y$-monotone 
polygons. The counterclockwise-oriented partition polygons are written to
the sequence starting at position \ccc{result}.  The past-the-end iterator for 
the resulting sequence of polygons is returned.
}

\ccHeading{Requirements}
%\ccIndexSubitem[C]{y_monotone_partition_2}{preconditions}
\begin{enumerate}
    \item \ccc{Traits} is a model of the concept YMonotonePartitionTraits\_2%
          \ccIndexMainItem[c]{YMonotonePartitionTraits_2} and, for the purposes
          of checking the postcondition that the partition is valid, it should 
          also be a model of YMonotonePartitionIsValidTraits\_2%
          \ccIndexMainItem[c]{YMonotonePartitionIsValidTraits_2}.
    \item \ccc{OutputIterator::value_type} should be 
          \ccc{Traits::Polygon_2}.
    \item \ccc{InputIterator::value_type} should be \ccc{Traits::Point_2},
          which should also be the type of the points stored in an object
          of type \ccc{Traits::Polygon_2}.
    \item Points in the range $[first, beyond)$ must define a simple polygon
          whose vertices are oriented counterclockwise.
\end{enumerate}

The default traits class \ccc{Default_traits} is \ccc{Partition_traits_2},
%\ccIndexTraitsClassDefault{y_monotone_partition_2}
with the representation type determined by \ccc{InputIterator::value_type}.

\ccSeeAlso
\ccRefIdfierPage{CGAL::approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::greene_approx_convex_partition_2} \\
\ccRefIdfierPage{CGAL::optimal_convex_partition_2} \\
\ccRefIdfierPage{CGAL::partition_is_valid_2} \\
\ccRefIdfierPage{CGAL::y_monotone_partition_is_valid_2}

\ccImplementation

This function implements the algorithm presented by de Bert \textit{et al.}
\cite{bkos-cgaa-97} which requires $O(n \log n)$ time
and $O(n)$ space for a polygon with $n$ vertices.

\ccExample


The following code fragment will compute a $y$-monotone partitioning
of the simple polygon \ccc{P} using the default
traits class and store the partition polygons in the list 
\ccc{partition_polys}.

\begin{verbatim}
   #include <CGAL/basic.h>
   #include <CGAL/Cartesian.h>
   #include <CGAL/Polygon_traits_2.h>
   #include <CGAL/partition_2.h>
   #include <list>

   typedef CGAL::Cartesian<double>                           R;
   typedef CGAL::Polygon_traits_2<R>                         Traits;
   typedef Traits::Point_2                                   Point_2;
   typedef std::list<Point_2>                                Container;
   typedef CGAL::Polygon_2<Traits, Container>                Polygon_2;

   Polygon_2            P;
   std::list<Polygon_2> partition_polys;

   // ...
   // insert vertices into P to create a simple CCW-oriented polygon
   // ...
   CGAL::y_monotone_partition_2(P.vertices_begin(),
                                P.vertices_end(),
                                std::back_inserter(partition_polys));
\end{verbatim}



\end{ccRefFunction}
