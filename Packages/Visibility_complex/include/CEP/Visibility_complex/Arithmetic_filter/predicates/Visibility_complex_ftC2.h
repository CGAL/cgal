// ======================================================================
//
// Copyright (c) 1999,2000 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------
// 
// release       :
// release_date  :
// 
// file          : include/CGAL/Arithmetic_filter/
// package       : Interval_arithmetic
// author(s)     : Sylvain Pion <Sylvain.Pion@sophia.inria.fr>
//
// coordinator   : INRIA Sophia-Antipolis (<Mariette.Yvinec@sophia.inria.fr>)
// ======================================================================

// This file is automatically generated by
// scripts/filtered_predicates_generator.pl

#ifndef CGAL_ARITHMETIC_FILTER_VISIBILITY_COMPLEX_FTC2_H
#define CGAL_ARITHMETIC_FILTER_VISIBILITY_COMPLEX_FTC2_H

CGAL_BEGIN_NAMESPACE

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi2_test_expensiveC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R)
{
  try
  {
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return chi2_test_expensiveC2(
		a.interval(),
		b.interval(),
		r.interval(),
		A.interval(),
		B.interval(),
		R.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return chi2_test_expensiveC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_chi2_test_expensiveC2_6
{
  static double _bound;
  static double _epsilon_0;
  static unsigned number_of_failures; // ?
  static unsigned number_of_updates;

  static Sign update_epsilon(
	const Static_filter_error &a,
	const Static_filter_error &b,
	const Static_filter_error &r,
	const Static_filter_error &A,
	const Static_filter_error &B,
	const Static_filter_error &R,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
      
      FT p = CGAL_NTS sqrt(a*a + b*b - r*r);
      FT P = CGAL_NTS sqrt(A*A + B*B - R*R);
      
      FT Sigma = a*A + b*B;
      FT Delta = a*B - b*A;
      
      FT E1 = - R * Sigma;
      
      FT E2 = r * Sigma;
      
      FT E3 = Delta;
      
      FT E4 = r * R * Delta;
      
      return CGAL_NTS Static_Filtered_sign_1::update_epsilon( (E1 + E3 * P) * p + E2 * P + E4 ,
  		epsilon_0);
      
      
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    number_of_updates++;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Sign epsilon_variant(
	const Restricted_double &a,
	const Restricted_double &b,
	const Restricted_double &r,
	const Restricted_double &A,
	const Restricted_double &B,
	const Restricted_double &R,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
      
      FT p = CGAL_NTS sqrt(a*a + b*b - r*r);
      FT P = CGAL_NTS sqrt(A*A + B*B - R*R);
      
      FT Sigma = a*A + b*B;
      FT Delta = a*B - b*A;
      
      FT E1 = - R * Sigma;
      
      FT E2 = r * Sigma;
      
      FT E3 = Delta;
      
      FT E4 = r * R * Delta;
      
      return CGAL_NTS Static_Filtered_sign_1::epsilon_variant( (E1 + E3 * P) * p + E2 * P + E4 ,
  		epsilon_0);
      
      
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi2_test_expensiveC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_chi2_test_expensiveC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(a.to_double()));
    NEW_bound = max(NEW_bound, fabs(b.to_double()));
    NEW_bound = max(NEW_bound, fabs(r.to_double()));
    NEW_bound = max(NEW_bound, fabs(A.to_double()));
    NEW_bound = max(NEW_bound, fabs(B.to_double()));
    NEW_bound = max(NEW_bound, fabs(R.to_double()));
    // Re-adjust the context.
    Static_Filtered_chi2_test_expensiveC2_6::new_bound(NEW_bound);
  }

  try
  {
    return Static_Filtered_chi2_test_expensiveC2_6::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		Static_Filtered_chi2_test_expensiveC2_6::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
    Static_Filtered_chi2_test_expensiveC2_6::number_of_failures++;
    return chi2_test_expensiveC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi2_test_expensiveC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_chi2_test_expensiveC2_6::_bound; )
  CGAL_assertion(!(
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound));

  try
  {
    return Static_Filtered_chi2_test_expensiveC2_6::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		Static_Filtered_chi2_test_expensiveC2_6::_epsilon_0);
  }
  catch (...)
  {
    Static_Filtered_chi2_test_expensiveC2_6::number_of_failures++;
    return chi2_test_expensiveC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi2_testC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R)
{
  try
  {
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return chi2_testC2(
		a.interval(),
		b.interval(),
		r.interval(),
		A.interval(),
		B.interval(),
		R.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return chi2_testC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_chi2_testC2_6
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4;
  static unsigned number_of_failures; // ?
  static unsigned number_of_updates;

  static Sign update_epsilon(
	const Static_filter_error &a,
	const Static_filter_error &b,
	const Static_filter_error &r,
	const Static_filter_error &A,
	const Static_filter_error &B,
	const Static_filter_error &R,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3,
	double & epsilon_4)
  {
    typedef Static_filter_error FT;
  
      
      
      
      
      FT d2 = -1;           
      FT R_square = -1;     
      FT Sigma_square = -1; 
      FT Delta_square = -1; 
      FT R_square_d2 = -1;  
      
      FT Sigma(a*A + b*B);
      Sign sign_Sigma = CGAL_NTS Static_Filtered_sign_1::update_epsilon(Sigma,
  		epsilon_0);
      
      FT Delta(a*B - b*A);
      Sign sign_Delta = CGAL_NTS Static_Filtered_sign_1::update_epsilon(Delta,
  		epsilon_1);
      
      Sign sign_r = CGAL_NTS Static_Filtered_sign_1::update_epsilon(r,
  		epsilon_2);
      Sign sign_R = CGAL_NTS Static_Filtered_sign_1::update_epsilon(R,
  		epsilon_3);
      
      
      
      Sign sign_E1 = opposite( sign_R * sign_Sigma );
      Sign sign_E3 = sign_Delta;                    
  
      Sign sign_E1PE3;                              
      if (sign_E1 == ZERO)         sign_E1PE3 = sign_E3;
      else if (sign_E3 == ZERO)    sign_E1PE3 = sign_E1;
      else if (sign_E1 == sign_E3) sign_E1PE3 = sign_E1;
      else {
  	d2 = a*a + b*b;
  	R_square = R*R;
  	Delta_square = Delta * Delta;
  	R_square_d2 = R_square * d2;
  	if (R_square_d2 > Delta_square)      sign_E1PE3 = POSITIVE;
  	else if (R_square_d2 < Delta_square) sign_E1PE3 = NEGATIVE;
  	else                                 sign_E1PE3 = ZERO;
  	sign_E1PE3 = sign_E1 * sign_E1PE3;
      }
      
      
      
      Sign sign_E2 = sign_r * sign_Sigma;
      Sign sign_E4 = sign_r * sign_R * sign_Delta;
      Sign sign_E2PE4;
      if (sign_E2 == ZERO)         sign_E2PE4 = sign_E4;
      else if (sign_E4 == ZERO)    sign_E2PE4 = sign_E2;
      else if (sign_E2 == sign_E4) sign_E2PE4 = sign_E2;
      else {
  	if (R_square_d2 == -1) {
  	    if (d2 == -1) d2 = a*a + b*b;
  	    if (R_square == -1) R_square = R*R;
  	    R_square_d2 = R_square * d2;
  	}
  	if (Sigma_square == -1) Sigma_square = Sigma * Sigma;
  	if (Sigma_square > R_square_d2)      sign_E2PE4 = POSITIVE;
  	else if (Sigma_square < R_square_d2) sign_E2PE4 = NEGATIVE;
  	else                                 sign_E2PE4 = ZERO;
  	sign_E2PE4 = sign_E2 * sign_E2PE4;
      }
      
      
      
      if (sign_E1PE3 == ZERO)            return sign_E2PE4;
      else if (sign_E2PE4 == ZERO)       return sign_E1PE3;
      else if (sign_E1PE3 == sign_E2PE4) return sign_E1PE3;
      
      
      
      
      
      Sign sign_E5 = opposite( sign_R * sign_Sigma * sign_Delta );
      
      
      
      if (R_square == -1) R_square = R * R;
      FT r_square = r * r;
      if (Sigma_square == -1) Sigma_square = Sigma * Sigma;
      if (Delta_square == -1) Delta_square = Delta * Delta;
      FT D2(A*A + B*B);
      FT P2 = D2 - R_square;
      Sign sign_E6 = CGAL_NTS Static_Filtered_sign_1::update_epsilon( P2 * Delta_square + R_square * Sigma_square -
  				  r_square * D2 * D2 ,
  		epsilon_4);
      
      
      
      if (sign_E5 == ZERO)         return sign_E1PE3 * sign_E6;
      else if (sign_E6 == ZERO)    return sign_E1PE3 * sign_E5;
      else if (sign_E5 == sign_E6) return sign_E1PE3 * sign_E5;
      
      
      
      FT r_R = r * R;
      if (d2 == -1) d2 = a*a + b*b;
      FT p2_P2 = P2 * (d2 - r_square);
      
      
      
      FT t7(CGAL_NTS square(Sigma - r_R));
      Sign sign_E7;
      if (t7 > p2_P2)      sign_E7 = POSITIVE;
      else if (t7 < p2_P2) sign_E7 = NEGATIVE;
      else                 sign_E7 = ZERO;
      
      
      
      FT t8(CGAL_NTS square(Sigma + r_R));
      Sign sign_E8;
      if (t8 > p2_P2)      sign_E8 = POSITIVE;
      else if (t8 < p2_P2) sign_E8 = NEGATIVE;
      else                 sign_E8 = ZERO;
      
      return opposite( sign_E1PE3 * sign_E5 * sign_E7 * sign_E8 );
      
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    number_of_updates++;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Sign epsilon_variant(
	const Restricted_double &a,
	const Restricted_double &b,
	const Restricted_double &r,
	const Restricted_double &A,
	const Restricted_double &B,
	const Restricted_double &R,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3,
	const double & epsilon_4)
  {
    typedef Restricted_double FT;
  
      
      
      
      
      FT d2 = -1;           
      FT R_square = -1;     
      FT Sigma_square = -1; 
      FT Delta_square = -1; 
      FT R_square_d2 = -1;  
      
      FT Sigma(a*A + b*B);
      Sign sign_Sigma = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(Sigma,
  		epsilon_0);
      
      FT Delta(a*B - b*A);
      Sign sign_Delta = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(Delta,
  		epsilon_1);
      
      Sign sign_r = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(r,
  		epsilon_2);
      Sign sign_R = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(R,
  		epsilon_3);
      
      
      
      Sign sign_E1 = opposite( sign_R * sign_Sigma );
      Sign sign_E3 = sign_Delta;                    
  
      Sign sign_E1PE3;                              
      if (sign_E1 == ZERO)         sign_E1PE3 = sign_E3;
      else if (sign_E3 == ZERO)    sign_E1PE3 = sign_E1;
      else if (sign_E1 == sign_E3) sign_E1PE3 = sign_E1;
      else {
  	d2 = a*a + b*b;
  	R_square = R*R;
  	Delta_square = Delta * Delta;
  	R_square_d2 = R_square * d2;
  	if (R_square_d2 > Delta_square)      sign_E1PE3 = POSITIVE;
  	else if (R_square_d2 < Delta_square) sign_E1PE3 = NEGATIVE;
  	else                                 sign_E1PE3 = ZERO;
  	sign_E1PE3 = sign_E1 * sign_E1PE3;
      }
      
      
      
      Sign sign_E2 = sign_r * sign_Sigma;
      Sign sign_E4 = sign_r * sign_R * sign_Delta;
      Sign sign_E2PE4;
      if (sign_E2 == ZERO)         sign_E2PE4 = sign_E4;
      else if (sign_E4 == ZERO)    sign_E2PE4 = sign_E2;
      else if (sign_E2 == sign_E4) sign_E2PE4 = sign_E2;
      else {
  	if (R_square_d2 == -1) {
  	    if (d2 == -1) d2 = a*a + b*b;
  	    if (R_square == -1) R_square = R*R;
  	    R_square_d2 = R_square * d2;
  	}
  	if (Sigma_square == -1) Sigma_square = Sigma * Sigma;
  	if (Sigma_square > R_square_d2)      sign_E2PE4 = POSITIVE;
  	else if (Sigma_square < R_square_d2) sign_E2PE4 = NEGATIVE;
  	else                                 sign_E2PE4 = ZERO;
  	sign_E2PE4 = sign_E2 * sign_E2PE4;
      }
      
      
      
      if (sign_E1PE3 == ZERO)            return sign_E2PE4;
      else if (sign_E2PE4 == ZERO)       return sign_E1PE3;
      else if (sign_E1PE3 == sign_E2PE4) return sign_E1PE3;
      
      
      
      
      
      Sign sign_E5 = opposite( sign_R * sign_Sigma * sign_Delta );
      
      
      
      if (R_square == -1) R_square = R * R;
      FT r_square = r * r;
      if (Sigma_square == -1) Sigma_square = Sigma * Sigma;
      if (Delta_square == -1) Delta_square = Delta * Delta;
      FT D2(A*A + B*B);
      FT P2 = D2 - R_square;
      Sign sign_E6 = CGAL_NTS Static_Filtered_sign_1::epsilon_variant( P2 * Delta_square + R_square * Sigma_square -
  				  r_square * D2 * D2 ,
  		epsilon_4);
      
      
      
      if (sign_E5 == ZERO)         return sign_E1PE3 * sign_E6;
      else if (sign_E6 == ZERO)    return sign_E1PE3 * sign_E5;
      else if (sign_E5 == sign_E6) return sign_E1PE3 * sign_E5;
      
      
      
      FT r_R = r * R;
      if (d2 == -1) d2 = a*a + b*b;
      FT p2_P2 = P2 * (d2 - r_square);
      
      
      
      FT t7(CGAL_NTS square(Sigma - r_R));
      Sign sign_E7;
      if (t7 > p2_P2)      sign_E7 = POSITIVE;
      else if (t7 < p2_P2) sign_E7 = NEGATIVE;
      else                 sign_E7 = ZERO;
      
      
      
      FT t8(CGAL_NTS square(Sigma + r_R));
      Sign sign_E8;
      if (t8 > p2_P2)      sign_E8 = POSITIVE;
      else if (t8 < p2_P2) sign_E8 = NEGATIVE;
      else                 sign_E8 = ZERO;
      
      return opposite( sign_E1PE3 * sign_E5 * sign_E7 * sign_E8 );
      
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi2_testC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_chi2_testC2_6::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(a.to_double()));
    NEW_bound = max(NEW_bound, fabs(b.to_double()));
    NEW_bound = max(NEW_bound, fabs(r.to_double()));
    NEW_bound = max(NEW_bound, fabs(A.to_double()));
    NEW_bound = max(NEW_bound, fabs(B.to_double()));
    NEW_bound = max(NEW_bound, fabs(R.to_double()));
    // Re-adjust the context.
    Static_Filtered_chi2_testC2_6::new_bound(NEW_bound);
  }

  try
  {
    return Static_Filtered_chi2_testC2_6::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		Static_Filtered_chi2_testC2_6::_epsilon_0,
		Static_Filtered_chi2_testC2_6::_epsilon_1,
		Static_Filtered_chi2_testC2_6::_epsilon_2,
		Static_Filtered_chi2_testC2_6::_epsilon_3,
		Static_Filtered_chi2_testC2_6::_epsilon_4);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
    Static_Filtered_chi2_testC2_6::number_of_failures++;
    return chi2_testC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi2_testC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_chi2_testC2_6::_bound; )
  CGAL_assertion(!(
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound));

  try
  {
    return Static_Filtered_chi2_testC2_6::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		Static_Filtered_chi2_testC2_6::_epsilon_0,
		Static_Filtered_chi2_testC2_6::_epsilon_1,
		Static_Filtered_chi2_testC2_6::_epsilon_2,
		Static_Filtered_chi2_testC2_6::_epsilon_3,
		Static_Filtered_chi2_testC2_6::_epsilon_4);
  }
  catch (...)
  {
    Static_Filtered_chi2_testC2_6::number_of_failures++;
    return chi2_testC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi3_testC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &alpha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &beta,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R4)
{
  try
  {
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return chi3_testC2(
		a.interval(),
		b.interval(),
		r.interval(),
		A.interval(),
		B.interval(),
		R.interval(),
		alpha.interval(),
		beta.interval(),
		R1.interval(),
		R4.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return chi3_testC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact(),
		alpha.exact(),
		beta.exact(),
		R1.exact(),
		R4.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_chi3_testC2_10
{
  static double _bound;
  static double _epsilon_0;
  static unsigned number_of_failures; // ?
  static unsigned number_of_updates;

  static Sign update_epsilon(
	const Static_filter_error &a,
	const Static_filter_error &b,
	const Static_filter_error &r,
	const Static_filter_error &A,
	const Static_filter_error &B,
	const Static_filter_error &R,
	const Static_filter_error &alpha,
	const Static_filter_error &beta,
	const Static_filter_error &R1,
	const Static_filter_error &R4,
	double & epsilon_0)
  {
    typedef Static_filter_error FT;
  
      
      FT D2 = A*A + B*B;
      FT d2 = a*a + b*b;
      
      FT Sigma = a*A + b*B;
      FT Delta = a*B - b*A;
      
      FT p2 = d2 - r*r;
      FT p  = CGAL_NTS sqrt(p2);
      FT P2 = D2 - R*R;
      FT P  = CGAL_NTS sqrt(P2);
      
      FT R4_mult_Delta = R4 * Delta;
      
      FT E1 = (a * beta - b * alpha) * D2 - R * R4_mult_Delta;
      FT E2 = r * R4_mult_Delta;
      FT E3 = - R4 * Sigma;
      FT E4 = R1 * d2 * D2 - r * R4 * R * Sigma + r * D2 * (a * alpha + b * beta);
      
      return CGAL_NTS Static_Filtered_sign_1::update_epsilon( (E1 + E3 * P) * p + E2 * P + E4 ,
  		epsilon_0);
      
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    number_of_updates++;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,b,_epsilon_0);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Sign epsilon_variant(
	const Restricted_double &a,
	const Restricted_double &b,
	const Restricted_double &r,
	const Restricted_double &A,
	const Restricted_double &B,
	const Restricted_double &R,
	const Restricted_double &alpha,
	const Restricted_double &beta,
	const Restricted_double &R1,
	const Restricted_double &R4,
	const double & epsilon_0)
  {
    typedef Restricted_double FT;
  
      
      FT D2 = A*A + B*B;
      FT d2 = a*a + b*b;
      
      FT Sigma = a*A + b*B;
      FT Delta = a*B - b*A;
      
      FT p2 = d2 - r*r;
      FT p  = CGAL_NTS sqrt(p2);
      FT P2 = D2 - R*R;
      FT P  = CGAL_NTS sqrt(P2);
      
      FT R4_mult_Delta = R4 * Delta;
      
      FT E1 = (a * beta - b * alpha) * D2 - R * R4_mult_Delta;
      FT E2 = r * R4_mult_Delta;
      FT E3 = - R4 * Sigma;
      FT E4 = R1 * d2 * D2 - r * R4 * R * Sigma + r * D2 * (a * alpha + b * beta);
      
      return CGAL_NTS Static_Filtered_sign_1::epsilon_variant( (E1 + E3 * P) * p + E2 * P + E4 ,
  		epsilon_0);
      
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi3_testC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &alpha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &beta,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R4)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_chi3_testC2_10::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound ||
	fabs(alpha.to_double()) > SAF_bound ||
	fabs(beta.to_double()) > SAF_bound ||
	fabs(R1.to_double()) > SAF_bound ||
	fabs(R4.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(a.to_double()));
    NEW_bound = max(NEW_bound, fabs(b.to_double()));
    NEW_bound = max(NEW_bound, fabs(r.to_double()));
    NEW_bound = max(NEW_bound, fabs(A.to_double()));
    NEW_bound = max(NEW_bound, fabs(B.to_double()));
    NEW_bound = max(NEW_bound, fabs(R.to_double()));
    NEW_bound = max(NEW_bound, fabs(alpha.to_double()));
    NEW_bound = max(NEW_bound, fabs(beta.to_double()));
    NEW_bound = max(NEW_bound, fabs(R1.to_double()));
    NEW_bound = max(NEW_bound, fabs(R4.to_double()));
    // Re-adjust the context.
    Static_Filtered_chi3_testC2_10::new_bound(NEW_bound);
  }

  try
  {
    return Static_Filtered_chi3_testC2_10::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		alpha.dbl(),
		beta.dbl(),
		R1.dbl(),
		R4.dbl(),
		Static_Filtered_chi3_testC2_10::_epsilon_0);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
    Static_Filtered_chi3_testC2_10::number_of_failures++;
    return chi3_testC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact(),
		alpha.exact(),
		beta.exact(),
		R1.exact(),
		R4.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi3_testC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &alpha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &beta,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R4)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_chi3_testC2_10::_bound; )
  CGAL_assertion(!(
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound ||
	fabs(alpha.to_double()) > SAF_bound ||
	fabs(beta.to_double()) > SAF_bound ||
	fabs(R1.to_double()) > SAF_bound ||
	fabs(R4.to_double()) > SAF_bound));

  try
  {
    return Static_Filtered_chi3_testC2_10::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		alpha.dbl(),
		beta.dbl(),
		R1.dbl(),
		R4.dbl(),
		Static_Filtered_chi3_testC2_10::_epsilon_0);
  }
  catch (...)
  {
    Static_Filtered_chi3_testC2_10::number_of_failures++;
    return chi3_testC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact(),
		alpha.exact(),
		beta.exact(),
		R1.exact(),
		R4.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, bool CGAL_IA_PROTECTED,
           class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi3_test_algebraicC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &alpha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &beta,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Dynamic, CGAL_IA_PROTECTED, CGAL_IA_CACHE> &R4)
{
  try
  {
    Protect_FPU_rounding<CGAL_IA_PROTECTED> Protection;
    return chi3_test_algebraicC2(
		a.interval(),
		b.interval(),
		r.interval(),
		A.interval(),
		B.interval(),
		R.interval(),
		alpha.interval(),
		beta.interval(),
		R1.interval(),
		R4.interval());
  } 
  catch (Interval_nt_advanced::unsafe_comparison)
  {
    Protect_FPU_rounding<!CGAL_IA_PROTECTED> Protection(CGAL_FE_TONEAREST);
    return chi3_test_algebraicC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact(),
		alpha.exact(),
		beta.exact(),
		R1.exact(),
		R4.exact());
  }
}

#ifdef CGAL_IA_NEW_FILTERS

struct Static_Filtered_chi3_test_algebraicC2_10
{
  static double _bound;
  static double _epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5,_epsilon_6,_epsilon_7,_epsilon_8,_epsilon_9,_epsilon_10;
  static unsigned number_of_failures; // ?
  static unsigned number_of_updates;

  static Sign update_epsilon(
	const Static_filter_error &a,
	const Static_filter_error &b,
	const Static_filter_error &r,
	const Static_filter_error &A,
	const Static_filter_error &B,
	const Static_filter_error &R,
	const Static_filter_error &alpha,
	const Static_filter_error &beta,
	const Static_filter_error &R1,
	const Static_filter_error &R4,
	double & epsilon_0,
	double & epsilon_1,
	double & epsilon_2,
	double & epsilon_3,
	double & epsilon_4,
	double & epsilon_5,
	double & epsilon_6,
	double & epsilon_7,
	double & epsilon_8,
	double & epsilon_9,
	double & epsilon_10)
  {
    typedef Static_filter_error FT;
  
      
      
      
      
      FT a2(-1); FT b2(-1); FT d2(-1); FT r2(-1);
      FT A2(-1); FT B2(-1); FT D2(-1); FT R2(-1);
      FT alpha2(-1); FT beta2(-1); FT dp2(-1); 
      FT R42(-1); FT R12(-1);
      
      FT Sigma(a*A + b*B); FT Sigma2(-1);
      Sign sign_Sigma = CGAL_NTS Static_Filtered_sign_1::update_epsilon(Sigma,
  		epsilon_0);
      
      FT Delta(a*B - b*A); FT Delta2(-1);
      Sign sign_Delta = CGAL_NTS Static_Filtered_sign_1::update_epsilon(Delta,
  		epsilon_1);
      
      FT delta(a*beta - b*alpha); FT delta2(-1);
      
      Sign sign_r  = CGAL_NTS Static_Filtered_sign_1::update_epsilon(r,
  		epsilon_2);
      Sign sign_R4 = CGAL_NTS Static_Filtered_sign_1::update_epsilon(R4,
  		epsilon_3);
      
      
      
      A2 = A*A; B2 = B*B; D2 = A2 + B2; 
      FT RR4(R * R4);
      FT RR4Delta(RR4 * Delta);
      Sign sign_E1 = CGAL_NTS Static_Filtered_sign_1::update_epsilon( delta * D2 - RR4Delta ,
  		epsilon_4);
      Sign sign_E3 = opposite( sign_R4 * sign_Sigma );  
  
      Sign sign_E1PE3;                              
      if (sign_E1 == ZERO)         sign_E1PE3 = sign_E3;
      else if (sign_E3 == ZERO)    sign_E1PE3 = sign_E1;
      else if (sign_E1 == sign_E3) sign_E1PE3 = sign_E1;
      else {
  	a2 = a*a; b2 = b*b; d2 = a2 + b2; 
  	R42 = R4*R4; R2 = R*R; 
  	Sigma2 = Sigma*Sigma; delta2 = delta*delta;
  	sign_E1PE3 = sign_E1 * CGAL_NTS Static_Filtered_sign_1::update_epsilon( (R2 * d2 - Sigma2) * R42 - 
  						FT(2) * RR4Delta * delta  + 
  						D2 * delta2 ,
  		epsilon_5);
      }
      
      
      
      FT RR4Sigma(RR4 * Sigma);
      FT sigma(a*alpha + b*beta);
      FT rsigma(r * sigma);
      if (d2 == -1) { a2 = a*a; b2 = b*b; d2 = a2 + b2; }
      Sign sign_E2 = sign_r * sign_R4 *  sign_Delta;
      Sign sign_E4 = CGAL_NTS Static_Filtered_sign_1::update_epsilon( D2 * (R1 * d2 + rsigma) - r * RR4Sigma ,
  		epsilon_6);
  
      Sign sign_E2PE4;
      if (sign_E2 == ZERO)         sign_E2PE4 = sign_E4;
      else if (sign_E4 == ZERO)    sign_E2PE4 = sign_E2;
      else if (sign_E2 == sign_E4) sign_E2PE4 = sign_E2;
      else {
  	if (R42 == -1) R42 = R4*R4;
  	if (R2  == -1) R2  = R * R;
  	CGAL_precondition(d2 != -1);
  	Delta2 = Delta*Delta;
  	r2 = r*r;
  	FT tmp(R1 * d2 + rsigma);
  	sign_E2PE4 = CGAL_NTS Static_Filtered_sign_1::update_epsilon( - r2 * R42 * (R2 * d2 - Delta2)
  				    + tmp * (FT(2) * r * RR4Sigma - D2 * tmp) ,
  		epsilon_7);
  	sign_E2PE4 = sign_E2 * sign_E2PE4;
      }
      
      
      
      if (sign_E1PE3 == ZERO)            return sign_E2PE4;
      else if (sign_E2PE4 == ZERO)       return sign_E1PE3;
      else if (sign_E1PE3 == sign_E2PE4) return sign_E1PE3;
      
      
      
      
      
      FT deltap(A*beta - B*alpha);
      if (r2 == -1) r2 = r*r;
      FT E5 = RR4Sigma * Delta - D2 * ( r*R1*Delta + delta*Sigma - r2*deltap );
      Sign sign_E5 = sign_R4 * CGAL_NTS Static_Filtered_sign_1::update_epsilon( E5 ,
  		epsilon_8);
      
      
      
      R12 = R1*R1; if (R2 == -1)  R2 = R*R; if (R42 == -1) R42 = R4*R4;
      FT D4(D2*D2); FT P2(D2 - R2);
      alpha2 = alpha*alpha; beta2 = beta*beta; dp2 = alpha2 + beta2;
      FT sigmap(A*alpha + B*beta);
      if (Sigma2 == -1) Sigma2 = Sigma*Sigma;
      if (Delta2 == -1) Delta2 = Delta*Delta;
      if (delta2 == -1) delta2 = delta*delta;
      FT E6 = R12 * d2 * D4 - FT(2) * r * R1 * D2 * (RR4Sigma - D2 * sigma) 
  	+ R42 * (r2 * D4 - R2 * Delta2 - P2 * Sigma2) 
  	+ FT(2) * RR4 * D2 * (Delta * delta - r2 * sigmap) 
  	- D4 * (delta2 - r2 * dp2);
      Sign sign_E6 = opposite(CGAL_NTS Static_Filtered_sign_1::update_epsilon( E6 ,
  		epsilon_9));
      
      
      
      if (sign_E5 == ZERO)         return sign_E1PE3 * sign_E6;
      else if (sign_E6 == ZERO)    return sign_E1PE3 * sign_E5;
      else if (sign_E5 == sign_E6) return sign_E1PE3 * sign_E5;
      
      
      
      
      
      FT F4 = ((CGAL_NTS square(a*R-B*r) + CGAL_NTS square(A*r+b*R) - Sigma2)*
               (CGAL_NTS square(a*R+B*r) + CGAL_NTS square(A*r-b*R) - Sigma2));
      
      FT f30 = Delta * delta * (Delta2 + d2 * (R2 - D2));
      FT f31 = R1 * Sigma * (Sigma2 + d2 * (R2 - FT(2) * D2));
      FT f32 = (b*beta*Sigma + a*a *sigmap - (Delta + a*B) * delta) * R2 
  	     + A2 * (b*alpha*Delta - a*A*sigma)
  	     - B2 * (a*beta*Delta  + b*B*sigma)
  	     - FT(2) * A * B * (a2*B*alpha + b2*A*beta);
      FT f33 = D2 * R1 * Sigma;
      FT f34 = D2 * sigmap;
      FT F3 = - FT(4) * R * (f30 + r * (f31 + r * (f32 + r * (f33 + r * f34))));
      
      FT deltap2(deltap*deltap); FT sigmap2(sigmap*sigmap);
      FT f20 = FT(2) * d2 * R12 * ( (Sigma2-Delta2)*R2 - D2*Sigma2 ) 
  	   + FT(2) * delta2 * ( (Sigma2 + FT(3)*Delta2)*R2-D2*Sigma2);
      FT f21 = FT(4) * R1 * ( (Sigma2-Delta2)*sigma*R2
  			   -D2*Sigma*( (A*a-b*B)*(a*alpha - b*beta)
  				       + FT(2)*(beta*B*a2 + A*alpha*b2) ) );
      FT f22 = FT(2) * R2 * ( FT(2) * d2 * D2 * R12  
  			  + FT(4)*A*B*a*b*dp2
  			  + FT(8)*a*b*alpha*beta*D2
  			  - FT(2)*a2*B2*beta2
  			  - FT(2)*b2*A2*alpha2
  			  - FT(3)*D2*(a2*beta2 + b2*alpha2)
  			  + (A2 - B2)*(a2*alpha2 - b2*beta2) )
  	    - FT(2) * D2 * ( - R12 * (Sigma-Delta) * (Sigma+Delta)
  			     - D2 * delta2 + d2 * sigmap2
  			     + delta * ( (a*beta + alpha*b)*(B*B-A*A)
  					 + FT(2)*A*B*(a*alpha-b*beta) ) );
      FT f23 = FT(4) * R1 * D2 * ( FT(2) * sigma * R2
  				+ (a*alpha - b*beta)*(A*A-B*B)
  				+ FT(2)*A*B*(alpha*b + a*beta) );
      FT f24 = FT(2) * D2 * (sigmap2 - deltap2 + FT(2) * R2 * dp2);
      FT F2 = f20 + r * (f21 + r * (f22 + r * (f23 + r * f24)));
      
      FT F0p = D2 * (delta2 - r2*dp2 - FT(2) * r * R1 * sigma - R12*d2);
      FT F1 = - FT(4)*R*F0p*(Delta*delta - r*R1*Sigma - r2*sigmap);
      
      FT F0 = CGAL_NTS square(F0p);
      
      
      
      Sign sign_E5E6 = opposite(
  	CGAL_NTS Static_Filtered_sign_1::update_epsilon(F0 + R4 * (F1 + R4 * (F2 + R4 * (F3 + R4 * F4))),
  		epsilon_10));
      
      return opposite( sign_E1PE3 * sign_E5 * sign_E5E6 );
      
  }

  // Call this function from the outside to update the context.
  static void new_bound (const double b) // , const double error = 0)
  {
    _bound = b;
    number_of_updates++;
    // recompute the epsilons: "just" call it over Static_filter_error.
    // That's the tricky part that might not work for everything.
    (void) update_epsilon(b,b,b,b,b,b,b,b,b,b,_epsilon_0,_epsilon_1,_epsilon_2,_epsilon_3,_epsilon_4,_epsilon_5,_epsilon_6,_epsilon_7,_epsilon_8,_epsilon_9,_epsilon_10);
    // TODO: We should verify that all epsilons have really been updated.
  }

  static Sign epsilon_variant(
	const Restricted_double &a,
	const Restricted_double &b,
	const Restricted_double &r,
	const Restricted_double &A,
	const Restricted_double &B,
	const Restricted_double &R,
	const Restricted_double &alpha,
	const Restricted_double &beta,
	const Restricted_double &R1,
	const Restricted_double &R4,
	const double & epsilon_0,
	const double & epsilon_1,
	const double & epsilon_2,
	const double & epsilon_3,
	const double & epsilon_4,
	const double & epsilon_5,
	const double & epsilon_6,
	const double & epsilon_7,
	const double & epsilon_8,
	const double & epsilon_9,
	const double & epsilon_10)
  {
    typedef Restricted_double FT;
  
      
      
      
      
      FT a2(-1); FT b2(-1); FT d2(-1); FT r2(-1);
      FT A2(-1); FT B2(-1); FT D2(-1); FT R2(-1);
      FT alpha2(-1); FT beta2(-1); FT dp2(-1); 
      FT R42(-1); FT R12(-1);
      
      FT Sigma(a*A + b*B); FT Sigma2(-1);
      Sign sign_Sigma = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(Sigma,
  		epsilon_0);
      
      FT Delta(a*B - b*A); FT Delta2(-1);
      Sign sign_Delta = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(Delta,
  		epsilon_1);
      
      FT delta(a*beta - b*alpha); FT delta2(-1);
      
      Sign sign_r  = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(r,
  		epsilon_2);
      Sign sign_R4 = CGAL_NTS Static_Filtered_sign_1::epsilon_variant(R4,
  		epsilon_3);
      
      
      
      A2 = A*A; B2 = B*B; D2 = A2 + B2; 
      FT RR4(R * R4);
      FT RR4Delta(RR4 * Delta);
      Sign sign_E1 = CGAL_NTS Static_Filtered_sign_1::epsilon_variant( delta * D2 - RR4Delta ,
  		epsilon_4);
      Sign sign_E3 = opposite( sign_R4 * sign_Sigma );  
  
      Sign sign_E1PE3;                              
      if (sign_E1 == ZERO)         sign_E1PE3 = sign_E3;
      else if (sign_E3 == ZERO)    sign_E1PE3 = sign_E1;
      else if (sign_E1 == sign_E3) sign_E1PE3 = sign_E1;
      else {
  	a2 = a*a; b2 = b*b; d2 = a2 + b2; 
  	R42 = R4*R4; R2 = R*R; 
  	Sigma2 = Sigma*Sigma; delta2 = delta*delta;
  	sign_E1PE3 = sign_E1 * CGAL_NTS Static_Filtered_sign_1::epsilon_variant( (R2 * d2 - Sigma2) * R42 - 
  						FT(2) * RR4Delta * delta  + 
  						D2 * delta2 ,
  		epsilon_5);
      }
      
      
      
      FT RR4Sigma(RR4 * Sigma);
      FT sigma(a*alpha + b*beta);
      FT rsigma(r * sigma);
      if (d2 == -1) { a2 = a*a; b2 = b*b; d2 = a2 + b2; }
      Sign sign_E2 = sign_r * sign_R4 *  sign_Delta;
      Sign sign_E4 = CGAL_NTS Static_Filtered_sign_1::epsilon_variant( D2 * (R1 * d2 + rsigma) - r * RR4Sigma ,
  		epsilon_6);
  
      Sign sign_E2PE4;
      if (sign_E2 == ZERO)         sign_E2PE4 = sign_E4;
      else if (sign_E4 == ZERO)    sign_E2PE4 = sign_E2;
      else if (sign_E2 == sign_E4) sign_E2PE4 = sign_E2;
      else {
  	if (R42 == -1) R42 = R4*R4;
  	if (R2  == -1) R2  = R * R;
  	CGAL_precondition(d2 != -1);
  	Delta2 = Delta*Delta;
  	r2 = r*r;
  	FT tmp(R1 * d2 + rsigma);
  	sign_E2PE4 = CGAL_NTS Static_Filtered_sign_1::epsilon_variant( - r2 * R42 * (R2 * d2 - Delta2)
  				    + tmp * (FT(2) * r * RR4Sigma - D2 * tmp) ,
  		epsilon_7);
  	sign_E2PE4 = sign_E2 * sign_E2PE4;
      }
      
      
      
      if (sign_E1PE3 == ZERO)            return sign_E2PE4;
      else if (sign_E2PE4 == ZERO)       return sign_E1PE3;
      else if (sign_E1PE3 == sign_E2PE4) return sign_E1PE3;
      
      
      
      
      
      FT deltap(A*beta - B*alpha);
      if (r2 == -1) r2 = r*r;
      FT E5 = RR4Sigma * Delta - D2 * ( r*R1*Delta + delta*Sigma - r2*deltap );
      Sign sign_E5 = sign_R4 * CGAL_NTS Static_Filtered_sign_1::epsilon_variant( E5 ,
  		epsilon_8);
      
      
      
      R12 = R1*R1; if (R2 == -1)  R2 = R*R; if (R42 == -1) R42 = R4*R4;
      FT D4(D2*D2); FT P2(D2 - R2);
      alpha2 = alpha*alpha; beta2 = beta*beta; dp2 = alpha2 + beta2;
      FT sigmap(A*alpha + B*beta);
      if (Sigma2 == -1) Sigma2 = Sigma*Sigma;
      if (Delta2 == -1) Delta2 = Delta*Delta;
      if (delta2 == -1) delta2 = delta*delta;
      FT E6 = R12 * d2 * D4 - FT(2) * r * R1 * D2 * (RR4Sigma - D2 * sigma) 
  	+ R42 * (r2 * D4 - R2 * Delta2 - P2 * Sigma2) 
  	+ FT(2) * RR4 * D2 * (Delta * delta - r2 * sigmap) 
  	- D4 * (delta2 - r2 * dp2);
      Sign sign_E6 = opposite(CGAL_NTS Static_Filtered_sign_1::epsilon_variant( E6 ,
  		epsilon_9));
      
      
      
      if (sign_E5 == ZERO)         return sign_E1PE3 * sign_E6;
      else if (sign_E6 == ZERO)    return sign_E1PE3 * sign_E5;
      else if (sign_E5 == sign_E6) return sign_E1PE3 * sign_E5;
      
      
      
      
      
      FT F4 = ((CGAL_NTS square(a*R-B*r) + CGAL_NTS square(A*r+b*R) - Sigma2)*
               (CGAL_NTS square(a*R+B*r) + CGAL_NTS square(A*r-b*R) - Sigma2));
      
      FT f30 = Delta * delta * (Delta2 + d2 * (R2 - D2));
      FT f31 = R1 * Sigma * (Sigma2 + d2 * (R2 - FT(2) * D2));
      FT f32 = (b*beta*Sigma + a*a *sigmap - (Delta + a*B) * delta) * R2 
  	     + A2 * (b*alpha*Delta - a*A*sigma)
  	     - B2 * (a*beta*Delta  + b*B*sigma)
  	     - FT(2) * A * B * (a2*B*alpha + b2*A*beta);
      FT f33 = D2 * R1 * Sigma;
      FT f34 = D2 * sigmap;
      FT F3 = - FT(4) * R * (f30 + r * (f31 + r * (f32 + r * (f33 + r * f34))));
      
      FT deltap2(deltap*deltap); FT sigmap2(sigmap*sigmap);
      FT f20 = FT(2) * d2 * R12 * ( (Sigma2-Delta2)*R2 - D2*Sigma2 ) 
  	   + FT(2) * delta2 * ( (Sigma2 + FT(3)*Delta2)*R2-D2*Sigma2);
      FT f21 = FT(4) * R1 * ( (Sigma2-Delta2)*sigma*R2
  			   -D2*Sigma*( (A*a-b*B)*(a*alpha - b*beta)
  				       + FT(2)*(beta*B*a2 + A*alpha*b2) ) );
      FT f22 = FT(2) * R2 * ( FT(2) * d2 * D2 * R12  
  			  + FT(4)*A*B*a*b*dp2
  			  + FT(8)*a*b*alpha*beta*D2
  			  - FT(2)*a2*B2*beta2
  			  - FT(2)*b2*A2*alpha2
  			  - FT(3)*D2*(a2*beta2 + b2*alpha2)
  			  + (A2 - B2)*(a2*alpha2 - b2*beta2) )
  	    - FT(2) * D2 * ( - R12 * (Sigma-Delta) * (Sigma+Delta)
  			     - D2 * delta2 + d2 * sigmap2
  			     + delta * ( (a*beta + alpha*b)*(B*B-A*A)
  					 + FT(2)*A*B*(a*alpha-b*beta) ) );
      FT f23 = FT(4) * R1 * D2 * ( FT(2) * sigma * R2
  				+ (a*alpha - b*beta)*(A*A-B*B)
  				+ FT(2)*A*B*(alpha*b + a*beta) );
      FT f24 = FT(2) * D2 * (sigmap2 - deltap2 + FT(2) * R2 * dp2);
      FT F2 = f20 + r * (f21 + r * (f22 + r * (f23 + r * f24)));
      
      FT F0p = D2 * (delta2 - r2*dp2 - FT(2) * r * R1 * sigma - R12*d2);
      FT F1 = - FT(4)*R*F0p*(Delta*delta - r*R1*Sigma - r2*sigmap);
      
      FT F0 = CGAL_NTS square(F0p);
      
      
      
      Sign sign_E5E6 = opposite(
  	CGAL_NTS Static_Filtered_sign_1::epsilon_variant(F0 + R4 * (F1 + R4 * (F2 + R4 * (F3 + R4 * F4))),
  		epsilon_10));
      
      return opposite( sign_E1PE3 * sign_E5 * sign_E5E6 );
      
  }
};

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi3_test_algebraicC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &alpha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &beta,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, true, CGAL_IA_CACHE> &R4)
{
//   bool re_adjusted = false;
  const double SAF_bound = Static_Filtered_chi3_test_algebraicC2_10::_bound;

  // Check the bounds.  All arguments must be <= SAF_bound.
  if (
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound ||
	fabs(alpha.to_double()) > SAF_bound ||
	fabs(beta.to_double()) > SAF_bound ||
	fabs(R1.to_double()) > SAF_bound ||
	fabs(R4.to_double()) > SAF_bound)
  {
// re_adjust:
    // Compute the new bound.
    double NEW_bound = 0.0;
    NEW_bound = max(NEW_bound, fabs(a.to_double()));
    NEW_bound = max(NEW_bound, fabs(b.to_double()));
    NEW_bound = max(NEW_bound, fabs(r.to_double()));
    NEW_bound = max(NEW_bound, fabs(A.to_double()));
    NEW_bound = max(NEW_bound, fabs(B.to_double()));
    NEW_bound = max(NEW_bound, fabs(R.to_double()));
    NEW_bound = max(NEW_bound, fabs(alpha.to_double()));
    NEW_bound = max(NEW_bound, fabs(beta.to_double()));
    NEW_bound = max(NEW_bound, fabs(R1.to_double()));
    NEW_bound = max(NEW_bound, fabs(R4.to_double()));
    // Re-adjust the context.
    Static_Filtered_chi3_test_algebraicC2_10::new_bound(NEW_bound);
  }

  try
  {
    return Static_Filtered_chi3_test_algebraicC2_10::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		alpha.dbl(),
		beta.dbl(),
		R1.dbl(),
		R4.dbl(),
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_0,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_1,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_2,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_3,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_4,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_5,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_6,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_7,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_8,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_9,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_10);
  }
  catch (...)
  {
    // if (!re_adjusted) {  // It failed, we re-adjust once.
      // re_adjusted = true;
      // goto re_adjust;
    // }
    Static_Filtered_chi3_test_algebraicC2_10::number_of_failures++;
    return chi3_test_algebraicC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact(),
		alpha.exact(),
		beta.exact(),
		R1.exact(),
		R4.exact());
  }
}

#ifndef CGAL_CFG_MATCHING_BUG_2
template < class CGAL_IA_CT, class CGAL_IA_ET, class CGAL_IA_CACHE >
#else
static
#endif
/*  */
Sign
chi3_test_algebraicC2(
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &a,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &b,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &r,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &A,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &B,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &alpha,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &beta,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R1,
    const Filtered_exact <CGAL_IA_CT, CGAL_IA_ET, Static, false, CGAL_IA_CACHE> &R4)
{
  CGAL_assertion_code(
    const double SAF_bound = Static_Filtered_chi3_test_algebraicC2_10::_bound; )
  CGAL_assertion(!(
	fabs(a.to_double()) > SAF_bound ||
	fabs(b.to_double()) > SAF_bound ||
	fabs(r.to_double()) > SAF_bound ||
	fabs(A.to_double()) > SAF_bound ||
	fabs(B.to_double()) > SAF_bound ||
	fabs(R.to_double()) > SAF_bound ||
	fabs(alpha.to_double()) > SAF_bound ||
	fabs(beta.to_double()) > SAF_bound ||
	fabs(R1.to_double()) > SAF_bound ||
	fabs(R4.to_double()) > SAF_bound));

  try
  {
    return Static_Filtered_chi3_test_algebraicC2_10::epsilon_variant(
		a.dbl(),
		b.dbl(),
		r.dbl(),
		A.dbl(),
		B.dbl(),
		R.dbl(),
		alpha.dbl(),
		beta.dbl(),
		R1.dbl(),
		R4.dbl(),
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_0,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_1,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_2,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_3,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_4,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_5,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_6,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_7,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_8,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_9,
		Static_Filtered_chi3_test_algebraicC2_10::_epsilon_10);
  }
  catch (...)
  {
    Static_Filtered_chi3_test_algebraicC2_10::number_of_failures++;
    return chi3_test_algebraicC2(
		a.exact(),
		b.exact(),
		r.exact(),
		A.exact(),
		B.exact(),
		R.exact(),
		alpha.exact(),
		beta.exact(),
		R1.exact(),
		R4.exact());
  }
}

#endif // CGAL_IA_NEW_FILTERS

CGAL_END_NAMESPACE

#endif // CGAL_ARITHMETIC_FILTER_VISIBILITY_COMPLEX_FTC2_H
