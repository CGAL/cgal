% +------------------------------------------------------------------------+
% | Reference manual page: Planar_map_traits.tex (Planar_map)
% +------------------------------------------------------------------------+
% | 
% | Package: pm (Planar_map_2)
% | 
% +------------------------------------------------------------------------+

\ccRefPageBegin

\begin{ccRefConcept}{PlanarMapTraits_2}
\label{PM_sec:req:interface} 
 
%\label{I1_S}} 

\ccCreationVariable{pm_traits}

\ccDefinition
A model of the \ccRefName\ concept aggregates the geometric types and
primitive operations used by the 
\ccc{Planar_map_2<PlanarMapDcel_2,PlanarMapTraits_2>} data structure.
It must provide the types and operations listed below.

\ccTypes

The geometric types defined below must have a default constructor,
copy constructor, assignment operator and \ccStyle{operator==}.
    
\ccNestedType{X_monotone_curve_2}{A type that holds an $x$-monotone curve in
  the plane.}

\ccNestedType{Point_2}{A type that holds the position of a vertex in
  the plane. The type of the end points of \ccc{X_monotone_curve_2} curves.}

\ccHeading{Categories}

The following categories declare the implementation of the method 
\ccc{curves_compare_y_at_x_left()}. If the category  \ccc{Has_left_category}
is \ccc{Tag_true} the method is required specifically. Otherwise, if 
the category  \ccc{Has_reflect_category} is \ccc{Tag_true} the method 
\ccc{curves_compare_y_at_x_left()} is implemented using the required 
methods \ccc{point_reflect_in_x_and_y()} and \ccc{curve_reflect_in_x_and_y()}.
If none of the categories is \ccc{Tag_true}, a default implementation is used, 
that does not require any of the above methods.

\ccNestedType{Has_left_category}{A boolean category that indicates
  whether the method \ccc{curves_compare_y_at_x_left()} is required.
  It must be either \ccc{Tag_true} or \ccc{Tag_false}.}

\ccNestedType{Has_reflect_category}{A boolean category that indicates
  whether the methods \ccc{point_reflect_in_x_and_y()} and
  \ccc{curve_reflect_in_x_and_y()} are required. It must be either
  \ccc{Tag_true} or \ccc{Tag_false}.}


\ccHeading{Enumerations}
\ccEnum{enum Comparison_result {SMALLER, EQUAL, LARGER};}
{a constant describing the relative position between objects.}
   
\ccCreation
    
% Only a default constructor is required. Note that further constructors
% can be provided.

\ccConstructor{Traits();}
{A default constructor.}

\ccOperations
The following methods that have a curve parameter of type
\ccc{X_monotone_curve_2} have the implicit precondition that requires the
curve to be $x$-monotone.

% \ccSetTwoOfThreeColumns{4cm}{4cm}

% predicates
% ----------

\ccMethod{Comparison_result compare_x(const Point_2& p0, const Point_2& p1);}
         {compares the \ccStyle{x}-coordinates of $p0$ and $p1$.  Returns
          \ccStyle{LARGER} if $x(p0) > x(p1)$; \ccStyle{SMALLER} if
	  $x(p0) < x(p1)$; \ccStyle{EQUAL} otherwise.}
    
\ccMethod{Comparison_result compare_xy(const Point_2& p0, const Point_2& p1);}
	 {compares the two points $p0$ and $p1$ lexigoraphically. First the
	   $x$-coordinates are compared. In case of a tie, the $y$-coordinates
	   are compared. Returns \ccStyle{LARGER} if $x(p1) > x(p2)$, or if
	   $x(p1) = x(p2)$ and $y(p1) > y(p2)$;
	   \ccStyle{SMALLER} if $x(p1) < x(p2)$, or if $x(p1) = x(p2)$ and
	   $y(p1) < y(p2)$;
	   \ccStyle{EQUAL} otherwise.}

\ccMethod{bool curve_is_vertical(const X_monotone_curve_2& cv);} 
         {returns \ccStyle{true} if \ccStyle{cv} is a vertical segment, 
          \ccStyle{false} otherwise.}
        
\ccMethod{bool point_in_x_range(const X_monotone_curve_2& cv,
                                const Point_2& pnt );}
         {returns \ccStyle{true} if \ccStyle{pnt} is in the $x$ range of
          \ccStyle{cv}, \ccStyle{false} otherwise.}
    
\ccMethod{Comparison_result curves_compare_y_at_x(const X_monotone_curve_2& cv1,
                                                  const X_monotone_curve_2& cv2,
						  const Point_2& pnt );}
         {compares the $y$-coordinate of $cv1$ and $cv2$ at the $x$-coordinate 
          of $pnt$. Returns \ccStyle{LARGER} if $cv1(x(q)) > cv2(x(q))$;
          \ccStyle{SMALLER} if $cv1(x(q)) < cv2(x(q))$; \ccStyle{EQUAL}
	  otherwise.
          \ccPrecond{$cv1$ and $cv2$ are defined at $pnt$'s $x$-coordinate.}}

\ccMethod{Comparison_result
  curves_compare_y_at_x_right(const X_monotone_curve_2& cv1,
                              const X_monotone_curve_2& cv2,
			      const Point_2& pnt);}
         {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the
	   right of the $x$-coordinate of $pnt$.
           \ccPrecond{$cv1$ and $cv2$ meet at $pnt$ $x$-coordinate.}
           \ccPrecond{$cv1$ and $cv2$ are defined lexigoraphically to
           the right of $pnt$'s $x$-coordinate.}}
    
\ccMethod{Comparison_result
  curves_compare_y_at_x_left(const X_monotone_curve_2& cv1,
                             const X_monotone_curve_2& cv2,
			     const Point_2& pnt);}
         {compares the $y$-coordinate of $cv1$ and $cv2$ immediately to the
           left of the $x$-coordinate of $pnt$. This predicate is not
	   required for the aggregate insertion of curves into the planar map.
	   Recall, that the aggregate insertion is based on a sweep-line
	   algorithm.
           \ccPrecond{$cv1$ and $cv2$ meet at $pnt$ $x$-coordinate.}
           \ccPrecond{$cv1$ and $cv2$ are defined lexigoraphically to
           the left of $pnt$'s $x$-coordinate.}}
    
\ccMethod{Point_2 point_reflect_in_x_and_y(const Point_2& pt);}
         {returns the reflection of the point \ccStyle{pt} about the origin
	   For example, the reflection of the point $(2,2)$ is the point as
	   $(-2,-2)$. This predicate is not required for the aggregate
	   insertion of curves into the planar map, or if the method
	   \ccc{curves_compare_y_at_x_left()} is provided and
	   the \ccc{Has_left_category} category is \ccc{Tag_true}.}
	   
\ccMethod{X_monotone_curve_2
  curve_reflect_in_x_and_y(const X_monotone_curve_2& cv);}
         {returns the reflection of the curve \ccc{cv} about the origin.
          For example, the reflection of the line segment $((2,2),(3,3))$
	  is $((-2,-2),(-3,-3))$. This predicate is not required for the
	  aggregate insertion of curves into the planar map, or if the method
	  \ccc{curves_compare_y_at_x_left()} is provided and the
	  \ccc{Has_left_category} category is \ccc{Tag_true}.}

\ccMethod{Comparison_result curve_compare_y_at_x(const Point_2 & pnt,
                                                 const X_monotone_curve_2 & cv);}
         {compares the $y$-coordinates of $pnt$ and the vertical projection of
	   $pnt$ on $cv$. Returns \ccStyle{SMALLER} if $y(pnt) < cv(x(pnt))$;
	   \ccStyle{LARGER} if $y(pnt) > cv(x(pnt))$;
	   \ccStyle{EQUAL} otherwise ($pnt$ is on the curve).
           \ccPrecond{$cv$ is defined at $pnt$'s $x$-coordinate.}}

\ccMethod{bool curve_equal(const X_monotone_curve_2 & cv1,
                           const X_monotone_curve_2 & cv2);}
         {returns \ccc{true} if \ccc{cv1} and \ccc{cv2} have the same graph, 
           \ccc{false} otherwise.}

\ccMethod{bool point_equal(const Point_2 & p1, const Point_2 & p2);}
         {returns \ccc{true} if \ccc{p1} is the same as \ccc{p2}, \ccc{false}
           otherwise.}
	  
%construction function
%---------------------   

\ccMethod{Point_2 curve_source(const X_monotone_curve_2& cv);}
         {returns the source of \ccc{cv}.}

\ccMethod{Point_2 curve_target(const X_monotone_curve_2& cv);}
             {returns the target of \ccc{cv}.}

%additions needed for the default point location strategy

%      \smallskip {\noindent \bf \large Requirements for
%         \ccStyle{Info_face}, \ccStyle{Info_edge}, \ccStyle{Info_vertex}}
      
%      All info types should have a constructor and a copy
%      constructor.

\ccHasModels
  \ccc{Pm_segment_traits_2<Kernel>}

The \ccc{PlanarMapWithIntersectionsTraits_2} and
\ccc{ArrangementTraits_2} concepts are refinements of the
\ccc{PlanarMapTraits_2} concept, in other words, a model of the
formers is a model of the latter.  Thus, all
supplied (or user written ) arrangement traits classes can be passed
as the \ccc{Traits} template parameter when instantiating an object of
type \ccc{Planar_map_2<Dcel,Traits>}.  See the list of the arrangement
traits classes in chapter ~\ref{I1_ChapterArrangement_2},
{\em Arrangement}.
  
\end{ccRefConcept} % Pm_traits

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+
