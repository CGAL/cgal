% +------------------------------------------------------------------------+
% | CGAL Reference Manual:  stl_extension.tex
% +------------------------------------------------------------------------+
% | STL Extensions for CGAL.
% |
% | 11.10.1996   Lutz Kettner
% |
% |
\RCSdef{\stlExtensionRev}{$Revision$}
\RCSdefDate{\stlExtensionDate}{$Date$}
% +------------------------------------------------------------------------+

\ccParDims

\chapter{\stl\ Extensions for \cgal}
\label{chapterDataStructures}
\label{chapterStlExtensions}
\ccChapterRelease{\stlExtensionRev. \ \stlExtensionDate}\\
\ccChapterAuthor{Michael Hoffmann}\\
\ccChapterAuthor{Lutz Kettner}

\cgal\ is designed in the spirit of the generic programming paradigm
to work together with the Standard Template Library (\stl)
\cite{c-wpdpi-96,ms-strg-96}.  This chapter documents non-geometric
\stl-like components that are not provided in the \stl\ standard but
in \cgal: a doubly-connected list managing items in place
(where inserted items are not copied), generic
functions, function objects for projection and creation, classes for
composing function objects and adaptor classes around iterators and
circulators. See also circulators in Chapter~\ref{chapterCirculators}.


% +=========================================================================+
\section{Doubly-Connected List Managing Items in Place}
% +=========================================================================+

The class \ccStyle{In_place_list<T,&T::next,&T::prev>} manages a
sequence of items in place in a doubly-connected list. Its goals are
the flexible handling of memory management and performance
optimization. The item type is supposed to provide the two necessary
pointers \ccc{&T::next_link} and \ccc{&T::prev_link}. One possibility
to obtain these pointers is to inherit them from the base class
\ccStyle{In_place_list_base<T>}.

The class \ccStyle{In_place_list<T>} is a container and quite
similar to \stl\ containers, with the advantage that it is able to
handle the stored elements by reference instead of copying them. It is
possible to delete an element only knowing its address and no iterator
to it. This simplifies mutually pointered data structures like a
halfedge data structure for planar maps or polyhedral surfaces. The
usual iterators are also available.  Another container with this
property of working with pointers to objects is the \stl\ vector (at
least in the current \stl\ implementations).


% +--------------------------------------------------------+
\subsection{Base Classes for List Nodes}

\ccDefinition

The node base classes provides pointers to build linked
lists. The class \ccStyle{In_place_sl_list_base<T>} provides a pointer
\ccStyle{next_link} for a single linked list. The class
\ccStyle{In_place_list_base<T>} provides an additional pointer
\ccStyle{prev_link} for doubly linked lists. These names conform to
the default parameters used in the template argument lists of the
container classes. The pointers are public members.

\ccInclude{CGAL/In_place_list.h}
\ccSetThreeColumns{T*}{next_link ;}{}

\begin{ccClassTemplate}{In_place_list_base<T>}
\ccVariable{T* next_link;}{forward pointer}
\ccGlue
\ccVariable{T* prev_link;}{backward pointer}
\end{ccClassTemplate}

% +--------------------------------------------------------+
\begin{ccClassTemplate}{In_place_list<T,bool>}
\ccSubsection{Container Class}

\ccDefinition

An object of the class \ccClassTemplateName\ represents a sequence of
items of type \ccc{T} that supports bidirectional iterators and allows
constant time insert and erase operations anywhere within the
sequence. The functionality is similar to the \ccStyle{list<T>} in the
\stl.

The \ccClassTemplateName\ manages the items in place, i.e.~inserted
items are not copied. Two pointers of type \ccStyle{T*} are expected
to be reserved in \ccc{T} for the list management. The base class
\ccStyle{In_place_list_base<T>} can be used to obtain such pointers.

The \ccClassTemplateName\ does not copy element items during insertion
(unless otherwise stated for a function). On removal of an item or
destruction of the list the items are not deleted by default.  The
second template parameter \ccStyle{bool} is set to \ccStyle{false} in
this case. If the \ccClassTemplateName\ should take the responsibility
for the stored objects the \ccStyle{bool} parameter could be set to
\ccStyle{true}, in which case the list will delete removed items and
will delete all remaining items on destruction. In any case, the
\ccStyle{destroy()} member function deletes all items.  Note that
these two possible versions of \ccClassTemplateName\ are not
assignable to each other to avoid confusions between the different
storage responsibilities.

\ccInclude{CGAL/In_place_list.h}

% +-----------------------------------+
\ccParameters

The full class name is \ccStyle{In_place_list<T,bool managed =
  false, T* T::*next = &T::next_link, T* T::*prev =
  &T::prev_link>}. As long as no default template arguments are
supported, only \ccClassTemplateName\ is provided.

The parameter \ccStyle{T} is supposed to have a default constructor, a
copy constructor and an assignment operator. The copy constructor and
the assignment may not copy the pointers in \ccc{T} for the list
management, but they are allowed to. The equality test and the
relational order require the operators \ccStyle{==} and \ccStyle{<}
for $T$ respectively. These operators must not compare the pointers in
\ccc{T}.

% +-----------------------------------+
\ccTypes
\ccSetThreeColumns{In_place_list<T,bool> &}{l.swap( l1);}{}
\ccPropagateThreeToTwoColumns

\ccNestedType{iterator}{}
\ccGlue
\ccNestedType{const_iterator}{}

\ccNestedType{value_type}{}
\ccGlue
\ccNestedType{reference}{}
\ccGlue
\ccNestedType{const_reference}{}
\ccGlue
\ccNestedType{size_type}{}
\ccGlue
\ccNestedType{difference_type}{}

\ccNestedType{reverse_iterator}{}
\ccGlue
\ccNestedType{const_reverse_iterator}{}

% +-----------------------------------+
\ccCreation
\ccCreationVariable{l}

\ccConstructor{In_place_list();}
             {introduces an empty list.}

\ccConstructor{In_place_list(const list<T> &l1);}
            {copy constructor. Each item in \ccStyle{l1} is copied.}

\ccConstructor{In_place_list(size_type n, const T& t = T() );}
            {introduces a list with $n$ items, all initialized with
              copies of $t$.}

\ccConstructor{template <class InputIterator>
               In_place_list( InputIterator first, InputIterator last);}
            {a list with copies from the range [\ccStyle{first,last}).}

\ccConstructor{In_place_list( const T* first, const T* last);}
            {non-member-template version.}

\ccMethod{In_place_list<T,bool> & operator=(const
              In_place_list<T,bool> &l1);} 
        {assignment. Each item in \ccStyle{l1} is copied. Each item in
          \ccVar\ is deleted if the \ccStyle{bool} parameter is
          \ccStyle{true}.}

\ccMethod{void swap( const In_place_list<T,bool> &l1);} 
        {swaps the contents of \ccVar\ with \ccStyle{l1}.}

\ccMethod{void destroy();} 
        {all items in \ccVar\ are deleted regardless of the
          \ccStyle{bool} parameter.} 


% +-----------------------------------+
\ccHeading{Comparison Operations}
\ccSetThreeColumns{const_iterator}{l.erase( iterator pos);}{}

\ccMethod{bool operator==(const In_place_list<T,bool> &l1) const;}
       {test for equality: Two lists are equal, iff they have the same size
        and if their corresponding elements are equal.}

\ccMethod{bool operator<(const In_place_list<T,bool> &l1) const;}
       {compares in lexicographical order.}


% +-----------------------------------+
\ccHeading{Access Member Functions}

\def\ccTagRmTrailingConst{\ccFalse}
\ccMethod{iterator begin();}
       {returns a mutable iterator referring to the first element in~\ccVar.}
\ccGlue
\ccMethod{const_iterator begin() const;}
       {returns a constant iterator referring to the first element in~\ccVar.}
\ccGlue
\ccMethod{iterator end();}
       {returns a mutable iterator which is the past-end-value of~\ccVar.}
\ccGlue
\ccMethod{const_iterator end() const;}
       {returns a constant iterator which is the past-end-value of~\ccVar.}
\def\ccTagRmTrailingConst{\ccTrue}

\ccMethod{bool empty() const;}
       {returns \ccStyle{true} if \ccVar\ is empty.}
\ccGlue
\ccMethod{size_type size() const;}
       {returns the number of items in list~\ccVar.}
\ccGlue
\ccMethod{size_type max_size() const;}
       {returns the maximum possible size of the list~\ccVar.}

\ccMethod{T& front();}
       {returns the first item in list~\ccVar.}
\ccGlue
\ccMethod{T& back();}
       {returns the last item in list~\ccVar.}

\ccHidden\ccMethod{const T& back() const;}{}
\ccHidden\ccMethod{const T& front() const;}{}


% +-----------------------------------+
\ccHeading{Insertion}

\ccMethod{void  push_front( T&);}
       {inserts an item in front of list~\ccVar.}
\ccGlue
\ccMethod{void push_back( T&);}
       {inserts an item at the back of list~\ccVar.}

\ccMethod{iterator insert(iterator pos, T& t);}{}
\ccGlue
\ccMethod{iterator insert(T* pos, T& t);}
 {inserts  \ccStyle{t} in front of \ccStyle{pos}.
  The return value points to the inserted item.}

\ccMethod{void insert(iterator pos, size_type n, const T& t = T());}{}
\ccGlue
\ccMethod{void insert(T* pos, size_type n, const T& t = T());}
 {inserts $n$ copies of \ccStyle{t} in front of \ccStyle{pos}.}


\ccMethod{template <class InputIterator>
          void insert(iterator pos,
                      InputIterator first,
                      InputIterator last);}{}

\ccMethod{template <class InputIterator>
          void insert(T* pos,
                      InputIterator first,
                      InputIterator last);}
 {inserts the range [\ccStyle{first, last}) in front of iterator
   \ccStyle{pos}.}

As long as member templates are not supported, member functions using
\ccStyle{T*} instead of the general \ccStyle{InputIterator} are provided.

\ccHidden\ccMethod{void insert(iterator pos, const T* first, const T* last);}
 {non-member-template version.}
\ccHidden\ccMethod{void insert(T* pos, const T* first, const T* last);}
 {non-member-template version.}


% +-----------------------------------+
\ccHeading{Removal}

\ccMethod{void pop_front();}
 {removes the first item from list~\ccVar.}
\ccGlue
\ccMethod{void pop_back();}
 {removes the last item from list~\ccVar.}
\ccGlue
\ccMethod{void erase(iterator pos);}
 {removes the item from list~\ccVar, where \ccStyle{pos} refers to.}
\ccGlue
 \ccMethod{void erase(T* pos);}
 {removes the item from list~\ccVar, where \ccStyle{pos} refers to.}

\ccMethod{void erase(iterator first, iterator last);}{}
\ccGlue
\ccMethod{void erase(T* first, T* last);}
 {removes the items in the range [\ccStyle{first, last}) from~\ccVar.}


% +-----------------------------------+
\ccHeading{Special List Operations}

\ccSetThreeColumns{const_iterator}{l.erase( iterator pos);}{}

\ccMethod{void splice(iterator pos, In_place_list<T,bool>& x);}{}
\ccGlue
\ccMethod{void splice(T* pos, In_place_list<T,bool>& x);}
    {inserts the list $x$ before position \ccStyle{pos} and $x$
      becomes empty. It takes constant time. 
     \ccPrecond \ccc{&} \ccVar \ccc{!= &x}.}

\ccMethod{ void splice(iterator pos, In_place_list<T,bool>& x, 
                       iterator i);}{}
\ccGlue
\ccMethod{ void splice(T* pos, In_place_list<T,bool>& x, 
                       T* i);}
    {inserts an element pointed to by $i$ from list $x$ before
      position \ccStyle{pos} and removes the element from $x$. It
      takes constant time. $i$ is a valid dereferenceable iterator of
      $x$. The result is unchanged if \ccStyle{pos == i} or
      \ccStyle{pos == ++i}.}

\ccMethod{void splice(iterator pos, In_place_list<T,bool>& x, 
                      iterator first, iterator last);}{}
\ccGlue
\ccMethod{void splice(T* pos, In_place_list<T,bool>& x, 
                      T* first, T* last);}
    {inserts elements in the range [\ccStyle{first, last}) before
      position \ccStyle{pos} and removes the elements from $x$. It
      takes constant time if \ccStyle{&x == &}\ccVar; otherwise, it
      takes linear time. [\ccStyle{first, last}) is a valid range in
      $x$.
    \ccPrecond \ccStyle{pos} is not in the range [\ccStyle{first, last}).}

\ccMethod{void remove(const T& value);}
    {erases all elements $e$ in the list \ccVar\ for which \ccStyle{e
        == value}. It is stable. 
    \ccPrecond a suitable \ccStyle{operator==} for the type $T$.}

\ccMethod{void unique();}
    {erases all but the first element from every consecutive group of
      equal elements in the list \ccVar.
    \ccPrecond a suitable \ccStyle{operator==} for the type $T$.}

\ccMethod{void merge(In_place_list<T,bool>& x);}
    {merges the list $x$ into the list \ccVar\ and $x$ becomes
      empty. It is stable.
    \ccPrecond Both lists are increasingly sorted. A suitable
    \ccStyle{operator<} for the type $T$.}

\ccMethod{void reverse();}
    {reverses the order of the elements in \ccVar\ in linear time.}

\ccMethod{void sort();}
    {sorts the list \ccVar\ according to the \ccStyle{operator<} in
      time $O(n \log n)$ where \ccStyle{n = size()}. It is stable.
    \ccPrecond a suitable \ccStyle{operator<} for the type $T$.}

\newpage
\ccExample

\ccIncludeVerbatim{in_place_list_prog.C}


% \ccImplementation

% \begin{tabular}{ll}
% {\em Quality:\/} & Experimental tests.\\
%                  & Runtime test ({\tt purify}).
% \end{tabular}


% The in-place list is adapted from the \ccStyle{list<T>} of the
% Standard Template Library (STL). The following notice applies for part
% of the code:
% 
% Copyright (c) 1994\\
% Hewlett-Packard Company
% 
% Permission to use, copy, modify, distribute and sell this software
% and its documentation for any purpose is hereby granted without fee,
% provided that the above copyright notice appear in all copies and
% that both that copyright notice and this permission notice appear
% in supporting documentation.  Hewlett-Packard Company makes no
% representations about the suitability of this software for any
% purpose.  It is provided "as is" without express or implied warranty.

\end{ccClassTemplate}


% +=========================================================================+
\newpage
\section{Generic Functions}
% +=========================================================================+
\label{sectionGenericFunctions}

% +---------------------------------------------+
\subsection{Copy $n$ Items}
\label{sectionCopyN}
\ccThree{OutputIterator}{copy_n}{}

\ccc{copy_n()} copies $n$ items from an input iterator to an
output iterator which is useful for possibly infinite sequences of 
random geometric objects\footnote{%
  The \stl\ release June 13, 1997, from SGI has a new function
  \ccc{copy_n} which is equivalent with \ccc{copy_n}.}.

\ccInclude{CGAL/copy_n.h}

\ccFunction{template <class InputIterator, class Size, class OutputIterator>
  OutputIterator copy_n( InputIterator first, Size n, 
  OutputIterator result);}
{copies the first $n$ items from \ccc{first} to \ccc{result}.
    Returns the value of \ccc{result} after inserting the $n$ items.}

\ccSeeAlso

\ccc{Counting_iterator}.



% +=========================================================================+
\newpage
\section{Function Objects}
% +=========================================================================+

Two kinds of function objects are provided: Projections and Creators.

% +--------------------------------------------------------+
\subsection{Projection Function Objects}
\label{sectionProjectionFunctionObjects}

\ccDefinition 

A {\em projection\/} function object $o$ of type $O$ has an unary parentheses
operator expecting an argument of type \ccc{O::argument_type} as a
reference or constant reference, and returns a reference or constant
reference of type \ccc{O::result_type} respectively.

\ccInclude{CGAL/function_objects.h}

\ccOperations

\ccHtmlNoClassFile
\ccHtmlNoClassLinks
\begin{ccClass}{ProjectionObject}
\ccTagFullDeclarations
\ccCreationVariable{o}
\ccThree{const O::result_type&;;}{A}{}
\ccMethod{O::result_type& operator()(O::argument_type &) const;}{}
\ccGlue
\ccMethod{const O::result_type& operator()(const O::argument_type &) const;}{}
\ccTagDefaults
\end{ccClass}

\ccCreation

The following projection function objects are available:

\ccTwo{Identity<Value>MMMMM}{}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Identity<Value>}
\ccCreationVariable{o}
\ccConstructor{Identity();}
    {the identity function for projection objects. 
      \ccc{argument_type} and \ccc{result_type} are equal to \ccc{Value}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Compose<Fct1, Fct2>}
\ccCreationVariable{o}
\ccConstructor{Compose();}
    {composes two projections: $\ccc{Fct1} \circ
      \ccc{Fct2} \circ x \equiv \ccc{Fct1()( Fct2()(x))}$.
      \ccc{argument_type} is equal to \ccc{Fct2::argument_type},
      \ccc{result_type} to \ccc{Fct1::result_type}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Dereference<Value>}
\ccCreationVariable{o}
\ccConstructor{Dereference();}
    {dereferences a pointer.
      \ccc{argument_type} is equal to \ccc{Value*} and 
      \ccc{result_type} is equal to \ccc{Value}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Get_address<Value>}
\ccCreationVariable{o}
\ccConstructor{Get_address();}
    {Get the address for a reference.
      \ccc{argument_type} is equal to \ccc{Value} and 
      \ccc{result_type} is equal to \ccc{Value*}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Cast_function_object<Arg, Result>}
\ccCreationVariable{o}
\ccConstructor{Cast_function_object();}
    {applies a C-style type cast to its argument. 
      \ccc{argument_type} is equal to \ccc{Arg} and 
      \ccc{result_type} is equal to \ccc{Result}.}
\end{ccClassTemplate}

The following function objects are provided with respect to the
polyhedral surfaces in the basic library.

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_vertex<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_vertex();}
    {calls the member function \ccc{vertex()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} is equal to \ccc{Node} and 
      \ccc{result_type} is equal to \ccc{Node::Vertex}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_facet<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_facet();}
    {calls the member function \ccc{facet()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} is equal to \ccc{Node} and 
      \ccc{result_type} is equal to \ccc{Node::Facet}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_point<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_point();}
    {calls the member function \ccc{point()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} is equal to \ccc{Node} and 
      \ccc{result_type} is equal to \ccc{Node::Point}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_normal<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_normal();}
    {calls the member function \ccc{normal()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} is equal to \ccc{Node} and 
      \ccc{result_type} is equal to \ccc{Node::Normal}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_plane<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_plane();}
    {calls the member function \ccc{plane()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} is equal to \ccc{Node} and 
      \ccc{result_type} is equal to \ccc{Node::Plane}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_next<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_next();}
    {calls the member function \ccc{next()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} and \ccc{result_type} are equal
      to \ccc{Node*}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_prev<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_prev();}
    {calls the member function \ccc{prev()} on an instance of type 
      \ccc{Node}. \ccc{argument_type} and \ccc{result_type} are equal
      to \ccc{Node*}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_next_opposite<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_next_opposite();}
    {calls the member functions \ccc{next()->opposite()} on an
      instance of type \ccc{Node}. \ccc{argument_type} and
      \ccc{result_type} are equal to \ccc{Node*}.}
\end{ccClassTemplate}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Project_opposite_prev<Node>}
\ccCreationVariable{o}
\ccConstructor{Project_opposite_prev();}
    {calls the member functions \ccc{opposite()->prev()} on an
      instance of type \ccc{Node}. \ccc{argument_type} and
      \ccc{result_type} are equal to \ccc{Node*}.}
\end{ccClassTemplate}


% +--------------------------------------------------------+
\subsection{Creator Function Objects}
\label{sectionCreatorFunctionObjects}

\ccDefinition 

A {\em creator\/} function object $o$ of type $O$ has a parentheses
operator which acts like a constructor. The operator might expect
arguments and returns an instance of type \ccc{O::result_type}.

\ccInclude{CGAL/function_objects.h}

\ccOperations

\ccHtmlNoClassFile
\ccHtmlNoClassLinks
\begin{ccClass}{CreatorObject}
\ccTagFullDeclarations
\ccCreationVariable{o}
\ccThree{O::result_type;;}{A}{}
\ccMethod{O::result_type operator()(...) const;}{}
\ccTagDefaults
\end{ccClass}

\ccCreation

The following creator function objects are available for one to five arguments:

\ccTwo{Identity<Value>MMMMMM}{}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Creator_1<Arg, Result>}
\ccCreationVariable{o}
\ccConstructor{Creator_1();}
    {applies the constructor \ccc{Result(Arg)}.
      \ccc{result_type} is equal to \ccc{Result}.}
\end{ccClassTemplate}

\ldots

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Creator_5<Arg1, Arg2, Arg3, Arg4, Arg5, Result>}
\ccCreationVariable{o}
\ccConstructor{Creator_5();}
    {applies the constructor \ccc{Result(Arg1, Arg2, Arg3, Arg4, Arg5)}.
      \ccc{result_type} is equal to \ccc{Result}.}
\end{ccClassTemplate}

The following creator function objects are available for two to nine
arguments (one argument is already captured with \ccc{Creator_1}):

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Creator_uniform_2<Arg, Result>}
\ccCreationVariable{o}
\ccConstructor{Creator_uniform_2();}
    {applies the constructor \ccc{Result(Arg,Arg)}.
      \ccc{result_type} is equal to \ccc{Result}.}
\end{ccClassTemplate}

\ldots

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Creator_uniform_9<Arg, Result>}
\ccCreationVariable{o}
\ccConstructor{Creator_uniform_9();}
    {applies the constructor for \ccc{Result} with nine arguments of
     type \ccc{Arg}.  \ccc{result_type} is equal to \ccc{Result}.}
\end{ccClassTemplate}

\ccSeeAlso

\ccc{Join_input_iterator_1} \ldots.


% +=========================================================================+
\newpage
\section{Classes for Composing Function Objects}
% +=========================================================================+
\label{sectionComposeFunctionClasses}

\input{compose}



% +=========================================================================+
\newpage
\section{Adaptor Classes around Iterators and Circulators}
% +=========================================================================+

% +---------------------------------------------+
\begin{ccClassTemplate}{Counting_iterator<Iterator, Value>}
\ccCreationVariable{i}
\subsection{Counting Input Iterator Adaptor}
\label{sectionCountingIterator}

\ccDefinition

The iterator adaptor \ccClassTemplateName\ adds a counter to the
internal iterator of type \ccc{Iterator} and defines equality of two
instances in terms of this counter. It can be used to create finite
sequences of possibly infinite sequences of values from input
iterators. It complies itself to the requirements of input iterators.

\ccInclude{CGAL/Counting_iterator.h}

\ccCreation

\ccTwo{Identity<Value>MMMMMM}{}

\ccConstructor{Counting_iterator( std::size_t n = 0);}{initializes the 
    internal counter to $n$ and \ccVar\ has a singular value.}

\ccConstructor{Counting_iterator( Iterator j, std::size_t n = 0);}{
    initializes the internal counter to $n$ and \ccVar\ to $j$.}

\ccSeeAlso

\ccc{copy_n}.
\end{ccClassTemplate}



% +--------------------------------------------------------+
\begin{ccClassTemplate}{N_step_adaptor<I,int N,Ref,Ptr,Val,Dst,Ctg>}
\ccCreationVariable{i}
\subsection{N-Step Iterator or Circulator Adaptor}

\ccDefinition

The adaptor \ccClassTemplateName\ changes the step width of the
iterator or circulator class \ccStyle{I} to $N$. It is itself an
iterator or circulator respectively. The value type is \ccc{Val} and
the distance type is \ccStyle{Dst}. The iterator category is
\ccc{Ctg}. For a mutable iterator, the parameters \ccc{Ref} and
\ccc{Ptr} must be set to \ccc{Val&} and \ccc{Val*} respectively. For a
non-mutable iterator the types must be set to \ccc{const Val&} and
\ccc{const Val*} respectively. With iterator traits classes \ccc{Val},
\ccc{Dst} and \ccStyle{Ctg} will be superfluous.

The behavior is undefined if the adaptor is used on a range [$i,j$)
where $j-i$ is not a multiple of $n$.

\ccInclude{CGAL/N_step_adaptor.h}

\ccCreation
\ccTwo{N_step_adaptor<I,int N,Ref,Ptr,Val,Dst,Ctg> i( I j);;M}{}

\ccConstructor{N_step_adaptor(const I& j);}{down cast.}

\ccOperations

The adaptor conforms to the iterator or circulator category stated
with the parameter \ccc{Ctg}. {\em Precondition:\/} The iterator or
circulator $I$ must be at least of this category.

\end{ccClassTemplate}


% +---------------------------------------------+
\subsection{Joining Input Iterator Streams}
\label{sectionJoinInputIterator}

\ccDefinition

A join of $n$ input iterators and a creator function object is again
an input iterator which reads an object from each stream and applies
the creator function object on them whenever it advances.

\ccInclude{CGAL/Join_input_iterator.h}

\ccCreation

The following join input iterator objects are available for one to
five iterators:

\ccTwo{Identity<Value>MMMMMM}{}

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Join_input_iterator_1<Iterator, Creator>}
\ccCreationVariable{join}
\ccConstructor{Join_input_iterator_1( Iterator i);}
    {the join of a single iterator $i$. Applies \ccc{Creator} to
      each item read from $i$.
      \ccc{value_type} is equal to \ccc{Creator::result_type}.}
\end{ccClassTemplate}

\ldots

\ccHtmlNoClassFile
\begin{ccClassTemplate}{Join_input_iterator_5<I1, I2, I3, I4, I5, Creator>}
\ccCreationVariable{join}
\ccConstructor{Join_input_iterator_5( I1 i1, I2 i2, I3 i3, I4 i4, I5 i5);}
    {the join of five iterators \ccc{i1} to \ccc{i5}. Applies
      \ccc{Creator} with five arguments \ccc{*i1} up to \ccc{*i5}.
      \ccc{value_type} is equal to \ccc{Creator::}\ccc{result_type}.}
\end{ccClassTemplate}

\ccSeeAlso

\ccc{Creator_1} \ldots\ and \ccc{Creator_uniform_2} \ldots.


% +--------------------------------------------------------+
\begin{ccClassTemplate}{Inverse_index<IC>}
\subsection{An Inverse Index for Iterators and Circulators}

\ccDefinition

The class \ccClassTemplateName\ constructs an inverse index for a
given range [$i,j$) of two iterators or circulators of type \ccc{IC}.
The first element $I$ in the range [$i,j$) has the index 0.
Consecutive elements are numbered incrementally. The inverse index
provides a query for a given iterator or circulator $k$ to retrieve
its index number. {\em Precondition:}\/ The iterator or circulator
must be either of the random access category or the dereference
operator must return stable and distinguishable addresses for the
values, e.g.~proxies or non-modifiable iterator with opaque values 
will not work.

\ccInclude{CGAL/Inverse_index.h}

\ccCreation

\ccCreationVariable{inverse}

\ccTwo{Inverse_index< IC,> inverse( IC i, IC j);;}{}
\ccConstructor{Inverse_index();}{invalid index.}
\ccGlue

\ccConstructor{Inverse_index( const IC& i);}
    {empty inverse index initialized to start at $i$.}
\ccGlue

\ccConstructor{Inverse_index( const IC& i, const IC& j);}
    {inverse index initialized with range [$i,j$).}

\ccOperations
\ccThree{std::size_t}{inverse.find( const T* p);}{}

\ccMethod{std::size_t operator[]( const IC& k);}{returns inverse index of $k$.
  \ccPrecond $k$ has been stored in the inverse index.}

\ccMethod{void push_back( const IC& k);}{adds $k$ at the end of the indices.}

\ccImplementation

For random access iterators or circulators, it is done in constant
time by subtracting $i$. For other iterator categories, an \stl\
\ccc{map} is used, which results in a $\log j-i$ query time. The
comparisons are done using the operator \ccc{operator<} on pointers.

\ccSeeAlso

\ccc{Random_access_adaptor} and \ccc{Random_access_value_adaptor}.

\end{ccClassTemplate}


% +--------------------------------------------------------+
\begin{ccClassTemplate}{Random_access_adaptor<IC>}
\subsection{A Random Access Adaptor for Iterators and Circulators}

\ccDefinition

The class \ccClassTemplateName\ provides a random access for data
structures. Either the data structure supports random access iterators
or circulators where this class maps function calls to the iterator
or circulator, or a \stl\ \ccc{std::vector} is used to provide the random
access. The iterator or circulator of the data structure are of type
\ccc{IC}.

\ccInclude{CGAL/Random_access_adaptor.h}

\ccTypes

\ccNestedType{size_type}{size type of the \stl\ \ccc{std::vector}.}

\ccCreation

\ccCreationVariable{random_access}

\ccTwo{Random_access_adaptor< IC> random_access;}{}
\ccConstructor{Random_access_adaptor();}{invalid index.}

\ccConstructor{Random_access_adaptor( const IC& i);}
    {empty random access index initialized to start at $i$.}

\ccConstructor{Random_access_adaptor( const IC& i, const IC& j);}
    {random access index initialized to the range [$i,j$).}

\ccThree{Dist}{random_access.push_back( IC k);}{}
\ccMethod{void reserve( size_type r);}{reserve $r$ entries, if a
  \ccc{std::vector} is used internally.}

\ccOperations

\ccMethod{IC operator[]( size_type n);}{returns iterator or circulator to
  the $n$-th item.
  \ccPrecond $n <$ number of items in \ccVar.}

\ccMethod{void push_back( const IC& k);}{adds $k$ at the end of the indices.}

\ccSeeAlso

\ccc{Inverse_index} and \ccc{Random_access_value_adaptor}.

\end{ccClassTemplate}


% +--------------------------------------------------------+
\begin{ccClassTemplate}{Random_access_value_adaptor<IC,T>}
\subsection{A Random Access Value Adaptor for Iterators and Circulators}

\ccDefinition

The class \ccClassTemplateName\ provides a random access for data
structures. It is derived from
\ccc{Random_access_adaptor<IC>}. Instead of returning
iterators from the \ccc{operator[]} methods, it returns the
dereferenced value of the iterator.  The iterator or circulator of the
data structure are of type \ccc{IC}. Their value type is $T$.

\ccInclude{CGAL/Random_access_value_adaptor.h}

\ccOperations

Creation and operations see \ccc{Random_access_adaptor<IC>}
above, with the exception of:

\ccCreationVariable{random_access}

\ccThree{Dist}{random_access.push_back( IC k);}{}

\ccMethod{T& operator[]( size_type n);}{returns a reference to
  the $n$-th item.
  \ccPrecond $n <$ number of items in \ccVar.}

\ccSeeAlso

\ccc{Inverse_index} and \ccc{Random_access_adaptor}.

\end{ccClassTemplate}


% +--------------------------------------------------------+
\ccParDims

% EOF


