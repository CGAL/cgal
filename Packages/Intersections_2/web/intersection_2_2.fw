@i cgal_util.fwi
@B@<Intersection of two triangles@>

The intersection of two triangles can lead to a (convex) polygon of (at
most) six sides.

@O@<../include/CGAL/Triangle_2_Triangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Triangle_2_Triangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)

#ifndef CGAL_TRIANGLE_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_TRIANGLE_2_TRIANGLE_2_INTERSECTION_H

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr1, const CGAL_Triangle_2<R>&tr2);

template <class R>
bool
CGAL_do_intersect(const CGAL_Triangle_2<R> &tr1, const CGAL_Triangle_2<R>&tr2);

#ifdef CGAL_CFG_NO_AUTOMATIC_TEMPLATE_INCLUSION
#include <CGAL/Triangle_2_Triangle_2_intersection.C>
#endif
#endif
@}

@O@<../include/CGAL/Triangle_2_Triangle_2_intersection.C@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Triangle_2_Triangle_2_intersection.C@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)


#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_TRIANGLE_2_H
#include <CGAL/Triangle_2.h>
#endif // CGAL_TRIANGLE_2_H

template <class R>
struct CGAL__Pointlist_2_rec {
    CGAL__Pointlist_2_rec *next;
    CGAL_Point_2<R> point;
    CGAL_Oriented_side side;
};

template <class R>
struct CGAL__Pointlist_2 {
    int size;
    CGAL__Pointlist_2_rec<R> *first;
    CGAL__Pointlist_2() ;
    ~CGAL__Pointlist_2() ;
};

template <class R>
class CGAL_Triangle_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT, TRIANGLE, POLYGON};
                        CGAL_Triangle_2_Triangle_2_pair() ;
                        CGAL_Triangle_2_Triangle_2_pair(
                                CGAL_Triangle_2<R> const *trian1,
                                CGAL_Triangle_2<R> const *trian2) ;
    ~CGAL_Triangle_2_Triangle_2_pair() {}
#ifdef CGAL_CFG_RETURN_TYPE_BUG_2
    Intersection_results intersection_type() const
    @<Triangle_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_CFG_RETURN_TYPE_BUG_2
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
    bool                intersection(CGAL_Triangle_2<R> &result) const;
    bool                intersection(/*CGAL_Polygon_2<R> &result*/) const;
    int                 vertex_count() const;
    CGAL_Point_2<R>     vertex(int i) const;
protected:
    CGAL_Triangle_2<R> const*   _trian1;
    CGAL_Triangle_2<R> const *  _trian2;
    bool                    _known;
    Intersection_results    _result;
    CGAL__Pointlist_2<R>    _pointlist;
};

@<do_intersect macro@>@(Triangle_2@,Triangle_2@)

@<Triangle_2_Triangle_2_pair implementation@>

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr1, const CGAL_Triangle_2<R>&tr2)
{
    typedef CGAL_Triangle_2_Triangle_2_pair<R> is_t;
    is_t ispair(&tr1, &tr2);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    case is_t::TRIANGLE: {
        CGAL_Triangle_2<R> itr;
        ispair.intersection(itr);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Triangle_2<R> >(itr));
    }
    case is_t::POLYGON: {
        typedef CGAL_STD::vector<CGAL_Point_2<R> > Container;
        Container points(ispair.vertex_count());
        for (int i =0; i < ispair.vertex_count(); i++) {
            points[i] = ispair.vertex(i);
        }
        return CGAL_Object(new CGAL_Wrapper< Container >(points));
    }
    }
}

@}

A triangle is a convex polygon. We maintain this convex polygon.
Every edge of the other triangle can be extended to a line.
We cut the maintained polygon consecutively with those three supporting lines.

We direct the lines in such a way that the (second) triangle lies to the left
of them. So, when we look at the maintained polygon, the vertices to the right
should be discarded.

The implementation does not make use of LEDA singly linked lists,
which it should do, probably.

@$@<Triangle_2_Triangle_2_pair implementation@>+=@{

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H
#ifndef CGAL_STD_VECTOR_H
#include <CGAL/std/vector>
#endif

template <class R>
CGAL__Pointlist_2<R>::CGAL__Pointlist_2()
{
    size = 0;
    first = 0;
}

template <class R>
CGAL__Pointlist_2<R>::~CGAL__Pointlist_2()
{
    CGAL__Pointlist_2_rec<R> *cur;
    for (int i=0; i<size; i++) {
        cur = first;
        first = cur->next;
        delete cur;
    }
}

@}

@$@<Triangle_2_Triangle_2_pair implementation@>+=@{
template <class R>
void CGAL__init_list(CGAL__Pointlist_2<R> &list,
                const CGAL_Triangle_2<R> &trian)
{
    // check on degeneracies of trian.
    if (!trian.is_degenerate()) {
        list.size = 3;
        list.first = 0;
        for (int i=0; i<3; i++) {
            CGAL__Pointlist_2_rec<R> *newrec =
                        new CGAL__Pointlist_2_rec<R>;
            newrec->next = list.first;
            list.first = newrec;
            newrec->point = trian[i];
        }
    } else {
        // CGAL__not_implemented();
        CGAL_kernel_assertion(false);
    }
}
@}

@$@<Triangle_2_Triangle_2_pair implementation@>+=@{
#ifndef CGAL_LINE_2_LINE_2_INTERSECTION_H
#include <CGAL/Line_2_Line_2_intersection.h>
#endif // CGAL_LINE_2_LINE_2_INTERSECTION_H

template <class R>
void CGAL__cut_off(CGAL__Pointlist_2<R> &list,
                const CGAL_Line_2<R> &cutter)
{
    int i;
    int add = 0;
    CGAL__Pointlist_2_rec<R> *cur, *last, *newrec;
    for (i=0, cur = list.first; i<list.size; i++, cur = cur->next) {
        cur->side = cutter.oriented_side(cur->point);
        last = cur;
    }
@}
Add vertices on the cutter.
@$@<Triangle_2_Triangle_2_pair implementation@>+=@{@-
    for (cur = list.first, i=0; i<list.size; i++, cur = cur->next) {
        if ((cur->side == CGAL_ON_POSITIVE_SIDE
             && last->side == CGAL_ON_NEGATIVE_SIDE)
           || (cur->side == CGAL_ON_NEGATIVE_SIDE
               && last->side == CGAL_ON_POSITIVE_SIDE)) {
            // add a vertex after cur
            add++;
            CGAL_Line_2<R> l(cur->point, last->point);
            newrec = new CGAL__Pointlist_2_rec<R>;
            newrec->next = last->next;
            last->next = newrec;
            newrec->side = CGAL_ON_ORIENTED_BOUNDARY;
            CGAL_Line_2_Line_2_pair<R> linepair(&cutter,  &l);
            CGAL_Line_2_Line_2_pair<R>::Intersection_results isr;
            isr = linepair.intersection_type();
            CGAL_kernel_assertion(isr == CGAL_Line_2_Line_2_pair<R>::POINT);
            linepair.intersection(newrec->point);
        }
        last = cur;
    }
    CGAL_kernel_assertion(add <= 2);
@}
remove the vertices on the right side of the line.
@$@<Triangle_2_Triangle_2_pair implementation@>+=@{@-
    CGAL__Pointlist_2_rec<R> **curpt;
    curpt = &list.first;
    while (*curpt != 0) {
        cur = *curpt;
        if (cur->side == CGAL_ON_NEGATIVE_SIDE) {
            add--;
            *curpt = cur->next;
            delete cur;
        } else {
            curpt = &cur->next;
        }
    }
@}
We added two identical points if the original pointlist had two points
and was cut by the cutter. Here we repair this.
@$@<Triangle_2_Triangle_2_pair implementation@>+=@{@-
    if (list.size == 2 && add == 1) {
        add = 0;
        cur = list.first;
        if (cur->side == CGAL_ON_ORIENTED_BOUNDARY) {
            list.first = cur->next;
            delete cur;
        } else {
            last = cur;
            cur = cur->next;
            last->next = cur->next;
            delete cur;
        }
    }
    list.size += add;
}

template <class R>
CGAL_Triangle_2_Triangle_2_pair<R>::
CGAL_Triangle_2_Triangle_2_pair()
{
    _trian1 = 0;
    _trian2 = 0;
    _known = false;
}

template <class R>
CGAL_Triangle_2_Triangle_2_pair<R>::
CGAL_Triangle_2_Triangle_2_pair(CGAL_Triangle_2<R> const *trian1,
         CGAL_Triangle_2<R> const *trian2)
{
    _trian1 = trian1;
    _trian2 = trian2;
    _known = false;
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Triangle_2_Triangle_2_pair<R>::Intersection_results
CGAL_Triangle_2_Triangle_2_pair<R>::intersection_type() const
@<Triangle_2_Triangle_2_pair intersection_type body@>
#endif


template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        /* CGAL_Polygon_2<R> &result */) const
{
    if (!_known)
        intersection_type();
    if (_result != TRIANGLE  &&  _result != POLYGON)
        return false;
    CGAL__Pointlist_2_rec<R> *cur;
    int i;
    for (i=0, cur = _pointlist.first;
         i<_pointlist.size;
         i++, cur = cur->next) {
      cout << CGAL_to_double(cur->point.x()) << ' ';
      cout << CGAL_to_double(cur->point.y()) << ' ';
    }
    cout << endl;
    return true;
}

template <class R>
int
CGAL_Triangle_2_Triangle_2_pair<R>::vertex_count() const
{
    CGAL_kernel_assertion(_known);
    return _pointlist.size;
}

template <class R>
CGAL_Point_2<R>
CGAL_Triangle_2_Triangle_2_pair<R>::vertex(int n) const
{
    CGAL_kernel_assertion(_known);
    CGAL_kernel_assertion(n >= 0 && n < _pointlist.size);
    CGAL__Pointlist_2_rec<R> *cur;
    int k;
    for (k=0, cur = _pointlist.first;
         k < n;
         k++, cur = cur->next) {
    }
    return cur->point;
}

template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        CGAL_Triangle_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != TRIANGLE)
        return false;
    result = CGAL_Triangle_2<R>(_pointlist.first->point,
                    _pointlist.first->next->point,
                    _pointlist.first->next->next->point);
    return true;
}

template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        CGAL_Segment_2<R> &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    seg = CGAL_Segment_2<R>(_pointlist.first->point,
                    _pointlist.first->next->point);
    return true;
}

template <class R>
bool
CGAL_Triangle_2_Triangle_2_pair<R>::intersection(
        CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = _pointlist.first->point;
    return true;
}

@}

@$@<Triangle_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Triangle_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Triangle_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    if (!CGAL_do_overlap(_trian1->bbox(), _trian2->bbox())) {
        ncthis->_result = NO;
        return _result;
    }
    CGAL__init_list(ncthis->_pointlist, *_trian1);
    if (_trian2->is_degenerate()) {
        // CGAL__not_implemented();
        CGAL_kernel_assertion(false);
    } else {
        CGAL_Line_2<R> l(_trian2->vertex(0), _trian2->vertex(1));
        if (l.oriented_side(_trian2->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
            // counterclockwise triangle
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(1), _trian2->vertex(2));
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(2), _trian2->vertex(0));
            CGAL__cut_off(ncthis->_pointlist, l);
        } else {
            l = l.opposite();
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(0), _trian2->vertex(2));
            CGAL__cut_off(ncthis->_pointlist, l);
            l = CGAL_Line_2<R>(_trian2->vertex(2), _trian2->vertex(1));
            CGAL__cut_off(ncthis->_pointlist, l);
        }
    }
    switch (_pointlist.size) {
    case 0:
        ncthis->_result = NO;
        break;
    case 1:
        ncthis->_result = POINT;
        break;
    case 2:
        ncthis->_result = SEGMENT;
        break;
    case 3:
        ncthis->_result = TRIANGLE;
        break;
    default:
        ncthis->_result = POLYGON;
    }
    return _result;
}
@}



@B@<Intersection of triangle with a line, ray, segment or point@>

@O@<../include/CGAL/Triangle_2_Line_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Triangle_2_Line_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_LINE_2_TRIANGLE_2_INTERSECTION_H
#include <CGAL/Line_2_Triangle_2_intersection.h>
#endif // CGAL_LINE_2_TRIANGLE_2_INTERSECTION_H
@}

@O@<../include/CGAL/Line_2_Triangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Line_2_Triangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_LINE_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_LINE_2_TRIANGLE_2_INTERSECTION_H

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_TRIANGLE_2_H
#include <CGAL/Triangle_2.h>
#endif // CGAL_TRIANGLE_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H

template <class R>
class CGAL_Line_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Line_2_Triangle_2_pair() ;
    CGAL_Line_2_Triangle_2_pair(CGAL_Line_2<R> const *line,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Line_2_Triangle_2_pair() {}
#ifdef CGAL_CFG_RETURN_TYPE_BUG_2
    Intersection_results intersection_type() const
    @<Line_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_CFG_RETURN_TYPE_BUG_2
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Line_2<R> const*_line;
    CGAL_Triangle_2<R> const *  _trian;
    bool                    _known;
    Intersection_results     _result;
    CGAL_Point_2<R>         _intersection_point;
    CGAL_Point_2<R>         _other_point;
};

@<do_intersect macro@>@(Line_2@,Triangle_2@)

@<Line_2_Triangle_2_pair implementation@>

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Line_2_Triangle_2_pair<R> is_t;
    is_t ispair(&line, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Line_2_pair
: public CGAL_Line_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Line_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Line_2<R> const *line) :
                        CGAL_Line_2_Triangle_2_pair<R>(line, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Line_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Line_2<R> &line)
{
    return CGAL_intersection(line, tr);
}
#endif
@}

@$@<Line_2_Triangle_2_pair implementation@>==@{
#ifndef CGAL_STRAIGHT_2_H
#include <CGAL/Straight_2.h>
#endif // CGAL_STRAIGHT_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H

template <class R>
CGAL_Line_2_Triangle_2_pair<R>::
CGAL_Line_2_Triangle_2_pair()
{
    _known = false;
    _line = 0;
    _trian = 0;
}

template <class R>
CGAL_Line_2_Triangle_2_pair<R>::
CGAL_Line_2_Triangle_2_pair(CGAL_Line_2<R> const *line,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _line = line;
    _trian = trian;
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Line_2_Triangle_2_pair<R>::Intersection_results
CGAL_Line_2_Triangle_2_pair<R>::intersection_type() const
@<Line_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

template <class R>
bool
CGAL_Line_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Line_2_Triangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Line_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Line_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Line_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    CGAL__Straight_2<R> straight(*_line);
CGAL_Line_2<R> l(_trian->vertex(0), _trian->vertex(1));
if (l.oriented_side(_trian->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
//    if (_trian->is_counterclockwise()) {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(2)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(0)));
    } else {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(0)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(2)));
    }
    switch (straight.current_state()) {
    case CGAL__Straight_2<R>::EMPTY:
        ncthis->_result = NO;
        return _result;
    case CGAL__Straight_2<R>::POINT: {
        straight.current(ncthis->_intersection_point);
        ncthis->_result = POINT;
        return _result;
        }
    case CGAL__Straight_2<R>::SEGMENT: {
        CGAL_Segment_2<R> seg;
        straight.current(seg);
        ncthis->_intersection_point = seg.start();
        ncthis->_other_point = seg.end();
        ncthis->_result = SEGMENT;
        return _result;
        }
    default:  // should not happen.
        CGAL_kernel_assertion_msg(false, "Internal CGAL error.");
        ncthis->_result = NO;
        return _result;
    }
}
@}

@O@<../include/CGAL/Triangle_2_Ray_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Triangle_2_Ray_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_RAY_2_TRIANGLE_2_INTERSECTION_H
#include <CGAL/Ray_2_Triangle_2_intersection.h>
#endif // CGAL_RAY_2_TRIANGLE_2_INTERSECTION_H
@}

@O@<../include/CGAL/Ray_2_Triangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Ray_2_Triangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_RAY_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_RAY_2_TRIANGLE_2_INTERSECTION_H

#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_RAY_2_H
#include <CGAL/Ray_2.h>
#endif // CGAL_RAY_2_H
#ifndef CGAL_TRIANGLE_2_H
#include <CGAL/Triangle_2.h>
#endif // CGAL_TRIANGLE_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H

template <class R>
class CGAL_Ray_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Ray_2_Triangle_2_pair() ;
    CGAL_Ray_2_Triangle_2_pair(CGAL_Ray_2<R> const *ray,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Ray_2_Triangle_2_pair() {}
#ifdef CGAL_CFG_RETURN_TYPE_BUG_2
    Intersection_results intersection_type() const
    @<Ray_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_CFG_RETURN_TYPE_BUG_2
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Ray_2<R> const* _ray;
    CGAL_Triangle_2<R> const *  _trian;
    bool                    _known;
    Intersection_results     _result;
    CGAL_Point_2<R>         _intersection_point;
    CGAL_Point_2<R>         _other_point;
};

@<do_intersect macro@>@(Ray_2@,Triangle_2@)

@<2D Ray Triangle intersection implementation@>

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Ray_2<R> &ray, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Ray_2_Triangle_2_pair<R> is_t;
    is_t ispair(&ray, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Ray_2_pair
: public CGAL_Ray_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Ray_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Ray_2<R> const *ray) :
                        CGAL_Ray_2_Triangle_2_pair<R>(ray, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Ray_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Ray_2<R> &ray)
{
    return CGAL_intersection(ray, tr);
}
#endif
@}

@$@<2D Ray Triangle intersection implementation@>==@{

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H
#ifndef CGAL_STRAIGHT_2_H
#include <CGAL/Straight_2.h>
#endif // CGAL_STRAIGHT_2_H

template <class R>
CGAL_Ray_2_Triangle_2_pair<R>::
CGAL_Ray_2_Triangle_2_pair()
{
    _known = false;
    _ray = 0;
    _trian = 0;
}

template <class R>
CGAL_Ray_2_Triangle_2_pair<R>::
CGAL_Ray_2_Triangle_2_pair(CGAL_Ray_2<R> const *ray,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _ray = ray;
    _trian = trian;
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Ray_2_Triangle_2_pair<R>::Intersection_results
CGAL_Ray_2_Triangle_2_pair<R>::intersection_type() const
@<Ray_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

template <class R>
bool
CGAL_Ray_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Ray_2_Triangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Ray_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Ray_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Ray_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    CGAL__Straight_2<R> straight(*_ray);
CGAL_Line_2<R> l(_trian->vertex(0), _trian->vertex(1));
if (l.oriented_side(_trian->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
//    if (_trian->is_counterclockwise()) {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(2)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(0)));
    } else {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(0)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(2)));
    }
    switch (straight.current_state()) {
    case CGAL__Straight_2<R>::EMPTY:
        ncthis->_result = NO;
        return _result;
    case CGAL__Straight_2<R>::POINT: {
        straight.current(ncthis->_intersection_point);
        ncthis->_result = POINT;
        return _result;
        }
    case CGAL__Straight_2<R>::SEGMENT: {
        CGAL_Segment_2<R> seg;
        straight.current(seg);
        ncthis->_intersection_point = seg.start();
        ncthis->_other_point = seg.end();
        ncthis->_result = SEGMENT;
        return _result;
        }
    default:  // should not happen.
        CGAL_kernel_assertion_msg(false, "Internal CGAL error.");
        ncthis->_result = NO;
        return _result;
    }
}
@}

@O@<../include/CGAL/Triangle_2_Segment_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Triangle_2_Segment_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_SEGMENT_2_TRIANGLE_2_INTERSECTION_H
#include <CGAL/Segment_2_Triangle_2_intersection.h>
#endif // CGAL_SEGMENT_2_TRIANGLE_2_INTERSECTION_H
@}

@O@<../include/CGAL/Segment_2_Triangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Segment_2_Triangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_SEGMENT_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_SEGMENT_2_TRIANGLE_2_INTERSECTION_H

#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_TRIANGLE_2_H
#include <CGAL/Triangle_2.h>
#endif // CGAL_TRIANGLE_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H

template <class R>
class CGAL_Segment_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Segment_2_Triangle_2_pair() ;
    CGAL_Segment_2_Triangle_2_pair(CGAL_Segment_2<R> const *seg,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Segment_2_Triangle_2_pair() {}
#ifdef CGAL_CFG_RETURN_TYPE_BUG_2
    Intersection_results intersection_type() const
    @<Segment_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_CFG_RETURN_TYPE_BUG_2
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Segment_2<R> const *  _seg;
    CGAL_Triangle_2<R> const * _trian;
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _intersection_point;
    CGAL_Point_2<R>            _other_point;
};

@<do_intersect macro@>@(Segment_2@,Triangle_2@)

@<Segment_2_Triangle_2_pair implementation@>


#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Segment_2<R> &seg, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Segment_2_Triangle_2_pair<R> is_t;
    is_t ispair(&seg, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> pt;
        ispair.intersection(pt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Segment_2_pair
: public CGAL_Segment_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Segment_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Segment_2<R> const *seg) :
                        CGAL_Segment_2_Triangle_2_pair<R>(seg, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Segment_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Segment_2<R> &seg)
{
    return CGAL_intersection(seg, tr);
}
#endif
@}

@$@<Segment_2_Triangle_2_pair implementation@>==@{

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H
#ifndef CGAL_STRAIGHT_2_H
#include <CGAL/Straight_2.h>
#endif // CGAL_STRAIGHT_2_H

template <class R>
CGAL_Segment_2_Triangle_2_pair<R>::
CGAL_Segment_2_Triangle_2_pair()
{
    _known = false;
    _seg = 0;
    _trian = 0;
}

template <class R>
CGAL_Segment_2_Triangle_2_pair<R>::
CGAL_Segment_2_Triangle_2_pair(CGAL_Segment_2<R> const *seg,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _seg = seg;
    _trian = trian;
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Segment_2_Triangle_2_pair<R>::Intersection_results
CGAL_Segment_2_Triangle_2_pair<R>::intersection_type() const
@<Segment_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

template <class R>
bool
CGAL_Segment_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _intersection_point;
    return true;
}

template <class R>
bool
CGAL_Segment_2_Triangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_intersection_point, _other_point);
    return true;
}
@}

@$@<Segment_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Segment_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Segment_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    CGAL__Straight_2<R> straight(*_seg);
CGAL_Line_2<R> l(_trian->vertex(0), _trian->vertex(1));
if (l.oriented_side(_trian->vertex(2)) == CGAL_ON_POSITIVE_SIDE) {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(2)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(0)));
    } else {
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(2), _trian->vertex(1)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(1), _trian->vertex(0)));
        straight.cut_right_off(
            CGAL_Line_2<R>(_trian->vertex(0), _trian->vertex(2)));
    }
    switch (straight.current_state()) {
    case CGAL__Straight_2<R>::EMPTY:
        ncthis->_result = NO;
        return _result;
    case CGAL__Straight_2<R>::POINT: {
        straight.current(ncthis->_intersection_point);
        ncthis->_result = POINT;
        return _result;
        }
    case CGAL__Straight_2<R>::SEGMENT: {
        CGAL_Segment_2<R> seg;
        straight.current(seg);
        ncthis->_intersection_point = seg.start();
        ncthis->_other_point = seg.end();
        ncthis->_result = SEGMENT;
        return _result;
        }
    default:  // should not happen.
        CGAL_kernel_assertion_msg(false, "Internal CGAL error.");
        ncthis->_result = NO;
        return _result;
    }
}
@}


@O@<../include/CGAL/Triangle_2_Point_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Triangle_2_Point_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_POINT_2_TRIANGLE_2_INTERSECTION_H
#include <CGAL/Point_2_Triangle_2_intersection.h>
#endif // CGAL_POINT_2_TRIANGLE_2_INTERSECTION_H
@}

@O@<../include/CGAL/Point_2_Triangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Point_2_Triangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_POINT_2_TRIANGLE_2_INTERSECTION_H
#define CGAL_POINT_2_TRIANGLE_2_INTERSECTION_H

#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H
#ifndef CGAL_TRIANGLE_2_H
#include <CGAL/Triangle_2.h>
#endif // CGAL_TRIANGLE_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H

template <class R>
class CGAL_Point_2_Triangle_2_pair {
public:
    enum Intersection_results {NO, POINT};
    CGAL_Point_2_Triangle_2_pair() ;
    CGAL_Point_2_Triangle_2_pair(CGAL_Point_2<R> const *pt,
                            CGAL_Triangle_2<R> const *trian);
    ~CGAL_Point_2_Triangle_2_pair() {}
#ifdef CGAL_CFG_RETURN_TYPE_BUG_2
    Intersection_results intersection_type() const
    @<Point_2_Triangle_2_pair intersection_type body@>
#else
    Intersection_results intersection_type() const;
#endif // CGAL_CFG_RETURN_TYPE_BUG_2
    bool                intersection(CGAL_Point_2<R> &result) const;
protected:
    CGAL_Point_2<R> const *    _pt;
    CGAL_Triangle_2<R> const * _trian;
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _intersection_point;
    CGAL_Point_2<R>            _other_point;
};

@<do_intersect macro@>@(Point_2@,Triangle_2@)

@<Point_2_Triangle_2_pair implementation@>

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Point_2<R> &pt, const CGAL_Triangle_2<R>&tr)
{
    typedef CGAL_Point_2_Triangle_2_pair<R> is_t;
    is_t ispair(&pt, &tr);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    }
}

template <class R>
class CGAL_Triangle_2_Point_2_pair
: public CGAL_Point_2_Triangle_2_pair<R> {
public:
    CGAL_Triangle_2_Point_2_pair(
            CGAL_Triangle_2<R> const *trian,
            CGAL_Point_2<R> const *pt) :
                        CGAL_Point_2_Triangle_2_pair<R>(pt, trian) {}
};

@<do_intersect macro@>@(Triangle_2@,Point_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Triangle_2<R> &tr, const CGAL_Point_2<R> &pt)
{
    return CGAL_intersection(pt, tr);
}

#endif
@}

@$@<Point_2_Triangle_2_pair implementation@>==@{

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H
#ifndef CGAL_STRAIGHT_2_H
#include <CGAL/Straight_2.h>
#endif // CGAL_STRAIGHT_2_H

template <class R>
CGAL_Point_2_Triangle_2_pair<R>::
CGAL_Point_2_Triangle_2_pair()
{
    _known = false;
    _pt = 0;
    _trian = 0;
}

template <class R>
CGAL_Point_2_Triangle_2_pair<R>::
CGAL_Point_2_Triangle_2_pair(CGAL_Point_2<R> const *pt,
                            CGAL_Triangle_2<R> const *trian)
{
    _known = false;
    _pt = pt;
    _trian = trian;
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Point_2_Triangle_2_pair<R>::Intersection_results
CGAL_Point_2_Triangle_2_pair<R>::intersection_type() const
@<Point_2_Triangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2



template <class R>
bool
CGAL_Point_2_Triangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = *_pt;
    return true;
}
@}

@$@<Point_2_Triangle_2_pair intersection_type body@>@M==@{@-
{
    typedef CGAL_Line_2<R> line_t;
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Point_2_Triangle_2_pair<R> *ncthis =
                (CGAL_Point_2_Triangle_2_pair<R> *) this;
    ncthis->_known = true;
    if (_trian->has_on_unbounded_side(*_pt)) {
        ncthis->_result = NO;
    } else {
        ncthis->_result = POINT;
    }
    return _result;
/*
    line_t l(_trian->vertex(0), _trian->vertex(1));
    if (l.has_on_positive_side(_trian->vertex(2))) {
        for (int i=0; i<3; i++) {
            if (line_t(_trian->vertex(i), _trian->vertex(i+1)).
                                has_on_negative_side(*_pt)) {
                ncthis->_result = NO;
                return _result;
            }
        }
    } else {
        for (int i=0; i<3; i++)
            if(line_t(_trian->vertex(i), _trian->vertex(i-1)).
                                has_on_negative_side(*_pt)){
                ncthis->_result = NO;
                return _result;
            }
    }
*/
}
@}

@B@<Iso_rectangle Line intersection@>

@O@<../include/CGAL/Iso_rectangle_2_Line_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Iso_rectangle_2_Line_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Line_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H
@}

@O@<../include/CGAL/Line_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Line_2_Iso_rectangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H
#define CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_ISO_RECTANGLE_2_H
#include <CGAL/Iso_rectangle_2.h>
#endif // CGAL_ISO_RECTANGLE_2_H

template <class R>
class CGAL_Line_2_Iso_rectangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Line_2_Iso_rectangle_2_pair() ;
    CGAL_Line_2_Iso_rectangle_2_pair(CGAL_Line_2<R> const *pt,
                            CGAL_Iso_rectangle_2<R> const *iso);
    ~CGAL_Line_2_Iso_rectangle_2_pair() {}
#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
  Intersection_results intersection_type() const;
#else
  Intersection_results intersection_type() const
@<Iso_rectangle_2_Line_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2
    bool                intersection(CGAL_Point_2<R> &result) const;
    bool                intersection(CGAL_Segment_2<R> &result) const;
protected:
    CGAL_Point_2<R>             _ref_point;
    CGAL_Vector_2<R>            _dir;
    CGAL_Point_2<R>             _isomin;
    CGAL_Point_2<R>             _isomax;
    bool                        _known;
    Intersection_results        _result;
    typename R::FT              _min, _max;
};

@<do_intersect macro@>@(Line_2@,Iso_rectangle_2@)

@<Line_2_Iso_rectangle_2_pair implementation@>

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(const CGAL_Line_2<R> &line, const CGAL_Iso_rectangle_2<R>&iso)
{
    typedef CGAL_Line_2_Iso_rectangle_2_pair<R> is_t;
    is_t ispair(&line, &iso);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> ipt;
        ispair.intersection(ipt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(ipt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}

template <class R>
class CGAL_Iso_rectangle_2_Line_2_pair
: public CGAL_Line_2_Iso_rectangle_2_pair<R> {
public:
    CGAL_Iso_rectangle_2_Line_2_pair(
            CGAL_Iso_rectangle_2<R> const *iso,
            CGAL_Line_2<R> const *line) :
                        CGAL_Line_2_Iso_rectangle_2_pair<R>(line, iso) {}
};

@<do_intersect macro@>@(Iso_rectangle_2@,Line_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Iso_rectangle_2<R>&iso, const CGAL_Line_2<R>&line)
{
    return CGAL_intersection(line, iso);
}

#endif
@}

@$@<Line_2_Iso_rectangle_2_pair implementation@>==@{

#ifndef CGAL_LINE_2_H
#include <CGAL/Line_2.h>
#endif // CGAL_LINE_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H

template <class R>
CGAL_Line_2_Iso_rectangle_2_pair<R>::
CGAL_Line_2_Iso_rectangle_2_pair()
{
    _known = false;
}

template <class R>
CGAL_Line_2_Iso_rectangle_2_pair<R>::
CGAL_Line_2_Iso_rectangle_2_pair(CGAL_Line_2<R> const *line,
                            CGAL_Iso_rectangle_2<R> const *iso)
{
    _known = false;
    _ref_point = line->point();
    _dir = line->direction().vector();
    _isomin = iso->min();
    _isomax = iso->max();
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Line_2_Iso_rectangle_2_pair<R>::Intersection_results
CGAL_Line_2_Iso_rectangle_2_pair<R>::intersection_type() const
@<Iso_rectangle_2_Line_2_pair intersection_type body@>
#endif


template <class R>
bool
CGAL_Line_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Point_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    result = _ref_point + _dir * _min;
    return true;
}

template <class R>
bool
CGAL_Line_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &result) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    result = CGAL_Segment_2<R>(_ref_point + _dir*_min, _ref_point + _dir*_max);
    return true;
}
@}

The following body of the intersection type member function is used twice.
Once inline (which the g++ compiler wants because of a bug) and once outline.

@$@<Iso_rectangle_2_Line_2_pair intersection_type body@>@M==@{@-
{
    typedef CGAL_Line_2<R> line_t;
    if (_known)
        return _result;
// The non const this pointer is used to cast away const.
    CGAL_Line_2_Iso_rectangle_2_pair<R> *ncthis =
                (CGAL_Line_2_Iso_rectangle_2_pair<R> *) this;
    ncthis->_known = true;
    typedef typename R::FT FT;
    typedef typename R::RT RT;
    bool all_values = true;
    int i;
    for (i=0; i< _ref_point.dimension(); i++) {
        if (_dir.homogeneous(i) == RT(0)) {
            if (_ref_point.cartesian(i) < _isomin.cartesian(i)) {
                ncthis->_result = NO;
                return NO;
            }
            if (_ref_point.cartesian(i) > _isomax.cartesian(i)) {
                ncthis->_result = NO;
                return NO;
            }
        } else {
            FT newmin, newmax;
            if (_dir.homogeneous(i) > RT(0)) {
                newmin = (_isomin.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomax.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            } else {
                newmin = (_isomax.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomin.cartesian(i) - _ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            }
            if (all_values) {
                ncthis->_min = newmin;
                ncthis->_max = newmax;
            } else {
                if (newmin > _min)
                    ncthis->_min = newmin;
                if (newmax < _max)
                    ncthis->_max = newmax;
                if (_max < _min) {
                    ncthis->_result = NO;
                    return NO;
                }
            }
            all_values = false;
        }
    }
    CGAL_kernel_assertion(!all_values);
    if (_max == _min) {
        ncthis->_result = POINT;
        return POINT;
    }
    ncthis->_result = SEGMENT;
    return SEGMENT;
}
@}

@B@<2D Ray Iso_rectangle intersection@>


@O@<../include/CGAL/Iso_rectangle_2_Ray_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Iso_rectangle_2_Ray_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_RAY_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Ray_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_RAY_2_ISO_RECTANGLE_2_INTERSECTION_H
@}


@O@<../include/CGAL/Ray_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Ray_2_Iso_rectangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_RAY_2_BBOX_2_INTERSECTION_H
#define CGAL_RAY_2_BBOX_2_INTERSECTION_H

#ifndef CGAL_ISO_RECTANGLE_2_H
#include <CGAL/Iso_rectangle_2.h>
#endif // CGAL_ISO_RECTANGLE_2_H
#ifndef CGAL_RAY_2_H
#include <CGAL/Ray_2.h>
#endif // CGAL_RAY_2_H
#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H

template <class R>
class CGAL_Ray_2_Iso_rectangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Ray_2_Iso_rectangle_2_pair() ;
    CGAL_Ray_2_Iso_rectangle_2_pair(CGAL_Ray_2<R> const *ray,
                          CGAL_Iso_rectangle_2<R> const *rect) ;

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
  Intersection_results intersection_type() const;

#else
  Intersection_results intersection_type() const
@<Ray_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

    bool                       intersection(
                                    CGAL_Point_2<R> &result) const;
    bool                       intersection(
                                    CGAL_Segment_2<R> &result) const;
protected:
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _ref_point;
    CGAL_Vector_2<R>           _dir;
    CGAL_Point_2<R>            _isomin;
    CGAL_Point_2<R>            _isomax;
    typename R::FT                     _min,
                               _max;
};

@<do_intersect macro@>@(Ray_2@,Iso_rectangle_2@)

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Ray_2<R> &ray,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    typedef CGAL_Ray_2_Iso_rectangle_2_pair<R> is_t;
    is_t ispair(&ray, &iso);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> ipt;
        ispair.intersection(ipt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(ipt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}


@<Ray_2_Iso_rectangle_2_pair implementation@>

template <class R>
class CGAL_Iso_rectangle_2_Ray_2_pair:
          public CGAL_Ray_2_Iso_rectangle_2_pair<R> {
public:
    CGAL_Iso_rectangle_2_Ray_2_pair() {}
    CGAL_Iso_rectangle_2_Ray_2_pair(CGAL_Iso_rectangle_2<R> const *rect,
                               CGAL_Ray_2<R> const *ray)
                :CGAL_Ray_2_Iso_rectangle_2_pair<R> (ray, rect){}
};

@<do_intersect macro@>@(Iso_rectangle_2@,Ray_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(const CGAL_Iso_rectangle_2<R>&iso, const CGAL_Ray_2<R>&ray)
{
    return CGAL_intersection(ray, iso);
}

#endif
@}


@$@<Ray_2_Iso_rectangle_2_pair implementation@>==@{

template <class R>
CGAL_Ray_2_Iso_rectangle_2_pair<R>::CGAL_Ray_2_Iso_rectangle_2_pair()
{
    _known = false;
}

template <class R>
CGAL_Ray_2_Iso_rectangle_2_pair<R>::
CGAL_Ray_2_Iso_rectangle_2_pair(
        CGAL_Ray_2<R> const *ray,
        CGAL_Iso_rectangle_2<R> const *iso)
{
    _known = false;
    _isomin = iso->min();
    _isomax = iso->max();
    _ref_point = ray->start();
    _dir = ray->direction().vector();
    _min = (typename R::FT)(0);
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Ray_2_Iso_rectangle_2_pair<R>::Intersection_results
CGAL_Ray_2_Iso_rectangle_2_pair<R>::intersection_type() const
@<Ray_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

template <class R>
bool CGAL_Ray_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    CGAL_Point_2<R> p1(_ref_point + _dir*_min);
    CGAL_Point_2<R> p2(_ref_point + _dir*_max);
    seg = CGAL_Segment_2<R>(p1, p2);
    return true;
}

template <class R> bool CGAL_Ray_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = CGAL_Point_2<R>(_ref_point + _dir*_min);
    return true;
}
@}

@$@<Ray_2_Iso_rectangle_2_pair intersection_type body@>@M==@{@-
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    if (_known)
        return _result;
    CGAL_Ray_2_Iso_rectangle_2_pair<R> *ncthis =
                (CGAL_Ray_2_Iso_rectangle_2_pair<R> *) this;
    ncthis->_known = true;
    bool to_infinity = true;
    for (int i=0; i<_ref_point.dimension(); i++) {
        if (_dir.homogeneous(i) == RT(0)) {
            if (_ref_point.cartesian(i) < _isomin.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
            if (_ref_point.cartesian(i) > _isomax.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
        } else {
            FT newmin, newmax;
            if (_dir.homogeneous(i) > RT(0)) {
                newmin = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            } else {
                newmin = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            }
            if (newmin > _min)
                ncthis->_min = newmin;
            if (to_infinity) {
                ncthis->_max = newmax;
            } else {
                if (newmax < _max)
                    ncthis->_max = newmax;
            }
            if (_max < _min) {
                ncthis->_result = NO;
                return _result;
            }
            to_infinity = false;
        }
    }
    CGAL_kernel_assertion(!to_infinity);
    if (_max == _min) {
        ncthis->_result = POINT;
        return _result;
    }
    ncthis->_result = SEGMENT;
    return _result;
}
@}


@B@<2D Segment Iso_rectangle intersection@>


@O@<../include/CGAL/Iso_rectangle_2_Segment_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Iso_rectangle_2_Segment_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_SEGMENT_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Segment_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_SEGMENT_2_ISO_RECTANGLE_2_INTERSECTION_H
@}


@O@<../include/CGAL/Segment_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Segment_2_Iso_rectangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_SEGMENT_2_BBOX_2_INTERSECTION_H
#define CGAL_SEGMENT_2_BBOX_2_INTERSECTION_H

#ifndef CGAL_ISO_RECTANGLE_2_H
#include <CGAL/Iso_rectangle_2.h>
#endif // CGAL_ISO_RECTANGLE_2_H
#ifndef CGAL_SEGMENT_2_H
#include <CGAL/Segment_2.h>
#endif // CGAL_SEGMENT_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H
#ifndef CGAL_UTILS_H
#include <CGAL/utils.h>
#endif // CGAL_UTILS_H
#ifndef CGAL_NUMBER_UTILS_H
#include <CGAL/number_utils.h>
#endif // CGAL_NUMBER_UTILS_H

template <class R>
class CGAL_Segment_2_Iso_rectangle_2_pair {
public:
    enum Intersection_results {NO, POINT, SEGMENT};
    CGAL_Segment_2_Iso_rectangle_2_pair() ;
    CGAL_Segment_2_Iso_rectangle_2_pair(CGAL_Segment_2<R> const *seg,
                          CGAL_Iso_rectangle_2<R> const *rect) ;

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
  Intersection_results intersection_type() const;

#else
  Intersection_results intersection_type() const
 @<Segment_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

    bool                       intersection(
                                    CGAL_Point_2<R> &result) const;
    bool                       intersection(
                                    CGAL_Segment_2<R> &result) const;
protected:
    bool                       _known;
    Intersection_results       _result;
    CGAL_Point_2<R>            _ref_point;
    CGAL_Vector_2<R>           _dir;
    CGAL_Point_2<R>            _isomin;
    CGAL_Point_2<R>            _isomax;
    typename R::FT              _min,
                               _max;
};

@<do_intersect macro@>@(Segment_2@,Iso_rectangle_2@)

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Segment_2<R> &seg,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    typedef CGAL_Segment_2_Iso_rectangle_2_pair<R> is_t;
    is_t ispair(&seg, &iso);
    switch (ispair.intersection_type()) {
    case is_t::NO:
    default:
        return CGAL_Object();
    case is_t::POINT: {
        CGAL_Point_2<R> ipt;
        ispair.intersection(ipt);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(ipt));
    }
    case is_t::SEGMENT: {
        CGAL_Segment_2<R> iseg;
        ispair.intersection(iseg);
        return CGAL_Object(new CGAL_Wrapper< CGAL_Segment_2<R> >(iseg));
    }
    }
}


@<Segment_2_Iso_rectangle_2_pair implementation@>

template <class R>
class CGAL_Iso_rectangle_2_Segment_2_pair:
          public CGAL_Segment_2_Iso_rectangle_2_pair<R> {
public:
    CGAL_Iso_rectangle_2_Segment_2_pair() {}
    CGAL_Iso_rectangle_2_Segment_2_pair(CGAL_Iso_rectangle_2<R> const *rect,
                               CGAL_Segment_2<R> const *seg)
                :CGAL_Segment_2_Iso_rectangle_2_pair<R> (seg, rect){}
};

@<do_intersect macro@>@(Iso_rectangle_2@,Segment_2@)

template <class R>
inline CGAL_Object
CGAL_intersection(
    const CGAL_Iso_rectangle_2<R>&iso,
    const CGAL_Segment_2<R>&seg)
{
    return CGAL_intersection(seg, iso);
}

#endif
@}


@$@<Segment_2_Iso_rectangle_2_pair implementation@>==@{

template <class R>
CGAL_Segment_2_Iso_rectangle_2_pair<R>::CGAL_Segment_2_Iso_rectangle_2_pair()
{
    _known = false;
}

template <class R>
CGAL_Segment_2_Iso_rectangle_2_pair<R>::
CGAL_Segment_2_Iso_rectangle_2_pair(
        CGAL_Segment_2<R> const *seg,
        CGAL_Iso_rectangle_2<R> const *iso)
{
    _known = false;
    _isomin = iso->min();
    _isomax = iso->max();
    _ref_point = seg->source();
    _dir = seg->direction().vector();
    _min = (typename R::FT)(0);
    int main_dir = (CGAL_abs(_dir.x()) > CGAL_abs(_dir.y()) ) ? 0 : 1;
    _max = (seg->target().cartesian(main_dir)-_ref_point.cartesian(main_dir)) /
            _dir.cartesian(main_dir);
}

#ifndef CGAL_CFG_RETURN_TYPE_BUG_2
template <class R>
CGAL_Segment_2_Iso_rectangle_2_pair<R>::Intersection_results
CGAL_Segment_2_Iso_rectangle_2_pair<R>::intersection_type() const
@<Segment_2_Iso_rectangle_2_pair intersection_type body@>
#endif // CGAL_CFG_RETURN_TYPE_BUG_2

template <class R>
bool CGAL_Segment_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Segment_2<R> &seg) const
{
    if (!_known)
        intersection_type();
    if (_result != SEGMENT)
        return false;
    CGAL_Point_2<R> p1(_ref_point + _dir*_min);
    CGAL_Point_2<R> p2(_ref_point + _dir*_max);
    seg = CGAL_Segment_2<R>(p1, p2);
    return true;
}

template <class R> bool CGAL_Segment_2_Iso_rectangle_2_pair<R>::
intersection(CGAL_Point_2<R> &pt) const
{
    if (!_known)
        intersection_type();
    if (_result != POINT)
        return false;
    pt = CGAL_Point_2<R>(_ref_point + _dir*_min);
    return true;
}
@}

@$@<Segment_2_Iso_rectangle_2_pair intersection_type body@>@M==@{@-
{
    typedef typename R::RT RT;
    typedef typename R::FT FT;
    if (_known)
        return _result;
    CGAL_Segment_2_Iso_rectangle_2_pair<R> *ncthis =
                (CGAL_Segment_2_Iso_rectangle_2_pair<R> *) this;
    ncthis->_known = true;
    for (int i=0; i<_ref_point.dimension(); i++) {
        if (_dir.homogeneous(i) == RT(0)) {
            if (_ref_point.cartesian(i) < _isomin.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
            if (_ref_point.cartesian(i) > _isomax.cartesian(i)) {
                ncthis->_result = NO;
                return _result;
            }
        } else {
            FT newmin, newmax;
            if (_dir.homogeneous(i) > RT(0)) {
                newmin = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            } else {
                newmin = (_isomax.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
                newmax = (_isomin.cartesian(i)-_ref_point.cartesian(i)) /
                    _dir.cartesian(i);
            }
            if (newmin > _min)
                ncthis->_min = newmin;
            if (newmax < _max)
                ncthis->_max = newmax;
            if (_max < _min) {
                ncthis->_result = NO;
                return _result;
            }
        }
    }
    if (_max == _min) {
        ncthis->_result = POINT;
        return _result;
    }
    ncthis->_result = SEGMENT;
    return _result;
}
@}

@B@<2D Point Iso_rectangle intersection@>

@O@<../include/CGAL/Iso_rectangle_2_Point_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Iso_rectangle_2_Point_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
MPI, Saarbruecken@)
#ifndef CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Point_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H
@}

@O@<../include/CGAL/Point_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Point_2_Iso_rectangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H
#define CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H

#ifndef CGAL_ISO_RECTANGLE_2_H
#include <CGAL/Iso_rectangle_2.h>
#endif // CGAL_ISO_RECTANGLE_2_H
#ifndef CGAL_POINT_2_H
#include <CGAL/Point_2.h>
#endif // CGAL_POINT_2_H


template <class R>
inline bool
CGAL_do_intersect(
    const CGAL_Point_2<R> &pt,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    return !iso.has_on_unbounded_side(pt);
}

#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Point_2<R> &pt,
    const CGAL_Iso_rectangle_2<R> &iso)
{
    if (CGAL_do_intersect(pt,iso)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

template <class R>
inline bool
CGAL_do_intersect(
    const CGAL_Iso_rectangle_2<R> &iso,
    const CGAL_Point_2<R> &pt)
{
    return !iso.has_on_unbounded_side(pt);
}


template <class R>
inline CGAL_Object
CGAL_intersection(
    const CGAL_Iso_rectangle_2<R> &iso,
    const CGAL_Point_2<R> &pt)
{
    if (CGAL_do_intersect(pt, iso)) {
        return CGAL_Object(new CGAL_Wrapper< CGAL_Point_2<R> >(pt));
    }
    return CGAL_Object();
}

#endif
@}

@O@<../include/CGAL/Iso_rectangle_2_Iso_rectangle_2_intersection.h@>==@{
@<CGAL_heading@>@(@-
include/CGAL/Iso_rectangle_2_Iso_rectangle_2_intersection.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)

#ifndef CGAL_ISO_RECTANGLE_2_ISO_RECTANGLE_2_INTERSECTION_H
#define CGAL_ISO_RECTANGLE_2_ISO_RECTANGLE_2_INTERSECTION_H

#ifndef CGAL_ISO_RECTANGLE_2_H
#include <CGAL/Iso_rectangle_2.h>
#endif // CGAL_ISO_RECTANGLE_2_H
#ifndef CGAL_OBJECT_H
#include <CGAL/Object.h>
#endif // CGAL_OBJECT_H

template <class R>
CGAL_Object
CGAL_intersection(
    const CGAL_Iso_rectangle_2<R> &irect1,
    const CGAL_Iso_rectangle_2<R> &irect2)
{
    const CGAL_Point_2<R> &min1 = irect1.min();
    const CGAL_Point_2<R> &min2 = irect2.min();
    const CGAL_Point_2<R> &max1 = irect1.max();
    const CGAL_Point_2<R> &max2 = irect2.max();
    typename R::FT minx, miny, maxx, maxy;
    CGAL_Point_2<R> newmin;
    CGAL_Point_2<R> newmax;
    minx = (min1.x() >= min2.x()) ? min1.x() : min2.x();
    maxx = (max1.x() <= max2.x()) ? max1.x() : max2.x();
    if (maxx < minx)
        return CGAL_Object();
    miny = (min1.y() >= min2.y()) ? min1.y() : min2.y();
    maxy = (max1.y() <= max2.y()) ? max1.y() : max2.y();
    if (maxy < miny)
        return CGAL_Object();
    if (R::FT_denominator(minx) == R::FT_denominator(miny)) {
        newmin = CGAL_Point_2<R>(R::FT_numerator(minx), R::FT_numerator(miny),
                    R::FT_denominator(minx));
    } else {
        newmin = CGAL_Point_2<R>(R::FT_numerator(minx)*R::FT_denominator(miny),
                    R::FT_numerator(miny)*R::FT_denominator(minx),
                    R::FT_denominator(minx) * R::FT_denominator(miny));
    }
    if (R::FT_denominator(maxx) == R::FT_denominator(maxy)) {
        newmax = CGAL_Point_2<R>(R::FT_numerator(maxx), R::FT_numerator(maxy),
                    R::FT_denominator(maxx));
    } else {
        newmax = CGAL_Point_2<R>(R::FT_numerator(maxx)*R::FT_denominator(maxy),
                    R::FT_numerator(maxy)*R::FT_denominator(maxx),
                    R::FT_denominator(maxx) * R::FT_denominator(maxy));
    }
    return CGAL_make_object(CGAL_Iso_rectangle_2<R>(newmin, newmax));
}

template <class R>
inline bool
CGAL_do_intersect(
    const CGAL_Iso_rectangle_2<R> &irect1,
    const CGAL_Iso_rectangle_2<R> &irect2)
{
    CGAL_Object obj(CGAL_intersection(irect1, irect2));
    CGAL_Iso_rectangle_2<R> irect;
    return (CGAL_assign(irect, obj));
}

#endif
@}


@B@<Packing intersections together@>

@O@<../include/CGAL/intersection_2_2.h@>==@{@-
@<CGAL_heading@>@(@-
include/CGAL/intersection_2_2.h@,@-
intersection_2_2.fw@,@-
Geert-Jan Giezeman@,@-
Saarbruecken@)


#ifndef CGAL_INTERSECTION_2_2_H
#define CGAL_INTERSECTION_2_2_H

#ifndef CGAL_TRIANGLE_2_TRIANGLE_2_INTERSECTION_H
#include <CGAL/Triangle_2_Triangle_2_intersection.h>
#endif // CGAL_TRIANGLE_2_TRIANGLE_2_INTERSECTION_H
#ifndef CGAL_TRIANGLE_2_LINE_2_INTERSECTION_H
#include <CGAL/Triangle_2_Line_2_intersection.h>
#endif // CGAL_TRIANGLE_2_LINE_2_INTERSECTION_H
#ifndef CGAL_TRIANGLE_2_RAY_2_INTERSECTION_H
#include <CGAL/Triangle_2_Ray_2_intersection.h>
#endif // CGAL_TRIANGLE_2_RAY_2_INTERSECTION_H
#ifndef CGAL_TRIANGLE_2_SEGMENT_2_INTERSECTION_H
#include <CGAL/Triangle_2_Segment_2_intersection.h>
#endif // CGAL_TRIANGLE_2_SEGMENT_2_INTERSECTION_H
#ifndef CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Line_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_LINE_2_ISO_RECTANGLE_2_INTERSECTION_H
#ifndef CGAL_RAY_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Ray_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_RAY_2_ISO_RECTANGLE_2_INTERSECTION_H
#ifndef CGAL_SEGMENT_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Segment_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_SEGMENT_2_ISO_RECTANGLE_2_INTERSECTION_H
#ifndef CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Point_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_POINT_2_ISO_RECTANGLE_2_INTERSECTION_H
#ifndef CGAL_ISO_RECTANGLE_2_ISO_RECTANGLE_2_INTERSECTION_H
#include <CGAL/Iso_rectangle_2_Iso_rectangle_2_intersection.h>
#endif // CGAL_ISO_RECTANGLE_2_ISO_RECTANGLE_2_INTERSECTION_H

#endif
@}


