\begin{ccRefClass}{Circle_2<R>}

\ccDefinition

An object of type \ccRefName\ is a circle in the
two-dimensional Euclidean plane $\E^2$. The circle is oriented, i.e.\ 
its boundary has clockwise or counterclockwise \ccHtmlNoLinksFrom{orientation}. The
boundary splits $\E^2$ into a positive and a negative side, where the
positive side is to the left of the boundary. The boundary further
splits $\E^2$ into a bounded and an unbounded side. Note that the
circle can be degenerated, i.e.\ the squared radius may be zero.


% -----------------------------------------------------------------------------
\ccCreation
\ccCreationVariable{c}

\ccHidden
\ccConstructor{ Circle_2( );}{
        introduces an uninitialized variable \ccVar\ of type
        \ccClassTemplateName.}

\ccConstructor{ Circle_2( Point_2<R>  const& center, 
                               R::FT  const& squared_radius,
                               Orientation const& ori = COUNTERCLOCKWISE);}{
        introduces a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to the circle with center \ccc{center},
        squared radius \ccc{squared_radius} and \ccHtmlNoLinksFrom{orientation}
        \ccc{ori}.
        \ccPrecond \ccc{ori} $\neq$ \ccc{COLLINEAR}, and further,
                   \ccc{squared_radius} $\geq$ 0.}

\ccConstructor{ Circle_2( Point_2<R> const& p,
                          Point_2<R> const& q,
                          Point_2<R> const& r);}{
        introduces a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to the unique circle which passes through
        the points \ccc{p}, \ccc{q} and \ccc{r}. The \ccHtmlNoLinksFrom{orientation} of
        the circle is the \ccHtmlNoLinksFrom{orientation} of the point triple \ccc{p},
        \ccc{q}, \ccc{r}.
        \ccPrecond \ccc{p}, \ccc{q}, and \ccc{r} are not collinear.}

\ccConstructor{ Circle_2( Point_2<R>  const& p, 
                               Point_2<R>  const& q,
                               Orientation const& ori 
                                                    = COUNTERCLOCKWISE);}{
        introduces a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to the circle with diameter 
        $\ccTexHtml{\overline{pq}}{pq}$
        and \ccHtmlNoLinksFrom{orientation} \ccc{ori}.
        \ccPrecond \ccc{ori} $\neq$ \ccc{COLLINEAR}.}

\ccConstructor{ Circle_2( Point_2<R>  const& center,
                               Orientation const& ori
                                                    = COUNTERCLOCKWISE);}{
        introduces a variable \ccVar\ of type \ccClassTemplateName.
        It is initialized to the circle with center \ccc{center}, squared
        radius zero and \ccHtmlNoLinksFrom{orientation} \ccc{ori}.
        \ccPrecond \ccc{ori} $\neq$ \ccc{COLLINEAR}.
        \ccPostcond \ccVar.\ccc{is_degenerate()} = \ccc{true}.}

\ccHidden
\ccConstructor{ Circle_2( Circle_2<R> const&);}{
        copy constructor.}

\ccHidden
\ccMemberFunction{ Circle_2<R>& operator = ( Circle_2<R> const&);}{
        assignment.}

% -----------------------------------------------------------------------------
\ccAccessFunctions

\ccMemberFunction{Point_2<R> const& center( ) const;}{
        returns the center of \ccVar.}
\ccGlue
\ccMemberFunction{ R::FT const& squared_radius( ) const;}{
        returns the squared radius of \ccVar.}
\ccGlue
\ccMemberFunction{ Orientation const& orientation( ) const;}{
        returns the \ccHtmlNoLinksFrom{orientation} of \ccVar.}

% -----------------------------------------------------------------------------

\ccHidden\ccMemberFunction{ bool operator == ( Circle_2<R> const& circle2) const;}{
        returns \ccc{true}, iff \ccVar\ and \ccc{circle2} are equal,
        i.e.\ if they have the same center, same squared radius and
        same \ccHtmlNoLinksFrom{orientation}.}

\ccHidden\ccMemberFunction{ bool operator != ( Circle_2<R> const& circle2) const;}{
        returns \ccc{true}, iff \ccVar\ and \ccc{circle2} are not equal.}

% -----------------------------------------------------------------------------
\ccPredicates

\ccMemberFunction{ bool is_degenerate( ) const;}{
        returns \ccc{true}, iff \ccVar\ is degenerate, i.e.\
        if \ccVar\ has squared radius zero.}

\ccMemberFunction{ Oriented_side
                   oriented_side( Point_2<R> const& p) const;}{
        returns either the constant \ccc{ON_ORIENTED_BOUNDARY}, 
        \ccc{ON_POSITIVE_SIDE}, or \ccc{ON_NEGATIVE_SIDE},
        iff \ccc{p} lies on the boundary, properly on the
        positive side, or properly on the negative side
        of \ccVar, resp.}

\ccMemberFunction{ Bounded_side
                   bounded_side( Point_2<R> const& p) const;}{
        returns \ccc{ON_BOUNDED_SIDE},
        \ccc{ON_BOUNDARY}, or \ccc{ON_UNBOUNDED_SIDE}
        iff \ccc{p} lies properly inside, on the boundary, or properly
        outside of \ccVar, resp.}

%\ccMemberFunction{ bool has_on_positive_side( Point const& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies properly on the
%        positive side of \ccVar.}
%
%\ccMemberFunction{ bool has_on_negative_side( Point const& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies properly on the
%        negative side of \ccVar.}
%
%\ccMemberFunction{ bool has_on_boundary( Point const& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies on the boundary
%        of \ccVar.}
%
%\ccMemberFunction{ bool has_on_bounded_side( Point const& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies properly inside \ccVar.}
%
%\ccMemberFunction{ bool
%                   has_on_unbounded_side( Point const& p) const;}{
%        returns \ccc{true}, iff \ccc{p} lies properly outside of \ccVar.}
\ccMethod{bool has_on_positive_side(const Point_2<R> &p) const;}
       {}
\ccGlue
\ccMethod{bool has_on_negative_side(const Point_2<R> &p) const;}
       {}
\ccGlue
\ccMethod{bool has_on_boundary(const Point_2<R> &p) const;}
       {}
\ccGlue
\ccMethod{bool has_on_bounded_side(const Point_2<R> &p) const;}
       {} 
\ccGlue
\ccMethod{bool has_on_unbounded_side(const Point_2<R> &p) const;}
       {}

% -----------------------------------------------------------------------------
\ccHeading{Miscellaneous}

\ccMemberFunction{ Circle_2<R> opposite() const;}{
        returns the circle with the same center and squared radius as
        \ccVar\, but with \ccHtmlNoLinksFrom{opposite} \ccHtmlNoLinksFrom{orientation}.}


\ccMemberFunction{ Circle_2<R> orthogonal_transform(
                       Aff_transformation_2<R> const& at) const;}{
        returns the circle obtained by applying $at$ on \ccVar.
        \ccPrecond \ccc{at} is an orthogonal transformation.}

\ccMemberFunction{ Bbox_2 bbox() const;}{
        returns a bounding box containing \ccVar.}

\ccSeeAlso

\ccRefConceptPage{Kernel::Circle_2} \\

\end{ccRefClass}
