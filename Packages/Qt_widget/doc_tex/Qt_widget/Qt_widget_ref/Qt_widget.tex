% +------------------------------------------------------------------------+
% | CGAL Reference Manual: Reference manual for Qt_widget.tex
% +------------------------------------------------------------------------+
% |
% | 13.12.2001  Radu Ursu
% | 
% | \RCSdef{\qtwidgetRev}{$Revision$}
% | \RCSdefDate{\qtwidgetDate}{$Date$}
% +------------------------------------------------------------------------+

% +-----------------------------------------------------+
\begin{ccRefClass}{Qt_widget}

\ccDefinition

An object of type \ccc{Qt_widget} is a two-dimensional window for graphical IO. It 
is a class that is designed to help \cgal\ users easily visualize \cgal\ 
objects and for advanced users to interact with them. This widget is designed 
only for 2D \cgal\ objects.

\ccInclude{CGAL/Qt_widget.h}
\ccGlue

\ccTypes

The widget class also defines the following enum type to specify
which kind of point representation do you want to use:

\ccEnum{enum PointStyle { PIXEL, CROSS, PLUS, CIRCLE, DISC, RECT, BOX };}{}

\ccCreation
\ccCreationVariable{win}
\ccSetTwoColumns{Qt_widget}{}

\ccConstructor{Qt_widget(QWidget *parent = 0, const char *name = 0);}{}

\ccOperations
\ccSetThreeColumns{const_iterator}{container.begin() const;}{}

%SCALES
\ccHeading{Scaling}

\ccStyle{Qt_widget} provides a scale system. You can use scales for your objects as 
well as you can draw the objects with one scale and look at the objects with 
different scales. Also there is a possibility to tell the widget that you
want that the visible area should be mapped to a certain interval, and the 
widget adjust the scales according to that.

\ccMethod{void set_window(double x_min, double x_max, double y_min, double 
y_max);}{Map the widget coordinates to the interval defined by the rectangle 
with given coordinates. This method should be called after \ccc{show()} from 
\ccStyle{QWidget}.}
\ccMethod{void set_x_scale(double xscale);}{Set the current X scale.}
\ccMethod{void set_y_scale(double yscale);}{Set the current Y scale.}
\ccMethod{void zoom_in(double ratio);}{Multiply X and Y scales by \ccc{ratio}.}
\ccMethod{void zoom_out(double ratio);}{Multiply X and Y scales by \ccc{ratio}.}
\ccMethod{void move_center(double distx, double disty);}{Move the center of the
 widget with \ccc{distx} on the X axis and with \ccc{disty} on the Y axis.}
\ccMethod{void set_center(double x, double y);}{Set the center of the widget to
 \ccStyle{(x, y)}.}

%PAINTER
\ccHeading{Painter}
\ccMethod{void clear();}{Clear the screen. The properties remain the same 
after calling this member function.}
\ccMethod{void lock();}{Locks the widget, keeping the widget away from being 
refreshed. If you lock the widget you should verify that you unlock it 
somewhere else. The number of \ccc{lock()} calls should be the same with the 
number of \ccc{unlock()} calls.}
\ccMethod{void unlock();}{Unlocks the widget, and call \ccc{do_paint()}}

\ccMethod{void do_paint();}{Refresh the widget calling 
\ccc{paintEvent(QPaintEvent *e)} for the \ccc{Qt_widget} only if the widget is 
unlocked. This mean that redraw() is called if and only if the widget is 
unlocked.}

%PROPERTIES
\ccHeading{Properties}
\ccMethod{void setColor(Qcolor c);}{Set the current pen color of the widget to 
be c.}
\ccMethod{void setBackgroundColor(QColor c);}{Set the current background color 
to be c.}
\ccMethod{void setFillColor(QColor c);}{Set the current fill color of the 
widget to be c.}
\ccMethod{void setFilled(bool f);}{Set the status of the widget to true or false
 concerning filling the objects: polygons, circles, rectangles \ldots}
\ccMethod{void setLineWidth(unsigned int i);}{Set the current line width of the widget.}
\ccMethod{void setPointSize(unsigned int i);}{Set the current point size of the widget.}
\ccMethod{void setPointStyle(PointStyle s);}{Set the current point style of the
 widget to s. PointStyle is a enumeration declared in \ccc{Qt_widget}.}
\ccMethod{void setRasterOp(RasterOp r);}{Set the current raster operation.}

%TOOLS
\ccHeading{Tools}
\ccMethod{void attach(Qt_widget_tool* tool);}{Attaches a tool to the
widget. If another tool is already attached this gets detached first.}

\ccMethod{bool has_tool() const;}{Returns true if a tool is attached.}

\ccMethod{void detach_current_tool();}{Detaches the current tool from
the widget.}

%LAYERS
\ccHeading{Layers}
\ccMethod{void attach(Qt_widget_layer* s);}{Add the layer s in the list of 
layers.The last added will be on top of the screen.}
\ccMethod{void detach(Qt_widget_layer* s);}{Remove the layer s from the list. 
s it's a pointer to an existing layer.}
\ccMethod{void activate(Qt_widget_layer* s);}{Activate a layer. s it's a 
pointer to an existing attached layer.}
\ccMethod{void deactivate(Qt_widget_layer* s);}{Deactivate a layer. When you'll
deactivate a layer, that layer will keep the order in the list of
layers. s it's a pointer to an existing attached layer.}
\ccMethod{void redraw();}{If you derive from \ccc{Qt_widget} you have to 
overload this function and put your code for drawing here if you don't use 
\ccc{layers}. Redraw the layers situated in the list. Before 
redraw the layers, clears the screen. Also calls \ccc{widget\_repainted()} for 
current tool.}

%Cgal
\ccHeading{New CGAL Objects}
\ccMethod{void new_object(CGAL::Object obj);}{This function should be called 
by the tools that create \cgal\ objects. It then emits the signal 
\ccc{new_cgal_object(CGAL::Object)}. Other components may catch this signal through a 
\ccc{connect}.}

\ccAccessFunctions
%PROPERTIES
%\ccHeading{Properties}
\ccMethod{QColor color() const;}{Returns the current pen color. The color 
returned is a Qt class.}

\ccMethod{QColor backgroundColor() const;}{Returns the current widget
background color. The color returned is a Qt class.}

\ccMethod{QColor fillColor() const;}{Returns the current color used
for filling the objects. The color returned is a Qt class.}

\ccMethod{PointStyle pointStyle();}{Returns the current point style. PointStyle
 is a enumeration declared in \ccc{Qt_widget}.}

\ccMethod{uint pointSize();}{Returns the current point size.}

\ccMethod{uint lineWidth();}{Returns the current line width.}

\ccMethod{RasterOp rasterOp();}{Return the current raster operation.}


%COORDINATES
%\ccHeading{Coordinates}
\ccMethod{double x_min() const;}{Returns the left \ccc{x} coordinate
of the widget.}
\ccMethod{double y_min() const;}{Returns the lower\ccc{y} coordinate
of the widget.}
\ccMethod{double x_max() const;}{Returns the right\ccc{x} coordinate
of the widget.}
\ccMethod{double y_max() const;}{Returns the upper\ccc{y} coordinate
of the widget.}

\begin{ccAdvanced}
%PAINTER
\ccHeading{Painter and Pixmap}

In order that layers can draw on the drawing area of a widget, they
have to access the underlying pixmap and painter.
 
\ccStyle{Qt_widget} use as a backbuffer for drawing a pixmap
defined inside the class, that is an object of type \ccc{QPixmap}. The
\ccc{QPixmap} class is an off-screen pixel-based paint device. One
common use of the \ccc{QPixmap} class is to enable smooth updating of widgets.
The QPainter class paints on paint devices. There is an object of type 
QPainter defined in \ccStyle{Qt_widget} that uses as a paint device
the \ccc{QPixmap} object.

\ccMethod{QPixmap& get_pixmap();}{Returns the current pixmap.}

\ccMethod{QPainter& painter();}{Returns the current painter.}
\end{ccAdvanced}

%Signals
\ccHeading{Signals}
\ccMethod{void mousePressed(QMouseEvent *e);}{}
\ccMethod{void mouseReleased(QMouseEvent *e);}{}
\ccMethod{void mouseMoved(QMouseEvent *e);}{}
\ccMethod{void resized();}{}
\ccMethod{void new_cgal_object(CGAL::Object);}{Triggered when a new object 
from a tool is received. The user should catch this signal if it's working with
tools that provide \cgal\ objects as input.}
\ccMethod{void custom_redraw();}{Emited in the redraw() function after 
the layers are drawn. If the user wants to draw something after
layers, should connect this signal to his own slot.}

\input{Qt_widget_ref/Operators_for_output.tex}
\input{Qt_widget_ref/Manipulators.tex}



\ccExample

In the given example, that is found in demo/basic/tutorial1/tutorial1.C, it is created an object of type \ccStyle{Qt_widget} and then it's used the operators for output and the manipulators to show some of the widget's functionality.

\ccIncludeExampleCode{Qt_widget/basic/tutorial1/tutorial1.C}

\end{ccRefClass}
% +-----------------------------------------------------+
% EOF







