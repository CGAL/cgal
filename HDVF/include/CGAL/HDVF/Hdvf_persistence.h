// Copyright (c) 2025 LIS Marseille (France).
// All rights reserved.
//
// This file is part of CGAL (www.cgal.org).
//
// $URL$
// $Id$
// SPDX-License-Identifier: GPL-3.0-or-later OR LicenseRef-Commercial
//
// Author(s)     : Alexandra Bac <alexandra.bac@univ-amu.fr>

#ifndef CGAL_HDVF_HDVF_PERSISTENCE_H
#define CGAL_HDVF_HDVF_PERSISTENCE_H

#include <CGAL/license/HDVF.h>

#include <vector>
#include <cassert>
#include <iostream>
#include <random>
#include <functional>
#include <CGAL/OSM/OSM.h>
#include <CGAL/HDVF/Sub_sparse_matrix.h>
#include <CGAL/HDVF/Hdvf_core.h>
#include <CGAL/HDVF/Filtration_lower_star.h>

namespace CGAL {
namespace HDVF {

// Types for persistent homology / cohomology



/*!
 \ingroup PkgHDVFAlgorithmClasses

 The class `Hdvf_persistence` computes persistent homology using HDVFs (over a ring of coefficients which should actually be a **field**). Hence, unlike other persistence algorithms, beside standard persistent intervals informations (birth/death indices, degrees, associated cells), `Hdvf_persistence` also provides **homology and cohomology generators for persistent pairs**. Intuitively, holes die when they are "filled" by a cell: associated homology and cohomology generators provide a representation of the hole and of the cells filling the hole.

 Given a `Filtration`, the `Hdvf_persistence` constructor basically builds a HDVF where indices of cells in the bases follow the filtration order (permutations between initial indices of cells in the chain complex and new indices given by the filtration are stored).
 Besides, `Hdvf_persistence` derives from `Hdvf_core` with the SparseMatrix parameter type set to `Sub_sparse_matrix`. Hence, `Hdvf_persistence` computes homology over a larger and larger sub-complex of `K` (encoded through a Bitboard mask of `Sub_sparse_matrix`) following the filtration `f`. At each step of the filtration, the new cell is paired (A operation) with the youngest cell valid for A.

 A few words about persistent generators. At a given time \f$t_2\f$ along the filtration, let us denote by \f$\tau\f$ the \f$q+1\f$-cell inserted and let us assume that persistent homology computation pairs \f$A(\sigma, \tau)\f$ (let \f$t_1\f$ be the index of \f$\sigma\f$ along the filtration). A new persistent interval \f$(t_1, t_2)\f$is created, generated by \f$\sigma\f$ and filled by \f$\tau\f$.
 Reduction at time \f$t_2-1\f$ (just before the insertion of \f$\tau\f$) provides persistent generators: \f$g(\sigma)\f$ is a cycle and \f$g(\tau)\f$ is a chain "filling" this cycle (before the pairing \f$A(\sigma, \tau)\f$, the HDVF over \f$K_{t_2}\f$ is not perfect, thus \f$g(\tau)\f$ is not a cycle but a chain bounded by \f$q\f$-cycles).

 Next figures illustrate such informations for a filtration of a dented double torus.

 <img src="lower_star_filtration_z.png" align="center" width=20%/>

 Filtration `Filtration_lower_star` along the z axis of a dented double torus.

 <img src="persistence_cycles1.png" align="center" width=20%/>
 <img src="persistence_2generator1.png" align="center" width=20%/>
 <img src="persistence_after1.png" align="center" width=20%/>

 The first persistent hole is a dimension 1 hole with a duration of 0.359 along z.
 - (Left)  the complex at time 622 along the filtration (in blue, the 2-cell \f$\tau\f$ added at time 623). This 1-homology of this complex contains two cycles depicted in white and yellow respectively. Yellow curve: a 1-cycle born at time 319 (with cell \f$\sigma\f$) along the filtration. White curve: the second 1-cycle of this complex (born at time 156 along the filtration).
 - (Middle) the filtration adds the (blue) 2-cell \f$\tau\f$ at time 623: this cell fills one the 1-cycles (actually the "youngest" cycle, thus the yellow one). Middle image illustrates as a yellow patch the "filling 2-chain", a chain a 2-cells filling the hole when the cell \f$\tau\f$ is added. As stated earlier, this filling chain is not a cycle and it equals \f$g(\tau)\f$ in the (non perfect) reduction before the pairing `A(319, 623)` between \f$\sigma\f$ and \f$\tau\f$. Middle figure illustrates that in the (non perfect) HDVF before A operation, \f$g(\tau)\f$ is not a cycle but a chain bounded by \f$q\f$-cycles.
 - (Right) the complex after insertion of \f$\tau\f$ and the pairing `A(319, 623)` between \f$\sigma\f$ and \f$\tau\f$. Only the white 1-cycle remains (actually its persistent lifetime is infinite).

 <img src="persistence_hole2.png" align="center" width=20%/>

 The figure above illustrates next persistent hole (dimension 0 hole) which duration is 0.684 along z. The cell \f$\tau\f$ is added at time 1237 and fills the 0-hole (connected component) introduced at time 756 by the cell \f$\sigma\f$. The persistent generator associated to \f$\sigma\f$ is simply the cell itself identifying its connected component. The persistent generator associated to \f$\tau\f$ is a 1-chain (depicted in yellow) connecting \f$\sigma\f$ to the critical cell identifying the second connected component.

 <img src="persistence_hole3.png" align="center" width=20%/>
 <img src="persistence_hole4.png" align="center" width=20%/>
 <img src="persistence_hole_inf.png" align="center" width=20%/>

 Figures above illustrate next finite persistent intervals and (right) infinite dimension 1 persistent intervals.

 \cgalModels{HDVF}

 \tparam ChainComplex a model of the `AbstractChainComplex` concept, providing the type of abstract chain complex used (the underlying ring of coefficients should be a model of `Field`).
 \tparam Degree a scalar data type used for the degrees of the filtration.
 \tparam FiltrationType a model of the `Filtration` concept, providing the filtration used to compute persistence.

 */

template<typename ChainComplex, typename Degree, typename FiltrationType >
class Hdvf_persistence : public Hdvf_core<ChainComplex, OSM::Sparse_chain, OSM::Sub_sparse_matrix>
{
public:
    /*! \brief Type of coefficients used to compute homology. */
    typedef ChainComplex::Coefficient_ring Coefficient_ring;

    /*! \brief Structure storing (full) persistent interval data:
     * - `time_birth`, `time_death`: persistent interval filtration indices
     * - `cell_birth`, `cell_death`: persistent interval cells
     * - `degree_birth`, `degree_death`: persistent interval degrees
     *
     * Infinite holes are encoded by setting birth data = death data (time, degree and cell).
     */
    struct PerHole {
        size_t time_birth, time_death;
        Degree degree_birth, degree_death;
        Cell cell_birth, cell_death;
        
        /** \brief Computes the (degree) duration of a persistent interval (ie.\ persistent hole)
         *
         * By definitions of "default" values, infinite intervals have a duration of -1.
         */
        inline Degree duration () const
        {
            // Test if the interval is infinite
            if (time_birth == time_death)
                return -1 ;
            else
                return degree_death-degree_birth;
        }
        
        /**
         * \brief Output the hole to a stream.
         */
        inline std::ostream& insert (std::ostream& out_stream) const
        {
            if (time_death != time_birth) // finite interval
            {
                out_stream << "[" << time_birth << " (" << cell_birth.first << ", " << cell_birth.second << ") -> " ;
                out_stream << time_death << " (" << cell_death.first << ", " << cell_death.second << ") / duration: " << duration() << "]" << std::endl ;
            }
            else
            {
                out_stream << "[" << time_birth << " (" << cell_birth.first << ", " << cell_birth.second << ") -> " ;
                out_stream << "inf]" << std::endl ;
            }
            return out_stream ;
        }
    };
    
    // Matrices types
    /*!
     Type of column-major chains
     */
    typedef CGAL::OSM::Sparse_chain<Coefficient_ring, CGAL::OSM::COLUMN> Column_chain;

    /*!
     Type of row-major chains
     */
    typedef CGAL::OSM::Sparse_chain<Coefficient_ring, CGAL::OSM::ROW> Row_chain;

    /*!
     Type of column-major sparse matrices
     */
    typedef CGAL::OSM::Sub_sparse_matrix<Coefficient_ring, CGAL::OSM::COLUMN> Column_matrix;

    /*!
     Type of row-major sparse matrices
     */
    typedef CGAL::OSM::Sub_sparse_matrix<Coefficient_ring, CGAL::OSM::ROW> Row_matrix;

    /*! Type of parent HDVF class (Hdvf_core with appropriate template parameters)
     * The SparseMatrix model is set to Sub_sparse_matrix to activate (co)homology computation over a subcomplex.
     */
    typedef Hdvf_core<ChainComplex, CGAL::OSM::Sparse_chain, CGAL::OSM::Sub_sparse_matrix> HDVF_parent ;

    /*! Type of filtrations used to compute persistence.
     */
    typedef FiltrationType Filtration;

    /*! Type for `PRIMARY`/`SECONDARY`/`CRITICAL` labels export
     *      Encoding used:
     *          - `PRIMARY`: -1
     *          - `SECONDARY`: +1
     *          - `CRITICAL`: 0
     */
    typedef std::vector<std::vector<int> > ExpLabels ;

    /*! Type  chains export (column-major chains)
     */
    typedef Column_chain ExpChain ;

    /*! For persistent diagram iterator (returned by *it)
     */
    typedef struct {
        PerHole hole ;
        ExpLabels labelsPSC ;
        ExpChain g_chain_sigma, g_chain_tau, fstar_chain_sigma, fstar_chain_tau ;
    } PerIntervalInformation ;

protected:
    /* \brief Reference to the filtration used for persistence */
    const Filtration &_f ;

    /* \brief Permutation between indices in the chain complex K and indices along the filtration
     * Indices along the filtration provide new indices for cells in each dimension.
     */
    std::vector<std::vector<size_t> > _K_to_per, _per_to_K ;

    /* \brief Vector of persistent pairs computed */
    std::vector<PerHole> _persist ;

    /* \brief Boolean determining weather or not export homology/cohomology generators associated to persistent pairs
     * - If _with_export is true, PSC labels and homology/cohomology generators are stored for each persistent pair of duration (that is, such as the difference between degrees of birth/death) strictly positive.
     * - If _with_export is false, only persistent intervals are stored.
     */
    bool _with_export ;

    /* \brief Vector of exported PSC labels */
    std::vector<ExpLabels> _export_labels ;

    /* \brief Vector of exported homology/cohomology generators */
    std::vector<std::pair<ExpChain, ExpChain> > _export_g, _export_fstar ;

    /* Warning:
     * In order to encode "time" as an unsigned int while the initial value is -1,
     * we store current times + 1
     */

    /* Current time + 1 (that is, current index + 1) in the filtration */
    size_t _t ;
    /* Current time +1 (that is, current index + 1) along each dimension */
    std::vector<size_t> _t_dim ;

    /* Bitboard masks in each dimension
     * At a given filtration time, only cells already met have a bit set to 1
     */
    std::vector<OSM::Bitboard> _masks ;


private:
    // Hide find_pair_A methods of the Hdvf_core class
    // Hide A operation of the Hdvf_core class
    // This operation is redefined with a different prototype in Hdvf_persistence and set as private since persistence lets no choice for A pairing (rule of the "youngest")
    using HDVF_parent::find_pair_A;
    using HDVF_parent::find_pairs_A;
    using HDVF_parent::A;
public:
    /**
     * \brief Hdvf_persistence default constructor
     *
     * Builds an "empty" HDVF_persistence (with all cells critical) associated to the chain complex `K` and the filtration `f`.
     * By default, the HDVF option is set to OPT_FULL (full reduction computed)
     *
     * \param[in] K A chain complex (a model of `AbstractChainComplex`).
     * \param[in] f A filtration (a model of `Filtration`).
     * \param[in] hdvf_opt Option for HDVF computation (`OPT_BND`, `OPT_F`, `OPT_G` or `OPT_FULL`)
     * \param[in] with_export Boolean option to activate or not the export of PSC labels and homology/cohomology generators for of persistent intervals of positive duration. This information is used by vtk exporters.
     */
    Hdvf_persistence(const ChainComplex& K, const Filtration& f, int hdvf_opt = OPT_BND, bool with_export = false) ;

    /**
     * \brief Computes a perfect persistent HDVF.
     *
     * This method follows the filtration and considers cells one by one. For each of them, it searches the youngest possible cell valid for A (returned by `find_pair_A()`), and applies the corresponding `A()` operation.
     * By definition of persistent homology, the `Ring` of coefficients *must be* a field.
     *
     * \param[in] verbose If this parameter is `true`, all intermediate reductions are printed out.
     *
     * \returns The vector of all `Cell_pair` paired with A.
     */
    std::vector<Cell_pair> compute_perfect_hdvf(bool verbose = false)
    {
        bool found;
        Cell_pair pair;
        std::vector<Cell_pair> res ;
        for (size_t i=0; i < _f._filtration.size(); ++i)
        {
            this->progress_bar(i, _f._filtration.size()) ;
            found = false ;
            pair = step_persist(found, verbose) ;
            if (found)
                res.push_back(pair) ;
        }

        // Compute "infinite" holes
        std::vector<std::vector<size_t> > criticals(this->flag(CRITICAL)) ;
        for (int q=0; q < criticals.size(); ++q)
        {
            for (size_t i : criticals.at(q))
            {
                // i : persistence index
                // encoding of the second "infinite" cell:
                //  -> equals the first cell (ie. birth = death)
                const Cell_pair p = {i, this->_K.number_of_cells(q+1), q} ;
                const size_t ki(_per_to_K.at(q).at(i)) ; // K index
                const Cell c(ki,q) ;
                const size_t ti(_f._cell_to_t.at(c)) ;
                const Degree di(_f._deg.at(i)) ;

                PerHole hole;
                hole.time_birth = ti;
                hole.time_death = ti;
                hole.degree_birth = di;
                hole.degree_death = di;
                hole.cell_birth = c;
                hole.cell_death = c;
                
                _persist.push_back(hole) ;

                // If export is on, store export data
                if (_with_export)
                    export_hdvf_persistence_pair(p) ;
            }
        }
        return res;
    }

    /** \brief Gets the "with_export" %Boolean flag.
     *  If the flag is `true`, homology/cohomology generators and corresponding PSC labels are exported for each persistent interval of positive duration.
     */
    bool with_export () { return _with_export ; }

    /** \brief Get a constant reference on the filtration
     */
    const Filtration& get_filtration() { return _f; }

    /** \brief Overload of operator<< for Hdvf_persistence.
     *
     * Prints out finite and infinite persistence intervals.
     *
     * \param[in] out Reference to an out stream.
     * \param[in] per_hdvf Constant reference on the Hdvf_persistence to print.
     */
    friend std::ostream& operator<< (std::ostream& out_stream, const Hdvf_persistence& per_hdvf)
    {
        size_t i = 0 ;
        for (PerHole hole : per_hdvf._persist)
        {
            if (hole.duration() > 0)
            {
                out_stream << i << " --- duration : " << hole.duration() << " -- " ;
                hole.insert(out_stream);
                out_stream << std::endl ;
            }
            ++i ;
        }
        return out_stream ;
    }

    /** \brief Prints informations related to the filtration.
     *
     * Prints out the filtration and associated permutations (_K_to_per and _per_to_K) between indices of cells in each dimension in the basis of K and indices along the filtration.
     *
     * \param[in] out Reference to an out stream.
     */
    std::ostream& print_hdvf_persistence_info (std::ostream& out)
    {
        out << "Filtration: " << _f << std::endl ;
        out << "_K_to_per and _per_to_K" << std::endl ;
        for (int q=0; q<=this->_K.dimension(); ++q)
        {
            out << "-> dim " << q << std::endl ;
            out << "index_per -(_per_to_K)-> index_K -(_K_to_per)-> index_per" << std::endl ;
            for (size_t i=0; i<this->_K.number_of_cells(q); ++i)
            {
                const size_t id_K(_per_to_K.at(q).at(i)) ;
                out << i << " -> " << id_K << " -> " << _K_to_per.at(q).at(id_K) << std::endl ;
            }
        }
        return out ;
    }


    /**
     * \brief Exports primary/secondary/critical labels (e.g. for vtk export).
     *
     * The method exports the labels of every cells in each dimension.
     * Encoding used:
     * - `PRIMARY`: -1
     * - `SECONDARY`: +1
     * - `CRITICAL`: 0
     *
     * \returns A vector containing, for each dimension, the vector of labels by cell index.
     */
    virtual std::vector<std::vector<int> > psc_labels () const
    {
        std::vector<std::vector<int> > labels(this->_K.dimension()+1) ;
        for (int q=0; q<=this->_K.dimension(); ++q)
        {
            for (size_t i = 0; i<this->_K.number_of_cells(q); ++i)
            {
                const size_t id_per(_K_to_per.at(q).at(i)) ;
                if (id_per < _t_dim.at(q))
                {
                    if (this->_flag.at(q).at(id_per) == PRIMARY)
                        labels.at(q).push_back(-1) ;
                    else if (this->_flag.at(q).at(id_per) == SECONDARY)
                        labels.at(q).push_back(1) ;
                    else if (this->_flag.at(q).at(id_per) == CRITICAL)
                        labels.at(q).push_back(0) ;
                    else // NONE
                        labels.at(q).push_back(2) ;
                }
                else
                    labels.at(q).push_back(2) ;
            }
        }
        return labels ;
    }

    /**
     * \brief Exports homology generators associated to `cell` (critical cell) of dimension  `q` (e.g. forx@ vtk export).
     *
     * The method exports the chain \f$g(\sigma)\f$ for \f$\sigma\f$ the cell of index `cell` and dimension `q`.
     *
     * \returns A column-major chain.
     */
    virtual Column_chain homology_chain (size_t cell, int q) const
    {
        if ((q<0) || (q>this->_K.dimension()))
            throw "Error : homology_chain with dim out of range" ;

        if (this->_hdvf_opt & (OPT_FULL | OPT_G))
        {
            // Get g(cell, dim) with per indices
            Column_chain g_cell(OSM::get_column(this->_G_col.at(q), cell)) ;
            // Add 1 to the cell
            g_cell.set_coefficient(cell, 1) ;
            // Compute the chain with _K indices
            Column_chain g_cell_K(g_cell.dimension()) ;
            for (typename Column_chain::const_iterator it = g_cell.begin(); it != g_cell.end(); ++it)
            {
                const size_t i(_per_to_K.at(q).at(it->first)) ;
                g_cell_K.set_coefficient(i, it->second) ;
            }
            return g_cell_K ;
        }
        else
            throw "Error : trying to export g_chain without proper HDVF option" ;
    }

    /**
     * \brief Exports cohomology generators associated to `cell` (critical cell) of dimension  `q` (used by vtk export).
     *
     * The method exports the chain \f$f^\star(\sigma)\f$ for \f$\sigma\f$ the cell of index `cell` and dimension `q`.
     *
     * \returns A column-major chain.
     */
    virtual Column_chain cohomology_chain (size_t cell, int q) const
    {
        if ((q<0) || (q>this->_K.dimension()))
            throw "Error : homology_chain with dim out of range" ;

        if (this->_hdvf_opt & (OPT_FULL | OPT_F))
        {
            // Get fstar(cell, dim) with per indices
            Row_chain fstar_cell(OSM::get_row(this->_F_row.at(q), cell)) ;
            // Add 1 to the cell
            fstar_cell.set_coefficient(cell, 1) ;

            // Compute the chain with _K indices
            Column_chain fstar_cell_K(fstar_cell.dimension()) ;
            for (typename Column_chain::const_iterator it = fstar_cell.begin(); it != fstar_cell.end(); ++it)
            {
                const size_t i(_per_to_K.at(q).at(it->first)) ;
                fstar_cell_K.set_coefficient(i, it->second) ;
            }
            return fstar_cell_K ;
        }
        else
            throw "Error : trying to export f_star_chain without proper HDVF option" ;
    }

    /*! \brief Iterator over (finite) persistent intervals.
     *
     * Iterate over persistent intervals of finite degree duration.
     * If `discard_small` is true (which is the default), the iterator discards persistent intervals with a null degree duration (that is, small persistent holes).
     */
    struct iterator
    {
        // Iterator tags
        using iterator_category = std::forward_iterator_tag;
        using difference_type   = std::ptrdiff_t;
        using value_type        = PerIntervalInformation;

        /*! \brief Iterator constructor
         *
         * \param[in] per_hdvf Constant reference over the Hdvf_persistence iterated.
         * \param[in] i The initial index.
         * \param[in] discard_small If `true` (default), only persistent intervals of (strictly) positive degree duration are iterated. Otherwise, all persistent intervals are iterated.
         */
        iterator(const Hdvf_persistence& per_hdvf, size_t i=0, bool discard_small = true) : _i(i), _per_hdvf(per_hdvf), _discard_small(discard_small)
        {
            if(_discard_small)
            {
                // Iterate only over holes of duration > 0
                while ((_i<_per_hdvf._persist.size()) && ((_per_hdvf._persist.at(_i)).duration() == 0))
                {
                    ++_i ;
                }
            }
        }

        /** \brief Returns the `discard_small` flag. */
        bool has_discard_small() { return _discard_small; }

        // Operators
        /*! \brief Iterator dereference
         *
         * \returns A `PerIntervalInformation` structure containing the information of the current persistence interval.
         */
        value_type operator*() const
        {
            PerIntervalInformation res ;
            res.hole = _per_hdvf._persist.at(_i) ;
            res.labelsPSC = _per_hdvf._export_labels.at(_i) ;
            if (_per_hdvf._hdvf_opt & (OPT_G | OPT_FULL))
            {
                res.g_chain_sigma = _per_hdvf._export_g.at(_i).first ;
                res.g_chain_tau = _per_hdvf._export_g.at(_i).second ;
            }
            if (_per_hdvf._hdvf_opt & (OPT_F | OPT_FULL))
            {
                res.fstar_chain_sigma = _per_hdvf._export_fstar.at(_i).first ;
                res.fstar_chain_tau = _per_hdvf._export_fstar.at(_i).second ;
            }
            return res ;
        }

        /**
         * \brief Prefix incrementation. Finds next persistent interval.
         *
         * If `discard_small` is true, the iterator searches next persistent interval with a (strictly) positive degree duration, otherwise, the iterator returns next persistent interval.
         *
         * \returns The reference to the current iterator.
         */
        iterator& operator++()
        {
            ++_i;
            if (_discard_small)
            {
                // Iterate only over holes of duration > 0
                while ((_i<_per_hdvf._persist.size()) && ((_per_hdvf._persist.at(_i)).duration() == 0))
                {
                    ++_i ;
                }
            }
            return *this;
        }

        /**
         * \brief Postfix incrementation. Finds the next not-null index.
         * \returns The pre-incremented iterator.
         */
        iterator operator++(int) { iterator tmp = *this; ++(*this); return tmp; }

        /**
         * \brief Equality check.
         * \returns True if the indices are equal.
         */
        friend bool operator== (const iterator& a, const iterator& b) { return a._i == b._i; };

        /**
         * \brief Inequality check.
         * \returns True if the indices are different.
         */
        friend bool operator!= (const iterator& a, const iterator& b) { return a._i != b._i; };

    private:
        size_t _i ; // Index along _persist
        const Hdvf_persistence& _per_hdvf ; // per_hdvf iterated
        const bool _discard_small ;
    };

    /**
     * \brief Iterator to the beginning of persistent intervals.
     *
     * \param[in] discard_small If `true`, the iterator visits only persistent intervals of (strictly) positive degree duration. Otherwise, visit all persistent intervals.
     *
     * \returns The iterator to the beginning of the chains indices.
     */
    iterator begin(bool discard_small = true) { return iterator(*this, 0, discard_small) ; }

    /**
     * \brief Iterator to the ending of the chains indices.
     *
     * \returns The iterator to the ending of the chains indices.
     */
    iterator end() { return iterator(*this, _persist.size()) ; }

private:
    /* \brief Export current persistent pair informations.
     *
     * This method exports and saves PSC labels, homology and cohomology generators of the current persistent pair `p` to corresponding private vectors (_export_label, _export_g, _export_fstar).
     * The method is invoqued on the result of `find_pair_A` before pairing cells with the A operation.
     */
    void export_hdvf_persistence_pair(Cell_pair p)
    {
        // Export labels
        ExpLabels labels(this->psc_labels()) ;
        _export_labels.push_back(labels) ;
        // Export g (according to options)
        if (this->_hdvf_opt & (OPT_FULL | OPT_G))
        {
            Column_chain chain_sigma(homology_chain(p.sigma, p.dim)) ;
            Column_chain chain_tau ;
            if (p.tau != this->_K.number_of_cells(p.dim+1)) // Check if the second cell is "finite"
                chain_tau = homology_chain(p.tau, p.dim+1) ;
            _export_g.push_back(std::pair<Column_chain,Column_chain>(chain_sigma, chain_tau)) ;
        }
        // Export fstar (according to options)
        if (this->_hdvf_opt & (OPT_FULL | OPT_F))
        {
            Column_chain chain_sigma(cohomology_chain(p.sigma, p.dim)) ;
            Column_chain chain_tau ;
            if (p.tau != this->_K.number_of_cells(p.dim+1)) // Check if the second cell is "finite"
                chain_tau = cohomology_chain(p.tau, p.dim+1) ;
            _export_fstar.push_back(std::pair<Column_chain,Column_chain>(chain_sigma, chain_tau)) ;
        }
    }

    /* \brief Export empty persistent pair.
     * Export empty persistence information (for "small" discarded pairs).
     */
    void export_hdvf_persistence_pair()
    {
        // Export labels
        ExpLabels labels ;
        _export_labels.push_back(labels) ;
        // Export g (according to options)
        if (this->_hdvf_opt & (OPT_FULL | OPT_G))
        {
            Column_chain chain_sigma, chain_tau ;
            _export_g.push_back(std::pair<Column_chain,Column_chain>(chain_sigma, chain_tau)) ;
        }
        // Export fstar (according to options)
        if (this->_hdvf_opt & (OPT_FULL | OPT_F))
        {
            Column_chain chain_sigma, chain_tau ;
            _export_fstar.push_back(std::pair<Column_chain,Column_chain>(chain_sigma, chain_tau)) ;
        }
    }

    /*
     * \brief Find a valid Cell_pair for A for persistent homology.
     *
     * The function searches, at a given time \f$t\f$ in the filtration, the youngest critical cell \f$\gamma'\f$ forming a valid pair with the cell \f$\gamma\f$. Hence, \f$(\gamma', \gamma)\f$ valid pair is a valid pair
     * (ie.\ such that \f$\langle \partial(\gamma), \gamma' \rangle\f$ invertible).
     *
     * \param[in] found Reference to a %Boolean variable. The method sets `found` to `true` if a valid pair is found, `false` otherwise.
     */
    Cell_pair find_pair_A(bool &found) ;

    /*
     * \brief Step forward along the filtration.
     *
     * Searches a possible persistent pair for A with `find_pair_A`, apply A and update internal structures.
     */
    Cell_pair step_persist(bool& found, bool verbose = false) ;
} ;


template<typename ChainComplex, typename Degree, typename FiltrationType>
Hdvf_persistence<ChainComplex, Degree, FiltrationType>::Hdvf_persistence(const ChainComplex& K, const FiltrationType& f, int hdvf_opt, bool with_export) : Hdvf_core<ChainComplex, OSM::Sparse_chain, OSM::Sub_sparse_matrix>(K,hdvf_opt), _f(f), _with_export(with_export), _t(0)
{
    // Initialisation of _t_dim, _K_to_per and _per_to_K
    _t_dim.resize(this->_K.dimension()+1, 0) ;
    _K_to_per.resize(this->_K.dimension()+1) ;
    _per_to_K.resize(this->_K.dimension()+1) ;
    for (int q=0; q<=this->_K.dimension(); ++q)
    {
        _K_to_per.at(q).resize(this->_K.number_of_cells(q)) ;
        _t_dim.at(q) = 0 ;
    }

    for (size_t i = 0; i<_f._filtration.size(); ++i)
    {
        const Cell c(_f._filtration.at(i));
        const int q(c.second) ;
        const size_t ind_K_i(c.first) ;
        const size_t ind_per_i(_per_to_K.at(q).size()) ;
        _per_to_K.at(q).push_back(ind_K_i) ;
        _K_to_per.at(q).at(ind_K_i) = ind_per_i ;
    }

    // Init _masks
    _masks.resize(this->_K.dimension()+1) ;
    for (int q=0; q<this->_K.dimension()+1; ++q)
    {
        _masks.at(q) = OSM::Bitboard(this->_K.number_of_cells(q)) ;
    }

    // Init boundary matrices
    std::vector<Column_matrix> _DD_per(this->_K.dimension()+1) ;

    // Copy _DD_col with filtration order (for dimensions q>0)
    for (int q = 0 ; q <= this->_K.dimension(); ++q)
    {
        const std::pair<int, int> s(this->_DD_col.at(q).dimensions()) ;
        _DD_per.at(q) = Column_matrix(s.first, s.second) ;
    }
    // Set empty mask for _DD_per[0]
    _DD_per.at(0).complement();

    for (int q = 1 ; q <= this->_K.dimension(); ++q)
    {
        // Cross _DD_col.at(q) and set _DD_per.at(q) coefficients on the fly
        for (OSM::Bitboard::iterator it_col = this->_DD_col.at(q).begin(); it_col != this->_DD_col.at(q).end(); ++it_col)
        {
            const size_t j(*it_col) ;
            const Column_chain& col(OSM::cget_column(this->_DD_col.at(q), j)) ;
            for (typename Column_chain::const_iterator it = col.begin(); it != col.end(); ++it)
            {
                const size_t i(it->first) ;
                const Coefficient_ring v(it->second) ;
                // Cells in the _K basis : i(dim q-1) / j(dim q)
                // Convert to indices in the persistent order
                const size_t pi(_K_to_per.at(q-1).at(i)), pj(_K_to_per.at(q).at(j)) ;
                set_coefficient(_DD_per.at(q), pi, pj, v) ;
            }
        }
    }
    this->_DD_col = _DD_per ;

    // Init _DD_col mask (empty for all cells)
    for (int q = 1 ; q <= this->_K.dimension(); ++q)
        this->_DD_col.at(q).set_sub(_masks.at(q)) ;
}

template<typename ChainComplex, typename Degree, typename FiltrationType>
Cell_pair Hdvf_persistence<ChainComplex, Degree, FiltrationType>::find_pair_A(bool &found)
{
    Cell_pair p ;
    // Get current cell (in the basis K)
    const size_t current_time(_t-1);
    Cell c(_f._filtration.at(current_time)) ;
    const int q(c.second), sigma(_K_to_per.at(q).at(c.first))  ;
    // Search for pairing
    found = false;

    if (q >= 1)
    {
        // Compute bounded max while iterating over the Sparse_chain
        const Column_chain& tmp2(OSM::cget_column(this->_DD_col.at(q), sigma)) ;
        std::size_t tmax = _t_dim.at(q-1) ;
        std::size_t i ;
        for (typename Column_chain::const_iterator it = tmp2.cbegin(); it != tmp2.cend(); ++it)
        {
            if ((it->first < tmax) && (abs(it->second) == 1)) // possible pairing
            {
                if (!found) // for first cell met
                {
                    found = true ;
                    i = it->first ;
                }
                else // update the i with the maximum cell index (persistance)
                {
                    if (it->first > i)
                        i = it->first ;
                }
            }
        }
        if (found)
        {
            p.sigma = i ;
            p.tau = sigma ;
            p.dim = q-1 ;
        }
    }
    return p;
}

template<typename ChainComplex, typename Degree, typename FiltrationType>
Cell_pair Hdvf_persistence<ChainComplex, Degree, FiltrationType>::step_persist(bool& found, bool verbose)
{
    // Compute next persistent pair

    ++_t ; // Step forward in the filtration
    const size_t t_current(_t-1); // Current time
    const size_t q_current(_f._filtration.at(t_current).second) ; // Get the dimension of the new current cell
    ++_t_dim.at(q_current) ; // Update time in the dimension of the current cell
    const size_t t_dim_current(_t_dim.at(q_current)-1); // Time of the current cell in its dimension
    _masks.at(q_current).setOn(t_dim_current) ; // Update mask accordingly
    this->_DD_col.at(q_current).set_bit_on(t_dim_current) ; // Update _DD_col mask

    // Search for pairing
    Cell_pair p(find_pair_A(found)) ;
    if (found)
    {
        // Corresponding persistent interval
        const int q(p.dim) ;
        // indices of both cells in the _K basis
        const size_t ki(_per_to_K.at(q).at(p.sigma)), kj(_per_to_K.at(q+1).at(p.tau)) ;
        Cell ci(ki, q), cj(kj, q+1) ; // cells of the interval - in the K basis
        size_t ti(_f._cell_to_t.at(ci)), tj(_f._cell_to_t.at(cj)) ; // times of the interval
//        FiltrIndexPerInterval interval(ti, tj) ;
//        CellsPerInterval interval_cells(ci, cj) ;
//        DegreePerInterval interval_deg(_f._deg.at(ti), _f._deg.at(tj)) ;
//        PerHole hole(interval, interval_cells, interval_deg) ;
        PerHole hole;
        hole.time_birth = ti;
        hole.time_death = tj;
        hole.degree_birth = _f._deg.at(ti);
        hole.degree_death = _f._deg.at(tj);
        hole.cell_birth = ci;
        hole.cell_death = cj;
        // Add this interval
        _persist.push_back(hole) ;

        // If export is on, store export data for significant persistant intervals
        if (_with_export)
        {
            if (hole.duration() > 0) /*((interval_deg.second-interval_deg.first)>0)*/
                export_hdvf_persistence_pair(p) ;
            else
                export_hdvf_persistence_pair() ;
        }


        // Prepare for next step
        this->A(p.sigma, p.tau, p.dim) ; // Update the reduction
        if (verbose)
        {
            std::cout << "A : " << p.sigma << " - " << p.tau << " (dim " << p.dim << ")" << std::endl ;
            this->insert_matrices(std::cout) ;
        }
    }
    return p;
}

// HELP !!!!!
template<typename ChainComplex, typename Degree, typename FiltrationType >
std::ostream& operator<< (std::ostream& out_stream, const typename Hdvf_persistence<ChainComplex, Degree, FiltrationType>::PerHole& hole)
{
    typedef Hdvf_persistence<ChainComplex, Degree, FiltrationType> HDVF_parent;
    // time (cell, dim) -> time (cell, dim) / degree duration

    if (hole.time_death != hole.time_birth) // finite interval
    {
        out_stream << "[" << hole.time_birth << " (" << hole.cell_birth.first << ", " << hole.cell_birth.second << ") -> " ;
        out_stream << hole.time_death << " (" << hole.cell_death.first << ", " << hole.cell_death.second << ") / duration: " << hole.duration() << "]" << std::endl ;
    }
    else
    {
        out_stream << "[" << hole.time_birth << " (" << hole.cell_birth.first << ", " << hole.cell_birth.second << ") -> " ;
        out_stream << "inf]" << std::endl ;
    }
    return out_stream ;
}

} /* end namespace HDVF */
} /* end namespace CGAL */

#endif // CGAL_HDVF_HDVF_PERSISTENCE_H
