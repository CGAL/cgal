/*!
\ingroup PkgHDVFConcepts
\cgalConcept

The concept `HDVF` describes the requirements for Homological Discrete Vector Fields (HDVF for short) , a theory of computational homology unifying discrete Morse theory and effective homology.
 A HDVF is a combinatorial tool computing the homology of a chain complex (described by the `AbstractChainComplex` concept) including "geometric" information such as homology and cohomology generators.
 
 As described in the package description, an HDVF is:
 - a partition of the cells of the underlying complex into three classes: primary, secondary and critical (together with partial invertibility conditions for the boundary operator)
 - an associated reduction \f$(f,g,h)\f$ from the chain complex onto a chain complex generated by critical cells and a reduced boundary.
 An HDVF is perfect when the reduced boundary is null; in this case, the maps \f$f\f$ and \f$g\f$ (and their duals) provide homology and cohomology information (generators, annotation...).
 
 More precisely, a HDVF over a chain complex C, derived from a complex K, is a partition of the cells: \f$K = P\coprod S\coprod C\f$ with \f$P\f$ primary cells, \f$S\f$ secondary cells and \f$C\f$ critical cells, such that the sub-matrix:
 \f\[\partial (S)|_P\text{ is invertible.}
 \f\]
 In what follows, given \f$q\in \mathbb N\f$ and \f$G\f$ a sub-group of the qth chain group \f$C_q\f$, we denote by:
 
 - \f$i_G\f$ the inclusion \f$G\to C_q\f$
 - \f$j_G\f$ the projection \f$C_q\to G\f$

That is, for all \f$q\in \mathbb N\f$, if
 
 \f\[\mathrm{Mat}(\partial_q) = \begin{array}{lc}
 & P_q \ \ \ \ S_q \ \ \ \ C_q \\
 \begin{array}{l}
 P_{q-1} \\
 S_{q-1} \\
 C_{q-1} \\
 \end{array} & \left(\begin{array}{ccc}
 \star & D_{PS} & \star \\
\star & \star & \star \\
\star & \star & \star \\
 \end{array}\right)\\
 \end{array}
 \f\]
 then \f$D_{PS}\f$, the matrix of \f$j_P\circ \partial\circ i_S\f$, is invertible.
 
 In order to build a perfect HDVF, a pairing operation called `A` associates (under conditions) two critical cells (becoming PRIMARY and SECONDARY) and updates the reduction in time \f$\mathcal O(n^2)\f$.
 Starting from this operation, `HDVF` provides two methods to generate perfect HDVFs (and hence compute homology):
 - `compute_perfect_hdvf` which computes a perfect HDVF by chosing at each step the first A-pairings available (depending on cells ordering in the chain complex)
 - `compute_rand_perfect_hdvf` which computes a perfect random HDVF by chosing at each step a rand A-pairing among all possible ones  (this option is thus slower)
 
 For efficiency, the HDVF reduction can be computed partialy:
 - compute only the reduced boundary  (option `OPT_BND`): to get Betti numbers
 - compute \f$\partial'\f$ together with \f$h\f$ and \f$g\f$ (option `OPT_G`): to get homology generators
 - compute \f$\partial'\f$ together with \f$h\f$ and \f$f\f$ (option `OPT_F`): to get co-homology generators
 - compute the full reduction (option `OPT_FULL`): to get the full homological / cohomological information

\cgalHasModelsBegin
\cgalHasModelsBare{`Hdvf_core<Ring, AbstractChainComplex, SparseChain, Sparse_matrix>`}
\cgalHasModelsBare{`Hdvf<Ring, AbstractChainComplex>`}
\cgalHasModelsBare{`Hdvf_persistence<Ring, AbstractChainComplex>`}
\cgalHasModelsBare{`Hdvf_duality<Ring, AbstractChainComplex>`}
\cgalHasModelsEnd

 \sa `AbstractChainComplex`
 \sa `Ring`
 \sa `SparseChain`
 \sa `Sparsematrix`
 
 *How to describe constants declared in the namespace HDVF and used everywhere? FlagType, options, exporttype*
 
*/

class HDVF
{
public:
/// \name Types
/// @{

/*!
 * \brief Type of coefficients stored in the matrix (a model of `Ring`).
 */
typedef Ring CoefficientType;
    
/*!
 Type of column-major chains
 */
typedef OSM::Chain<CoefficientType, OSM::COLUMN> CChain;

/*!
 Type of row-major chains
 */
typedef OSM::Chain<CoefficientType, OSM::ROW> RChain ;

/*!
 Type of column-major sparse matrices
 */
typedef OSM::SparseMatrix<CoefficientType, OSM::COLUMN> CMatrix;
    
/*!
 Type of row-major sparse matrices
 */
typedef OSM::SparseMatrix<CoefficientType, OSM::ROW> RMatrix;

/// @}

/// \name Functions to find valid pairs for A operations
/// @{
    
/*!
 * \brief Find a valid PairCell of dimension q / q+1 for A.
 *
 * The function finds a pair of critical cells \f$(\gamma_1, \gamma2)\f$ of dimension q / q+1, valid for A (ie. such that \f$\langle \partial_{q+1}(\gamma_2), \gamma_1 \rangle\f$ invertible). It returns the first valid pair found by iterators.
 *
 * Sets `found` to `true` if a valid pair is found, `false` otherwise.
 */
virtual PairCell find_pair_A(int q, bool &found) const;
    
/*!
 * \brief Find a valid PairCell for A containing `gamma` (a cell of dimension `q`)
 *
 * The function finds a cell \f$\gamma'\f$ such that one of the following conditions holds:
 * - \f$\gamma'\f$ has dimension q+1 and \f$(\gamma, \gamma')\f$ is valid for A (ie. such that \f$\langle \partial_{q+1}(\gamma'), \gamma \rangle\f$ invertible),
 * - \f$\gamma'\f$ has dimension q-1 and \f$(\gamma', \gamma)\f$ is valid for A (ie. such that \f$\langle \partial_{q}(\gamma), \gamma' \rangle\f$ invertible).
 *
 * Sets `found` to `true` if a valid pair is found, `false` otherwise.
 */
virtual PairCell find_pair_A(int q, bool &found, int gamma) const;

/*!
 * \brief Find all valid PairCell of dimension q / q+1 for A.
 *
 * The function returns all pairs of critical cells \f$(\gamma_1, \gamma2)\f$ of dimension q / q+1, valid for A (ie. such that \f$\langle \partial_{q+1}(\gamma_2), \gamma_1 \rangle\f$ invertible).
 *
 * Sets `found` to `true` if a valid pair is found, `false` otherwise.
 */
virtual std::vector<PairCell> find_pairs_A(int q, bool &found) const;

/*!
 * \brief Find all valid PairCell for A containing `gamma` (a cell of dimension `q`)
 *
 * The function finds all cells \f$\gamma'\f$ such that either:
 * - \f$\gamma'\f$ has dimension q+1 and \f$(\gamma, \gamma')\f$ is valid for A (ie. such that \f$\langle \partial_{q+1}(\gamma'), \gamma \rangle\f$ invertible),
 * - \f$\gamma'\f$ has dimension q-1 and \f$(\gamma', \gamma)\f$ is valid for A (ie. such that \f$\langle \partial_{q}(\gamma), \gamma' \rangle\f$ invertible).
 *
 * Sets `found` to `true` if a valid pair is found, `false` otherwise.
 */
virtual std::vector<PairCell> find_pairs_A(int q, bool &found, int tau) const;

    
/// @}
    
    
/// \name HDVF functions and operations
/// @{

/*!
 * \brief A operation: pairs critical cells.
 *
 * A pair of critical cells \f$(\gamma_1, \gamma_2)\f$ of respective dimension q and q+1 is valid for A if \f$\langle \partial_{q+1}(\gamma_2), \gamma_1 \rangle\f$ is invertible. After the A operation, \f$\gamma_1\f$ becomes PRIMARY, \f$\gamma_2\f$ becomes SECONDARY. The A functions updates the reduction accordingly (in time \f$\mathcal O(n^2)\f$).
 */
void A(int gamma1, int gamma2, int q);
    
/*!
 * \brief Compute a perfect HDVF.
 *
 * As long as valid pairs for A exist, the function selects the first available pair (returned by `find_pair_A`) and applies the corresponding A operation.
 * If the `Ring` of coefficients is a field, this operation always produces a perfect HDVF (ie. the reduced boundary is null and the reduction provides homology and cohomology information).
 *
 * If the HDVF is initially not trivial (some cells have already been paired), the function completes it into a perfect HDVF.
 *
 * If the `verbose` parameter is `true`, all intermediate reductions are printed out.
 *
 */
std::vector<PairCell> compute_perfect_hdvf(bool verbose = false);

/*!
 * \brief Compute a random perfect HDVF.
 *
 *As long as valid pairs for A exist, the function selects a random pair (among pairs returned by `find_pairs_A`) and applies the corresponding A operation.
 * If the `Ring` of coefficients is a field, this operation always produces a perfect HDVF (ie. the reduced boundary is null and the reduction provides homology and cohomology information).
 *
 * If the HDVF is initially not trivial (some cells have already been paired), the function randomly completes it into a perfect HDVF.
 *
 * If the `verbose` parameter is `true`, all intermediate reductions are printed out.
 */
std::vector<PairCell> compute_rand_perfect_hdvf(bool verbose = false);
/// @}
    
/// \name Getters
/// @{

/*!
 * \brief Get cells with a given `flag` in any dimension.
 *
 * The function returns in each dimension the vector of cells with a given `flag`.
 */
std::vector<std::vector<int> > get_flag (FlagType flag) const;
    
/*!
 * \brief Get cells with a given `flag` in dimension `q`.
 *
 * The function returns the vector of cells of dimension `q` with a given `flag`.
 */
std::vector<int> get_flag_dim (FlagType flag, int q) const;

/*!
 * \brief Get the flag of the cell `tau` in dimension `q`.
 */
FlagType get_cell_flag (int q, int tau) const;

/*!
 * \brief Get HDVF option.
 */
int get_hdvf_opts ();

/*!
 * \brief Get the row-major matrix of \f$f\f$ (from the reduction associated to the HDVF).
 */
const RMatrix& get_f (int q) const;

/*!
 * \brief Get the column-major matrix of \f$g\f$ (from the reduction associated to the HDVF).
 */
const CMatrix& get_g (int q) const;

/*!
 * \brief Get the column-major matrix of \f$h\f$ (from the reduction associated to the HDVF).
 */
const CMatrix& get_h (int q) const;
    
/*!
 * \brief Get the column-major matrix of \f$\partial'\f$, reduced boundary operator (from the reduction associated to the HDVF).
 */
const CMatrix& get_dd (int q) const;

/// @}

/// \name Output functions
/// @{

/*!
 * Prints the matrices of the reduction (that is \f$f\f$, \f$g\f$, \f$h\f$, \f$\partial'\f$ the reduced boundary).
 *
 * By default, outputs the complex to `std::cout`.
*/
std::ostream& print_matrices(std::ostream &out = std::cout) const;

/*!
 * Prints the homology and cohomology reduction information (that is \f$f^*\f$, \f$g\f$ \f$\partial'\f$ the reduced boundary over each critical cell).
 *
 * By default, outputs the complex to `std::cout`.
*/
std::ostream& print_reduction(std::ostream &out = std::cout) const;

    
/// @}

};
