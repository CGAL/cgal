/*!
\ingroup PkgHDVFConcepts
\cgalConcept

The concept `HDVF` describes the requirements for Homological Discrete Vector Fields, a theory of computational homology unifying discrete Morse theory and effective homology.
 An HDVF is a combinatorial tool computing the homology of a chain complex (described by the `AbstractChainComplex` concept).
 
 As described in the package description, an HDVF is:
 - a partition of the cells of the underlying complex into three classes: primary, secondary and critical (together with partial invertibility conditions for the boundary operator)
 - an associated reduction \f$(f,g,h)\f$ from the chain complex onto a chain complex generated by critical cells and a reduced boundary.
 An HDVF is perfect when the reduced boundary is null; in this case, the maps \f$f\f$ and \f$g\f$ (and their duals) provide homology and cohomology information (generators, annotation...).
 
 In order to build a perfect HDVF, a pairing operation called `A` associates (under conditions) two critical cells (becoming PRIMARY and SECONDARY) and updates the reduction in time \f$\mathcal O(n^2)\f$.
 Starting from this operation, `HDVF` provides two methods to generate perfect HDVFs (and hence compute homology):
 - `compute_perfect_hdvf` which computes a perfect HDVF by chosing at each step the first A-pairings available (depending on cells ordering in the chain complex)
 - `compute_rand_perfect_hdvf` which computes a perfect random HDVF by chosing at each step a rand A-pairing among all possible ones  (this option is thus slower)

\cgalHasModelsBegin
\cgalHasModelsBare{`HDVF_core<Ring, AbstractChainComplex, SparseChain, SparseMatrix>`}
\cgalHasModelsBare{`HDVF<Ring, AbstractChainComplex>`}
\cgalHasModelsBare{`HDVF_persistence<Ring, AbstractChainComplex>`}
\cgalHasModelsBare{`HDVF_duality<Ring, AbstractChainComplex>`}
\cgalHasModelsEnd

 \sa `AbstractChainComplex`
 \sa `Ring`
 \sa `SparseChain`
 \sa `SparseMatrix`
 
 \warning How to describe constants declared in the namespace HDVF and used everywhere?
 
 /** \brief Enum for the HDVF_core label of cells. */
 static enum FlagType {
     PRIMARY,
     SECONDARY,
     CRITICAL,
     NONE // For duality and persistence
 };

 /** \brief HDVF_core options (compute only reduced boundary). */
 const int OPT_BND = 0b0001;
 /** \brief HDVF_core options (compute only reduced boundary and f). */
 const int OPT_F = 0b0010;
 /** \brief HDVF_core options (compute only reduced boundary and g). */
 const int OPT_G = 0b0100;
 /** \brief HDVF_core options (compute full reduction). */
 const int OPT_FULL = 0b1000;

 /** \brief Enum for export: lets chose the type of export.
  *
  * - PSC export a flag encoding the label of the cell: P (-1), S (1), C (0)
  * - FSTAR exports a boolean flag for a given cohomology generator (true: the cell belongs to the cycle, false: the cell does not belong)
  * - G exports a boolean flag for a given homology generator (true: the cell belongs to the cycle, false: the cell does not belong)
  */
 enum ExportType {
     PSC,
     FSTAR,
     G
 };

 /** \brief PairCell: Structure to represent a pair of cells (for HDVF operations).
  */
 struct PairCell {
     int sigma;  // Index of the first cell
     int tau;    // Index of the second cell
     int dim;    // Dimension of cells: q/q+1 for A and R, q for other operations
 };
 
*/

class HDVF
{
public:
/// \name Types
/// @{

/*!
 Type of column-major chains (returned by the boundary operator)
 */
typedef OSM::Chain<CoefficientType, OSM::COLUMN> CChain;

/*!
 Type of row-major chains (returned by the co-boundary operator)
 */
typedef OSM::Chain<CoefficientType, OSM::ROW> RChain ;

/*!
 Type of column-major sparse matrices (used to store the boundary operator)
 */
typedef OSM::SparseMatrix<CoefficientType, OSM::COLUMN> CMatrix;

/// @}

/// \name Operators
/// @{

/*!
Affectation operator.
 
The operator creates a "fresh" copy of `complex`.
 */
    AbstractChainComplex& operator= (const AbstractChainComplex& complex);
    
/// @}
    
/// \name Access functions
/// @{

/*!
Returns the dimension of the complex, that is, the largest dimension of cells.
 */
int dim();

/*!
Returns the number of cells of dimension `q`.
If `q` is negative of larger than the dimension of the complex, returns 0.
 */
int nb_cells(int q);

/*!
Returns all boundary matrices.
 
The function returns constant reference to a vector of column-major sparse matrices. The `q`-th element of this vector is the matrix of \f$\partial_q\f$, which gives the boundary of cells of dimension `q`(as a linear combination of `q`-1 cells).

 */
const vector<CMatrix> & get_bnd_matrices() const;

/*!
Returns the boundary matrix of dimension `q` (ie. the matrix of \f$\partial_q}\f$).
 
The function returns a column-major sparse matrices.
 */
const CMatrix & get_bnd_matrix(int q) const;

/*!
Returns the boundary of the cell of index `id_cell` in dimension `q`.

This boundary is a finite linear combination of cells of dimension `q`-1. It is encoded as a column-major chain (which maps each cell with a non-zero coefficient to this coefficient). This boundary  is thus the `id_cell`-th column of the boundary matrix in dimension `q`.
 
*/
CChain d(int id_cell, int q);

    
/*!
Returns the co-boundary of the cell of index `id_cell` in dimension `q`.

This boundary is a finite linear combination of cells of dimension `q`+1. It is encoded as a row-major chain (which maps each cell with a non-zero coefficient to this coefficient). This co-boundary  is thus the `id_cell`-th row of the boundary matrix in dimension `q`+1.
*/
CChain cod(int id_cell, int q);

/*!
Returns the vertices of a given cell (that is, the indices of its faces of dimension 0).
 
*/
    std::vector<int> bottom_faces(int id_cell, int q) const;

/// @}

/// \name Output functions
/// @{

/*!
Outputs the chain complex in text mode.
 
By default, outputs the complex to `std::cout`.
*/
std::ostream& print_complex(std::ostream& out = std::cout) const;
    
/// @}

};
