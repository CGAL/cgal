/*!
\ingroup PkgHDVFConcepts
\cgalConcept

The concept `HDVF` describes the requirements for Homological Discrete Vector Fields (%HDVF for short) , a theory of computational homology unifying discrete Morse theory and effective homology. HDVFs were introduced by Aldo Gonzalez-Lorenzo in his PhD (see [AGL,2017], [AGL,2016]).

A HDVF is a combinatorial tool computing the homology of a chain complex (described by the `AbstractChainComplex` concept) including "geometric" information such as homology and cohomology generators.

 As described in the user manual description, an HDVF is:
 - a partition of the cells of the underlying complex into three classes: primary (P), secondary (S) and critical (C), together with partial invertibility conditions for the boundary operator,
 - an associated reduction \f$(f,g,h)\f$ from the chain complex onto a chain complex generated by critical cells and a reduced boundary.
 A HDVF is perfect when the reduced boundary is null; in this case, the maps \f$f\f$ and \f$g\f$ (and their duals) provide homology and cohomology information (generators, annotation...).

 More precisely, a HDVF over a chain complex C, derived from a complex K, is a partition of the cells: \f$K = P\coprod S\coprod C\f$ with \f$P\f$ primary cells, \f$S\f$ secondary cells and \f$C\f$ critical cells, such that the sub-matrix:
 \f\[\partial (S)|_P\text{ is invertible.}
 \f\]
 In what follows, given \f$q\in \mathbb N\f$ and \f$G\f$ a sub-group of the qth chain group \f$C_q\f$, we denote by:

 - \f$i_G\f$ the inclusion \f$G\to C_q\f$
 - \f$j_G\f$ the projection \f$C_q\to G\f$

That is, for all \f$q\in \mathbb N\f$, if

 \f\[\mathrm{Mat}(\partial_q) = \begin{array}{lc}
 & P_q \ \ \ \ S_q \ \ \ \ C_q \\
 \begin{array}{l}
 P_{q-1} \\
 S_{q-1} \\
 C_{q-1} \\
 \end{array} & \left(\begin{array}{ccc}
 \star & D_{PS} & \star \\
\star & \star & \star \\
\star & \star & \star \\
 \end{array}\right)\\
 \end{array}
 \f\]
 then \f$D_{PS}\f$, the matrix of \f$j_P\circ \partial\circ i_S\f$, also written \f$\partial (S)|_P\f$ is invertible.

 In order to build a perfect HDVF, a pairing operation called `A()` associates (under conditions) two critical cells (becoming PRIMARY and SECONDARY) and updates the reduction in time \f$\mathscr O(n^2)\f$. Intuitively, this operation bears some similitudes (see users guide) with discrete Morse theory's DGVF arrows (and an HDVF can always be represented by such a vector field - possibly with cycles).
 Given a HDVF \f$X = (P,S,C)\f$, A operation between two cells \f$(\gamma_1, \gamma_2)\f$ of respective dimension \f$q/q+1\f$ is valid if \f$(P',S',C') = (P\cup\{\gamma_1\}, P\cup\{\gamma_2\}, C\backslash\{\gamma_1,\gamma_2\})\f$ is a HDVF (ie.\ if \f$j_{P'}\circ \partial\circ i_{S'}\f$ is still invertible). This is actually the case if and only if \f$\langle d(\gamma_2), \gamma_1 \rangle\f$ (with \f$d\f$ the reduced boundary operator) is invertible. This condition is called the *validity condition for A*; all the `find_pair_A()` and `find_pairs_A()` methods search for such valid pairs.


 Starting from this operation, `HDVF` provides two methods to generate perfect HDVFs (and hence compute homology):
 - `compute_perfect_hdvf()` which computes a perfect HDVF by chosing at each step the first A-pairings available (depending on cells ordering in the chain complex)
 - `compute_rand_perfect_hdvf()` which computes a perfect random HDVF by chosing at each step a rand A-pairing among all possible ones  (this option is thus slower)

 For efficiency, the HDVF reduction can be computed partially:
 - compute only the reduced boundary  (option `OPT_BND`): to get Betti numbers
 - compute \f$\partial'\f$ together with \f$h\f$ and \f$g\f$ (option `OPT_G`): to get homology generators
 - compute \f$\partial'\f$ together with \f$h\f$ and \f$f\f$ (option `OPT_F`): to get co-homology generators
 - compute the full reduction (option `OPT_FULL`): to get the full homological / cohomological information

 Let us consider a simple cubical complex example (see \ref secHDVFcubical_chain_complex for an introduction). In what follows, PRIMARY cells are coloured green, SECONDARY are coloured red and critical blue. The picture below shows an initial empty HDVF where all cells are critical:

 <img src="HDVF_ex1.png" align="center" width=40%/>

 The boundary matrix of \f$\partial_2\f$ (which equals the reduced boundary matrix as the HDVF is empty) for \f$\mathbb Z\f$-homology is (cells are identified by their Khalimsky coordinates):
 \f\[\mathrm{Mat}(\partial_2) = \begin{array}{lc}
 & (3,1)\\
 \begin{array}{l}
 (3,0) \\
 (2,1) \\
 (4,1) \\
 (3,2) \\
 \end{array} & \left(\begin{array}{c}
 1 \\
 -1 \\
 1 \\
 -1 \\
 \end{array}\right)\\
 \end{array}
 \f\]
 Let us consider \f$\gamma_2 = (3,1)\f$ and \f$\gamma_1 = (3,2)\f$, the condition for A is valid (-1 is invertible). The following images illustrates this pairing in discrete Morse theory "style" (pink arrow in left complex) and the resulting HDVF (right complex).

 <img src="HDVF_ex1_A1_arrow.png" align="center" width=30%/>
 <img src="HDVF_ex1_A1.png" align="center" width=30%/>

 The reduced boundary matrix in dimension 2 becomes empty and the matrix of \f$d_1\f$ is similar to the boundary matrix \f$\partial_1\f$ with the row/colums associated to previous cells removed.

 Thus, if we now consider \f$\gamma_2 = (4,1)\f$ and \f$\gamma_1 = (4,0)\f$, the condition for A is valid; cells can be paired and we obtain the following HDVF:

 <img src="HDVF_ex1_A2_arrow.png" align="center" width=30%/>
 <img src="HDVF_ex1_A2.png" align="center" width=30%/>

 The process can be continued step by step:

 <img src="HDVF_ex1_A3_arrow.png" align="center" width=30%/>
 <img src="HDVF_ex1_A3.png" align="center" width=30%/>

 Until we eventually get a perfect HDVF:

 <img src="HDVF_ex1_perfect.png" align="center" width=40%/>

 Each hole is identified by a critical cell and the \f$g\f$ map of the reduction provides associated homology generators (highlighted in blue):

 <img src="HDVF_ex1_perfect_hom1.png" align="center" width=30%/>
 <img src="HDVF_ex1_perfect_hom2.png" align="center" width=30%/>
 <img src="HDVF_ex1_perfect_hom3.png" align="center" width=30%/>

 A corresponding cohomology generators (highlighted in pink):

 <img src="HDVF_ex1_perfect_cohom1.png" align="center" width=30%/>
 <img src="HDVF_ex1_perfect_cohom2.png" align="center" width=30%/>
 <img src="HDVF_ex1_perfect_cohom3.png" align="center" width=30%/>


\cgalHasModelsBegin
\cgalHasModelsBare{`CGAL::HDVF::Hdvf_core<Ring, AbstractChainComplex, SparseChain, Sparse_matrix>`}
\cgalHasModelsBare{`CGAL::HDVF:Hdvf<Ring, AbstractChainComplex>`}
\cgalHasModelsBare{`CGAL::HDVF:Hdvf_persistence<Ring, AbstractChainComplex>`}
\cgalHasModelsBare{`CGAL::HDVF:Hdvf_duality<Ring, AbstractChainComplex>`}
\cgalHasModelsEnd

 \sa `AbstractChainComplex`
 \sa `Ring`
 \sa `SparseChain`
 \sa `SparseMatrix`

 *How to describe constants declared in the namespace HDVF and used everywhere? FlagType, options, exporttype*

 [AGL, 2017] Aldo Gonzalez-Lorenzo, Alexandra Bac, Jean-Luc Mari, Pedro Real. Allowing cycles in discrete Morse theory, Topology and its Applications, Volume 228, 2017, Pages 1-35.

 [AGL, 2016] Aldo Gonzalez-Lorenzo. Computational Homology Applied to Discrete Objects. Discrete Mathematics [cs.DM]. Aix-Marseille UniversiteÃÅ; Universidad de Sevilla, 2016.

*/

class HDVF
{
public:
/// \name Types
/// @{

/*!
 * \brief Type of underlying chain complex (a model of `AbstractChainComplex`).
 */
typedef unspecified_type ComplexType;
    
/*! \brief Type of coefficients used to compute homology. */
typedef ComplexType::Coefficient_type Coefficient_type;

/*!
 * \brief Type of sparse chains (a model of `SparseChain`).
 */
    typedef unspecified_type SparseChainType;

/*!
 * \brief Type of sparse matrices (a model of `SparseMatrix`).
 */
    typedef unspecified_type SparseMatrixType;

/*! \brief Structure to represent data for HDVF operations (pairs of cells).
 *
 * Cells are always sorted so that the dimension of `sigma` is lesser than the dimension of `tau`.
 */
struct Cell_pair {
    /// Index of the first cell
    size_t sigma; 
    /// Index of the second cell
    size_t tau;   
    /// Dimension of cells: `dim`/`dim`+1 for `A()` and `R()`, `dim`/`dim` for other operations
    int dim;    
};
    
/*!
 Type of column-major chains
 */
typedef SparseChainType<CoefficientType, CGAL::OSM::COLUMN> Column_chain;

/*!
 Type of row-major chains
 */
typedef SparseChainType<CoefficientType, CGAL::OSM::ROW> Row_chain ;

/*!
 Type of column-major sparse matrices
 */
typedef SparseMatrixType<CoefficientType, CGAL::OSM::COLUMN> Column_matrix;

/*!
 Type of row-major sparse matrices
 */
typedef SparseMatrixType<CoefficientType, CGAL::OSM::ROW> Row_matrix;

/// @}

/// \name Functions to find valid pairs for `A()` operations
/// @{

/*!
 * \brief Finds a valid Cell_pair of dimension q / q+1 for A.
 *
 * The function searches a pair of critical cells \f$(\gamma_1, \gamma2)\f$ of dimension q / q+1, valid for A (ie.\ such that \f$\langle \partial_{q+1}(\gamma_2), \gamma_1 \rangle\f$ invertible). It returns the first valid pair found by iterators.
 *
 * \param[in] q Lower dimension of the pair.
 * \param[in] found Reference to a %Boolean variable. The method sets `found` to `true` if a valid pair is found, `false` otherwise.
 */
virtual Cell_pair find_pair_A(int q, bool &found) const;

/*!
 * \brief Finds a valid Cell_pair for A containing `gamma` (a cell of dimension `q`)
 *
 * The function searches a cell \f$\gamma'\f$ such that one of the following conditions holds:
 * - \f$\gamma'\f$ has dimension q+1 and \f$(\gamma, \gamma')\f$ is valid for A (ie.\ such that \f$\langle \partial_{q+1}(\gamma'), \gamma \rangle\f$ invertible),
 * - \f$\gamma'\f$ has dimension q-1 and \f$(\gamma', \gamma)\f$ is valid for A (ie.\ such that \f$\langle \partial_{q}(\gamma), \gamma' \rangle\f$ invertible).
 *
 * \param[in] q Dimension of the cell `gamma`.
 * \param[in] found Reference to a %Boolean variable. The method sets `found` to `true` if a valid pair is found, `false` otherwise.
 * \param[in] gamma Index of a cell to pair.
 */
virtual Cell_pair find_pair_A(int q, bool &found, size_t gamma) const;

/**
 * \brief Finds *all* valid Cell_pair of dimension q / q+1 for A.
 *
 * The function searches all pairs of critical cells \f$(\gamma_1, \gamma2)\f$ of dimension q / q+1, valid for A (ie.\ such that \f$\langle \partial_{q+1}(\gamma_2), \gamma_1 \rangle\f$ invertible).
 * It returns a vector of such pairs.
 *
 * \param[in] q Lower dimension of the pair.
 * \param[in] found Reference to a %Boolean variable. The method sets `found` to `true` if a valid pair is found, `false` otherwise.
 */
virtual std::vector<Cell_pair> find_pairs_A(int q, bool &found) const;

/**
 * \brief Finds *all* valid Cell_pair for A containing `gamma` (a cell of dimension `q`)
 *
 * The function searches all critical cells \f$\gamma'\f$ such that one of the following conditions holds:
 * - \f$\gamma'\f$ has dimension q+1 and \f$(\gamma, \gamma')\f$ is valid for A (ie.\ such that \f$\langle \partial_{q+1}(\gamma'), \gamma \rangle\f$ invertible),
 * - \f$\gamma'\f$ has dimension q-1 and \f$(\gamma', \gamma)\f$ is valid for A (ie.\ such that \f$\langle \partial_{q}(\gamma), \gamma' \rangle\f$ invertible).
 * It returns a vector of such pairs.
 *
 * \param[in] q Dimension of the cell `gamma`.
 * \param[in] found Reference to a %Boolean variable. The method sets `found` to `true` if a valid pair is found, `false` otherwise.
 * \param[in] gamma Index of a cell to pair.
 */
virtual std::vector<Cell_pair> find_pairs_A(int q, bool &found, size_t gamma) const;


/// @}


/// \name HDVF functions and operations
/// @{

/*!
 * \brief A operation: pairs two critical cells.
 *
 * A pair of critical cells \f$(\gamma_1, \gamma_2)\f$ of respective dimension q and q+1 is valid for A if \f$\langle \partial_{q+1}(\gamma_2), \gamma_1 \rangle\f$ is invertible. After the `A()` operation, \f$\gamma_1\f$ becomes PRIMARY, \f$\gamma_2\f$ becomes SECONDARY. The A functions updates the reduction accordingly (in time \f$\mathscr O(n^2)\f$).
 */
void A(size_t gamma1, size_t gamma2, int q);

/*!
 * \brief Computes a perfect HDVF.
 *
 * As long as valid pairs for A exist, the function selects the first available pair (returned by `find_pair_A()`) and applies the corresponding `A()` operation.
 * If the `Ring` of coefficients is a field, this operation always produces a perfect HDVF (ie.\ the reduced boundary is null and the reduction provides homology and cohomology information).
 *
 * If the HDVF is initially not trivial (some cells have already been paired), the function completes it into a perfect HDVF.
 *
 * \param verbose If `true`, all intermediate reductions are printed out.
 *
 */
std::vector<Cell_pair> compute_perfect_hdvf(bool verbose = false);

/*!
 * \brief Computes a random perfect HDVF.
 *
 *As long as valid pairs for A exist, the function selects a random pair (among pairs returned by `find_pairs_A()`) and applies the corresponding `A()` operation.
 * If the `Ring` of coefficients is a field, this operation always produces a perfect HDVF (ie.\ the reduced boundary is null and the reduction provides homology and cohomology information).
 *
 * If the HDVF is initially not trivial (some cells have already been paired), the function randomly completes it into a perfect HDVF.
 *
 * \param verbose If `true`, all intermediate reductions are printed out.
 */
std::vector<Cell_pair> compute_rand_perfect_hdvf(bool verbose = false);
/// @}

/// \name Getters
/// @{

/*!
 * \brief Gets cells with a given `flag` in any dimension.
 *
 * The function returns in each dimension the vector of cells with a given `flag`.
 */
std::vector<std::vector<size_t> > flag (FlagType flag) const;

/*!
 * \brief Gets cells with a given `flag` in dimension `q`.
 *
 * The function returns the vector of cells of dimension `q` with a given `flag`.
 */
std::vector<size_t> flag_dim (FlagType flag, int q) const;

/*!
 * \brief Gets the flag of the cell `tau` in dimension `q`.
 */
FlagType cell_flag (int q, size_t tau) const;

/*!
 * \brief Gets HDVF option.
 */
int hdvf_opts ();

/*!
 * \brief Gets the row-major matrix of \f$f\f$ (from the reduction associated to the HDVF).
 */
const Row_matrix& matrix_f (int q) const;

/*!
 * \brief Gets the column-major matrix of \f$g\f$ (from the reduction associated to the HDVF).
 */
const Column_matrix& matrix_g (int q) const;

/*!
 * \brief Gets the column-major matrix of \f$h\f$ (from the reduction associated to the HDVF).
 */
const Column_matrix& matrix_h (int q) const;

/*!
 * \brief Gets the column-major matrix of \f$\partial'\f$, reduced boundary operator (from the reduction associated to the HDVF).
 */
const Column_matrix& matrix_dd (int q) const;

/*!
 * \brief Tests if a HDVF is perfect.
 *
 * The function returns `true` if the reduced boundary matrix is null and `false` otherwise.
 */
    bool is_perfect_hdvf();

/// @}

/// \name Output functions
/// @{

/*!
 * \brief Prints the matrices of the reduction.
 *
 * Prints the matrices of the reduction (that is \f$f\f$, \f$g\f$, \f$h\f$, \f$\partial'\f$ the reduced boundary).
 *
 * By default, outputs the complex to `std::cout`.
*/
std::ostream& insert_matrices(std::ostream &out = std::cout) const;

/*! \brief Prints the homology and cohomology reduction information.
 *
 * Prints the homology and cohomology reduction information (that is \f$f^*\f$, \f$g\f$ \f$\partial'\f$ the reduced boundary over each critical cell).
 *
 * By default, outputs the complex to `std::cout`.
*/
std::ostream& insert_reduction(std::ostream &out = std::cout) const;

/*!
 *\brief Saves a HDVF and its reduction to a %hdvf file.
 *
 * Save a HDVF together with the associated reduction (f, g, h, d matrices) to a %hdvf file.
 */

std::ostream& insert_hdvf_reduction(std::ostream& out) ;

/*!
 * \brief Loads a HDVF and its reduction from a `.hdvf` file.
 *
 * Load a HDVF and its reduction from a `.hdvf` file, a simple text file format (see for a specification).
 */
std::istream& extract_hdvf_reduction(std::istream& out) ;

/*!
 * \brief Exports primary/secondary/critical labels (in particular for vtk export).
 *
 * The method exports the labels of every cell in each dimension.
 *
 * \return A vector containing, for each dimension, the vector of labels by cell index.
 */
virtual std::vector<std::vector<int> > psc_labels () const;

/*!
 * \brief Returns a chain containing the homology generator associated to `cell` (critical cell) of dimension  `q` (in particular for vtk export).
 *
 * The method exports the chain \f$g(\sigma)\f$ for \f$\sigma\f$ the cell of index `cell` and dimension `q`.
 *
 * \return A column-major chain.
 */
virtual Column_chain homology_chain (size_t cell, int q) const;

/*!
 * \brief Returns a chain containing the cohomology generators associated to `cell` (critical cell) of dimension  `q` (in particular for vtk export).
 *
 * The method exports:
 * - the chain \f$f^\star(\sigma)\f$ for \f$\sigma\f$ the cell of index `cell` and dimension `q`,
 * - or the co-faces of this chain if `co_faces` is true (sometimes easier to view cohomology generators)
 *
 * Below, a sample mesh with, (left) homology generators, (right) two examples of cohomology generators (corresponding generators/co-generators bear similar colours):
 *
 * <img src="HDVF_dtorus_homs.png" align="center" width=25%/>
 * <img src="HDVF_dtorus_cohom1.png" align="center" width=25%/>
 * <img src="HDVF_dtorus_cohom2.png" align="center" width=25%/>
 *
 * The same generators displayed through their co-faces:
 *
 * <img src="HDVF_dtorus_cohom1_co.png" align="center" width=25%/>
 * <img src="HDVF_dtorus_cohom2_co.png" align="center" width=25%/>
 *
 * All homology / cohomology generators:
 *
 *<img src="HDVF_dtorus_all.png" align="center" width=30%/>
 *
 * \return A column-major chain.
 */
virtual Column_chain cohomology_chain (size_t cell, int dim, bool co_faces = false) const;

/// @}

};
