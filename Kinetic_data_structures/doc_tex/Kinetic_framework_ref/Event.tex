% +------------------------------------------------------------------------+
% | Reference manual page: Event.tex
% +------------------------------------------------------------------------+
% | 20.03.2005   Author
% | Package: Kinetic_data_structures
% | 
\RCSdef{\RCSEventRev}{$Id$}
\RCSdefDate{\RCSEventDate}{$Date$}
% |
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+

\ccDefGlobalScope{CGAL::}
\begin{ccRefConcept}[Kinetic::Simulator::]{Event}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[concept]{} %% add further index entries

\ccDefinition
  
The concept \ccClassName\ represents a single event. Models of
\ccClassName\ should be passed to the \ccc{Kinetic::Simulator} when
scheduling events which will in turn pass them to the
\ccc{EventQueue}.

\ccCreationVariable{a}  %% choose variable name

\ccOperations

\ccMethod{void process();}{This method is called when the event
  occurs. This method will only be called once per time this event is
  scheduled and the event will be removed from the queue immediately
  afterwards.}

\ccMethod{void* kds();}{Return a \ccc{void *} which represents the KDS
  which this event belongs to. The pointer is used solely to tell if
  two events come from the same KDS for the purposes of handling
  degeneracy.}



\ccMethod{CGAL::Comparison_result compare_concurrent(Key a, Key b)
  const;}{The two events \ccc{a} and \ccc{b} occur at the same time
  (\ccc{this} has key \ccc{a}). This method returns a
  \ccc{CGAL::Comparison_result} which is used to order the two equal
  events. If \ccc{CGAL::EQUAL} is returned then \ccc{merge} will be
  called.}

\ccMethod{bool merge_concurrent(Key a, Key b);}{ The two events
  \ccc{a} and \ccc{b} occur at the same time (\ccc{this} has key
  \ccc{a}) and cannot be perturbed to be unequal. This event allows
  the KDS to merge event \ccc{b} with \ccc{a}. If it returns
  \ccc{true} then \ccc{b} is dropped from the event queue.}

\ccMethod{void audit(Key this_key);}{Audit that this is a valid event.
  To use this, kinetic data structure can check that this event is
  indeed pointed to by the correct part of the combinatorial
  structure. }

\ccMethod{std::ostream& write(std::ostream&) const;}{Write the event to a stream.}

%\ccMethod{void degenerate_events(Event_key this_event, Event_key other_event);}{This event and the event referenced by \ccc{k} belong to the same KDS and occur simultaneously. This function call gives the KDS a chance to handle } 

\ccHasModels

All over the place. \ccc{Kinetic::Event_base}.

\ccSeeAlso

\ccc{Kinetic::EventQueue}

\ccExample

All of the kinetic data structures provided have models of
\ccRefName. Here is the code implementing a swap event from the
sorting kinetic data structure. Events occuring at equal times are
perturbed so that the one that occurs first in the list is processed
first (just to illustrate the idea).

\begin{ccExampleCode}
template <class Certificate, class Id, class Root_enumerator> 
class Swap_event {
  typedef Swap_event<class Certificate, class Id, class Root_enumerator> This;
public:
  Swap_event(Id o, Sort* sorter, 
	     const Certificate &s): left_object_(o), 
                                    sorter_(sorter), 
                                    s_(s){}
  void process(){
    sorter_->swap(left_object_, s_);
  }
  void *kds() const {return sorter_;}
  CGAL::Comparison_result perturb_comparison(typename Sort::Event_key a, typename Sort::Event_key b) const {
    return CGAL::compare(std::distance(sorter_->objects_begin(), left_object_),
                         std::distance(sorter_->objects_begin(),
			               sorter_->simulator_handle()->get_event<This>(b).left_object_));
  }
  bool merge(typename Sort::Event_key a, typename Sort::Event_key b) {
    return false;
  }
  Id left_object_; 
  Sort* sorter_; 
  Certificate s_;
};
\end{ccExampleCode}


\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

