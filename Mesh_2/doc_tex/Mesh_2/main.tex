\ccUserChapter{2D Conforming Triangulations and Meshes\label{user_chapter_2D_Meshes}}

\ccChapterAuthor{Laurent Rineau}

\input{Mesh_2/PkgDescription}

\minitoc

This package implements Shewchuk's algorithm \cite{s-mgdsa-00} to construct
conforming triangulations and 2D meshes. Conforming triangulations will be
described in Section~\ref{sec:Mesh_2_conforming_triangulation} and
meshes in Section~\ref{sec:Mesh_2_meshes}.

\section{Conforming Triangulations\label{sec:Mesh_2_conforming_triangulation}}

\subsection{Definitions\label{sec:Mesh_2_conforming_definitions}}

A triangulation is a \emph{Delaunay triangulation} if the circumscribing
circle of any facet of the triangulation contains no vertex in its
interior. A \emph{constrained} Delaunay triangulation is a constrained
triangulation which is as much Delaunay as possible. The circumscribing
circle of any facet of a constrained Delaunay triangulation contains in its
interior no data point \emph{visible} from the facet.

An edge is said to be a \emph{Delaunay edge} if it is inscribed in an empty
circle (containing no data point in its interior). This edge is said to be a
\emph{Gabriel edge} if its diametrical circle is empty.

A constrained Delaunay triangulation is said to be a \emph{conforming
  Delaunay triangulation} if every constrained edge is a Delaunay edge.
Because any edge in a constrained Delaunay triangulation is either a
Delaunay edge or a constrained edge, a conforming Delaunay triangulation is
in fact a Delaunay triangulation. The only difference is that some of the
edges are marked as constrained edges.

A constrained Delaunay triangulation is said to be a \emph{conforming
  Gabriel triangulation} if every constrained edge is a Gabriel edge. The
Gabriel property is stronger than the Delaunay property and each Gabriel
edge is a Delaunay edge. Conforming Gabriel triangulations are thus also
conforming Delaunay triangulations.

Any constrained Delaunay triangulation can be refined into a
conforming Delaunay triangulation or into a conforming Gabriel
triangulation by adding vertices, called \emph{Steiner vertices}, on
constrained edges until they are decomposed into subconstraints small enough
to be Delaunay or Gabriel edges.

\subsection{Building Conforming Triangulations\label{sec:Mesh_2_building_conforming}}

Constrained Delaunay triangulations can be refined into
conforming triangulations 
by the two following global functions: \\
\ccc{template<class CDT> void make_conforming_Delaunay_2 (CDT& t)}~and\\
\ccc{template<class CDT> void make_conforming_Gabriel_2 (CDT& t)}. 

In both cases, the template parameter \ccc{CDT} must be instantiated
by a constrained Delaunay triangulation class.  Such a class must be a
model of the concept \ccc{ConstrainedDelaunayTriangulation_2}.

The geometric traits of the constrained
Delaunay triangulation used to instantiate the parameter \ccc{CDT} has to
be a model of the concept \ccc{ConformingDelaunayTriangulationTraits_2}.

The constrained Delaunay triangulation \ccc{t} is passed by reference
and is refined into a conforming Delaunay triangulation or into a
conforming Gabriel triangulation by adding vertices. The user is advised to
make a copy of the input triangulation in the case where the original
triangulation has to be preserved for other computations

The algorithm used by \ccc{make_conforming_Delaunay_2} and
\ccc{make_conforming_Gabriel_2} builds internal data structures that would be
computed twice if the two functions are called consecutively on the same
triangulation. In order to avoid these data to be constructed twice, the
advanced user can use the class \ccc{Triangulation_conformer_2<CDT>} to
refine a constrained Delaunay triangulation into a conforming Delaunay
triangulation and then into a conforming Gabriel triangulation. For
additional control of the refinement algorithm, this class also provides
separate functions to insert one Steiner point at a time.

\subsection{Example: Making a Triangulation Conforming Delaunay and Then
  Conforming Gabriel\label{sec:Mesh_2_example_making_conforming}}

This example inserts several segments into a constrained Delaunay
triangulation, makes it conforming Delaunay, and then conforming
Gabriel. At each step, the number of vertices of the triangulation is
printed.

\ccIncludeExampleCode{Mesh_2/conforming.cpp}

See figures~\ref{Conform-example-conform},
\ref{Conform-example-conform-Delaunay}
and~\ref{Conform-example-conform-Gabriel}.

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/example-conform}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./example-conform.png"
     align=middle title="Initial triangulation.">
\end{ccHtmlOnly}
\end{center}
\caption{Initial triangulation.}
\label{Conform-example-conform}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/example-conform-Delaunay}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./example-conform-Delaunay.png"
     align=middle title="The corresponding conforming Delaunay triangulation.">
\end{ccHtmlOnly}
\end{center}
\caption{The corresponding conforming Delaunay triangulation.}
\label{Conform-example-conform-Delaunay}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/example-conform-Gabriel}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./example-conform-Gabriel.png"
     align=middle title="The corresponding conforming Gabriel triangulation.">
\end{ccHtmlOnly}
\end{center}
\caption{The corresponding conforming Gabriel triangulation.}
\label{Conform-example-conform-Gabriel}
\end{figure}

\section{Meshes\label{sec:Mesh_2_meshes}}


\subsection{Definitions\label{sec:Mesh_2_meshes_definition}}

A mesh is a partition of a given region into simplices whose shapes
and sizes satisfy several criteria.

The domain is the region that the user wants to mesh. It has to be
  a bounded region of the plane. The domain is defined by a \emph{planar
  straight line graph}, {\sc Pslg} for short, which is a set of segments
  such that two segments in the set are either disjoint or share an
  endpoint. The segments of the {\sc Pslg} are constraints that will be
  represented by a union of edges in the mesh. The {\sc Pslg} can also
  contain isolated points that will appear as vertices of the mesh.

The segments of the {\sc Pslg} are either segments of the
boundary or internals constraints. The segments of the {\sc Pslg} have to
cover the boundary of the domain.

The {\sc Pslg} divides the plane into several connected components. By
default, the domain is the union of the bounded connected components. The
user can override this default by providing a set of seed points. Either
seed points mark components to be meshed or they mark components not to be
meshed (holes).

See figures~\ref{Domain} and~\ref{Domain-mesh} for an example of a domain
defined without using seed points, and a possible mesh of it. See
figure~\ref{Domain-seeds} for another domain defined with the same {\sc
  Pslg} and two seed points used to define holes. 
In the corresponding mesh (figure~\ref{Domain-seeds-mesh}), these
two holes are triangulated but not meshed.

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/domain}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./domain.png"
     align=middle title="A domain defined without seed points.">
\end{ccHtmlOnly}
\end{center}
\caption{A domain defined without seed points.}
\label{Domain}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/domain-mesh}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./domain-mesh.png"
     align=middle title="A mesh of the domain defined without seed points.">
\end{ccHtmlOnly}
\end{center}
\caption{A mesh of the domain defined without seed points.}
\label{Domain-mesh}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/domain-seeds}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./domain-seeds.png"
     align=middle title="A domain with two seeds points defining holes.">
\end{ccHtmlOnly}
\end{center}
\caption{A domain with two seeds points defining holes.}
\label{Domain-seeds}
\end{figure}

\begin{figure}[htbp]
\begin{center}
\begin{ccTexOnly}
\includegraphics[width=8cm]{Mesh_2/domain-seeds-mesh}
\end{ccTexOnly}
\begin{ccHtmlOnly}
<img border=0 src="./domain-seeds-mesh.png"
     align=middle title="A mesh of the domain with seeds defining holes.">
\end{ccHtmlOnly}
\end{center}
\caption{A mesh of the domain with two seeds defining holes.}
\label{Domain-seeds-mesh}
\end{figure}

\subsection{Shape and Size Criteria\label{sec:Mesh_2_criteria}}

The shape criterion for triangles is a lower bound $B$ on the ratio
between the circumradius and the shortest edge length.  Such a bound
implies a lower bound of $\arcsin{\frac{1}{2B}}$ on the minimum angle
of the triangle and an upper bound of $\pi - 2* \arcsin{\frac{1}{2B}}$
on the maximum angle.  Unfortunately, the termination of the algorithm
is guaranteed only if $B \ge \sqrt{2}$, which corresponds to a lower
bound of $20.7$~degrees over the angles.

The size criterion can be any criterion that tends to prefer small
triangles. For example, the size criterion can be an upper bound on the
length of longest edge of triangles, or an upper bound on the radius of the
circumcircle. The size bound can vary over the domain. For example,
the size criterion could impose a small size for the triangles intersecting
a given line.

Both types of criteria are defined in an object \ccc{criteria} passed as
parameter of the meshing functions.

\subsection{The Meshing Algorithm}

The input to a meshing problem is a {\sc Pslg} and a set of seeds
describing the domain to be meshed, and a set of size and shape
criteria.  The algorithm implemented in this package starts with a
constrained Delaunay triangulation of the input {\sc Pslg} and produces a
mesh using the Delaunay refinement method. This method inserts new vertices to
the triangulation, as far as possible from other vertices, and stops when the
criteria are satisfied.

If all angles between incident segments of the input {\sc Pslg}
are greater than $60$~degrees and if the bound on the
circumradius/edge ratio is greater than $\sqrt{2}$,
the algorithm is guaranteed to terminate with a mesh
satisfying the size and shape criteria.

If some input angles are smaller than $60$~degrees, the algorithm will
end up with a mesh in which some triangles violate the criteria near small
input angles. This is unavoidable since small angles formed
by input segments cannot be suppressed. Furthermore, it has been
shown (\cite{s-mgdsa-00}), that some domains with small input angles
cannot be meshed with angles even smaller than the small input angles.
Note that if the domain is a polygonal region, the resulting mesh will
satisfy size and shape criteria except for the small input angles.
In addition, the algorithm may succeed in producing meshes with a lower
angle bound greater than $20.7$~degrees, but there is no such guarantee.

\subsection{Building Meshes\label{sec:Mesh_2_building_meshes}}

Meshes are obtained from
constrained Delaunay triangulations by calling the global function \\
\ccc{template<class CDT, class Criteria> void refine_Delaunay_mesh_2 (CDT
  &t, const Criteria& criteria)}. \\
The template parameter \ccc{CDT} must be instantiated by a constrained
Delaunay triangulation class, which is a model of the concept
\ccc{ConstrainedDelaunayTriangulation_2}. In order to override the domain,
a version of this function has two more arguments that define a sequence of
seed points.

The geometric traits class of \ccc{CDT} has to be a
model of the concept \ccc{DelaunayMeshTraits_2}.  This concept
refines the concept \ccc{ConformingDelaunayTriangulationTraits_2}
adding the geometric predicates and constructors. The template parameter
\ccc{Criteria} must be a model of \ccc{MeshingCriteria_2}. This concept
defines criteria that the triangles have to satisfy.
\cgal\ provides two models for this concept:
\begin{itemize}
\item \ccc{Delaunay_mesh_criteria_2<CDT>}, that defines a shape criterion
  that bounds the minimum angle of triangles, 
\item \ccc{Delaunay_mesh_size_criteria_2<CDT>}, that adds to the previous
criterion a bound on the maximum edge length.
\end{itemize}

If the function \ccc{refine_Delaunay_mesh_2} is called several times on the
same triangulation with different criteria, the algorithm rebuilds the 
internal data structure used for meshing at every call. In order to avoid 
rebuild the data structure at every call, the advanced user can
use the class \ccc{Delaunay_mesher_2<CDT>}. This class provides also step
by step functions. Those functions insert one vertex at a time.

Any object of type \ccc{Delaunay_mesher_2<CDT>} is constructed from a
reference to a \ccc{CDT}, and has several member functions to define the
domain to be meshed and to mesh the \ccc{CDT}. See the example given below
and the reference manual for details. Note that the \ccc{CDT} should not be
externally modified during the life time of the \ccc{Delaunay_mesher_2<CDT>}
object.

Once the mesh is constructed, one can determine which faces of the
triangulation are in the mesh domain using the \ccc{is_in_domain()} member
function of the face type (see the concept \ccc{DelaunayMeshFaceBase_2}).

\subsection{Example Using the Global Function}

The following example inserts several segments into a constrained
triangulation and then meshes it using the global function
\ccc{refine_Delaunay_mesh_2}. The size and shape criteria are the default ones
provided by the criteria class \ccc{Delaunay_mesh_criteria_2<K>}. No seeds are
given, meaning that the mesh domain covers the whole plane except the
unbounded component.

\ccIncludeExampleCode{Mesh_2/mesh_global.cpp}

\subsection{Example Using the Class \texttt{Delaunay\_mesher\_2<CDT>}}

This example uses the class \ccc{Delaunay_mesher_2<CDT>} and calls
  the \ccc{refine_mesh()} member function twice, changing the size and
  shape criteria in between. In such a case, using twice the global
  function \ccc{refine_Delaunay_mesh_2} would be less efficient,
  because some internal structures needed by the algorithm would be
  built twice.

\ccIncludeExampleCode{Mesh_2/mesh_class.cpp}

\subsection{Example Using Seeds}

This example uses the global function \ccc{refine_Delaunay_mesh_2} but
defines a domain by using one seed. The size and shape criteria are the
default ones provided by the criteria class
\ccc{Delaunay_mesh_criteria_2<K>}.

Once the mesh is constructed, the \ccc{is_in_domain()} member function of
faces is used to count them.

\ccIncludeExampleCode{Mesh_2/mesh_with_seeds.cpp}

%%% For emacs/AucTeX:
%%% Local Variables: ***
%%% mode:latex ***
%%% TeX-master: "../Mesh_2.tex"  ***
%%% End: ***
