namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Isosurfacing3

\cgalAutoToc
\author Julian Stahl and Daniel Zint


[PA] : I recommend to select a more complex example (medical?), use a white background instead of default Meshlab one and superimpose the mesh edges in black.
\cgalFigureAnchor{isosurfacing_bunny_offset}
<center>
<img src="bunny_offset.gif" style="max-width:50%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_bunny_offset}
Isosurfacing with different isovalues for the bunny model.
\cgalFigureCaptionEnd

\section secmyintroduction Introduction

TODO: add a context and motivation: when do you need MC or dual contouring? what can represent the input scalar field ? illustrate this from eg density fields in medical imaging, or distance fields, etc.


TODO: stick to 'field' throughout the whole documentation, and leave the term 'function' for C++ function. This is valid for all terms: introduce them and do not interchange with others throughout the documentation.
TODO: Make sure you you clearly state that the input field is sampled.

This package provides isosurfacing algorithms that compute a surface mesh approximating an isosurface of a scalar field defined over an input 3D domain.
An isosurface is defined as the points of constant value of this scalar field, i.e. a level-set. Such a constant value, referred to as isovalue, is user-defined. For well-behaved scalar fields (e.g., non-zero gradient), the above level-set is a surface.
Depending on the isosurfacing method and the input data structure, the output is either a triangular, a quadrilateral, or a higher degree polygonal surface mesh represented as an indexed face set. The output may also be empty when the isosurface is absent from the sampled input scalar field.


\section secmyalgorithms Algorithms

There is a wide range of algorithms for extracting isosurfaces.
This package offers Marching Cubes, topologically correct Marching Cubes and Dual Contouring.

\subsection subsecmc Marching Cubes (MC)
MC runs over a 3D grid, i.e. a 3D domain partitioned into hexahedral cells, and processes all cells of the input domain individually while sampling the input scalar field at the grid corners.
Each cell corner is assigned a sign (+/-) to indicate if its field value is above or below the isovalue.
MC creates a vertex for each grid edge with a sign change, i.e. where the edge intersects the isosurface. More specifically, the vertex position is computed via linear interpolation of the scalar field values evaluated at the cell corners forming the edge. Depending on the configuration of signs at the cell corners, the resulting vertices are connected to form triangles within the cell. The figure below illustrates the configurations in 2D. [it would be better to show a subset of 3D cases, too, even if the figure is taken from a paper - it is probably possible to contact the authors and add a statement - figure courtesy from xxx]

\cgalFigureAnchor{isosurfacing_mc_cases}
<center>
<img src="mc_cases.png" style="max-width:70%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_mc_cases}
Different configurations of Marching Cubes in 2D.
\cgalFigureCaptionEnd


The proposed implementation is generic in that it can process any grid-based data structure that consists of hexahedral cells.
In case of a conforming grid, MC generates as output a surface triangle mesh that is 2-manifold in most scenarios. [TODO: reformulate, as it is either strict or not - precise in which cases it is not, and say whether you talk about just combinatorially 2-manifold, or truly 2-manifold with 3D embedding taken into account]
If the mesh is 2-manifold and the isosurface does not intersect the domain boundaries, then the output mesh is also watertight. [add a figure showing the two cases]
As MC only proceeds by linear interpolation of the sampled scalar field along the grid edges, it can miss details or components that are not captured by the said sampling and interpolation.

Compared to other approaches such as Delaunay refinement (TODO: add link to component), and depending on the parameters, the MC algorithm often generates more triangles, and triangles with small angles. [The statement is too strong - I would largely reformulate it as this depends too much on the parameters. I recommend to add instead a figure with different parameters and methods, depicting the mesh edges in black in addition to the shaded facets]
MC does not preserve the sharp features present in the isovalue of the input scalar field [add a figure].


\subsection subsectmc Topologically correct Marching Cubes (TMC)
This algorithm is an extension to MC and provides additional guarantees for the output \cgalCite{g-ctcmi-16}.
It generates as output a mesh that is homeomorphic to the trilinear interpolant of the input scalar field inside each cube.
This means that the output mesh can accurately represent small complex features.
For example, a tunnel of the isosurface within a single cell is topologically resolved.
Furthermore, the mesh is guaranteed to be 2-manifold and watertight, as long as the isosurface does not intersect the domain boundaries. [add a figure comparing without and with the option activated]

[TODO: add following to CGAL list of references]
Roberto Grosso: Construction of Topologically Correct and Manifold Isosurfaces. Computer Graphics Forum 35(5):187-196 - 2016.

\subsection subsecdc Dual Contouring (DC)
DC creates one vertex for each cell that is intersected by the isosurface.
Next, a face is created for each edge that intersects the isosurface, by connecting the vertices of the incident cells.
For a uniform hexahedral grid, this results into a quadrilateral surface mesh.

As the original DC method requires the gradient of the scalar field, the domain must implement the concept `IsosurfacingDomainWithGradient` in order to provide a gradient field in addition to a scalar field.
All default domain implementations also provide a gradient field, but assume the gradient to be null everywhere when it is not provided as an additional parameter.
Alternatively, some default gradient fields are provided such as `Finite_difference_gradient` and `Explicit_cartesian_grid_gradient`.

Variants of DC differ in the way they compute vertex positions.
The vertex positioning is thus configurable with an optional parameter passed to the DC algorithm.
Some variants do not require the gradient and therefore run successfully even when the default null gradient is provided.

Dual Contouring can deal with any domain but guarantees neither a 2-manifold nor a watertight mesh.
It generates fewer faces than Marching Cubes, in general.
Its advantage over MC is its ability to recover sharp creases. [what about tips, darts, cusps and corners? respectively adjacent to 0, 1, 2 and 3+ creases] TODO: add a figure.

\cgalFigureAnchor{isosurfacing_iwp_dc}
<center>
<img src="iwp_dc.png" style="max-width:40%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_iwp_dc}
Isosurface of the IWP scalar field generated by Dual Contouring. [TODO: do not assume that the iwp scalar field is well known to the reader - explicit first what it means. in addition, the shape is too complex, adding confusion to the reader. try to pass only one message per figure and provide a caption to not let the reader guess. show mesh edges in black]
\cgalFigureCaptionEnd

\subsection subseccomparison Comparisons

The following table compares the algorithms in terms of constraints over the input 3D domain, the facets of the output surface mesh, and the 2-manifold property of the output surface mesh.

|  Algorithm        | Domains    | Facets       | 2-Manifold  | Watertight*   | Topologically correct |
| ----              | ----       | ----        | ----      | ----          | ----                  |
  MC                | Hexahedral | Triangles   | no        | no            | no                    |
  TMC               | Hexahedral | Triangles   | yes       | yes           | yes                   |
  DC                | All        | Polygons    | no        | no            | no                    |

(* assuming the isosurface does not leave the specified bounding box of the input 3D domain)

\cgalFigureAnchor{isosurfacing_compare_mc_dc}
<center>
<img src="cube_mc_dc.png" style="max-width:70%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_compare_mc_dc}
Comparison between a cube generated by Dual Contouring (left) or by Marching Cubes (right).
\cgalFigureCaptionEnd


\section secmyinterface Interface

Each algorithm can be called by a single templated function, and the function signature is common to all algorithms:

\code{.cpp}
template <typename Concurrency_tag = Sequential_tag, class Domain_, class PointRange, class PolygonRange>
void marching_cubes(const Domain_& domain, const typename Domain_::FT isovalue, PointRange& points, PolygonRange& polygons);
\endcode

The input is provided in the form of a `domain` (see \ref secmydomains).

The `isovalue` scalar parameter denotes the value used for sampling the input scalar field for generating the isosurface.

[why using the term collection below ? how about containers? ]

The output surface mesh is provided in the form of an indexed face set,  which is written to the two collections `points` and `polygons`.
The vertex positions are stored as `Point_3` in `points`. Each face in `polygons` is a list of indices pointing into the `points` collection.
Depending on the algorithm, the indexed face set may store either a polygon soup or a mesh with connectivity.

The isosurfacing algorithms can run either sequentially on one CPU core or in parallel on multicore architectures with shared memory.
The Concurrency_tag is used to specify how the algorithm is executed: either Sequential_tag or Parallel_tag.
To enable parallelism, CGAL must be linked with the Intel TBB library.
When the parallel version is not available due to unsuccessful link with the TBB library, then the sequential version is utilized as a fallback.


\section secmydomains Domains
A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient. [I fail to understand how you specify the topology - for me the domain is the support of the scalar field, whose sampling/interpolation will yield the output mesh topology]
For common representations, we offer a set of predefined domain classes that wrap the input data and provide a generalized interface for the algorithm.
Users can also define new domains by implementing the `Isosurfacing_domain` or `IsosurfacingDomainWithGradient` concept.

\subsection mysubsecimplicitdomain Implicit cartesian grid domain
The `Implicit_cartesian_grid_domain` represents the input scalar field in an implicit form without storing any values.
It takes a function-object (functor) or lambda function that computes the value of the scalar field from the position of a vertex query.
Additionally, the bounding box and spacing between the grid points must be provided.

\subsection mysubseccartesiandomain Explicit cartesian grid domain
The `Explicit_cartesian_grid_domain` only takes a `Cartesian_grid_3` as parameter.
It represents a uniform grid of scalar field values that are either computed by the user or read from an `Image_3`.
The constructor of `Cartesian_grid_3` requires the number of grid points in each dimension (x, y, z) and the bounding box.
The field values are read and written with `value(x, y, z)` where x, y, and z denote the coordinates of a grid point.
Alternatively, all required data can be copied from an `Image_3`.


\section secmybenchmarks Performance

\cgalFigureAnchor{isosurfacing_perf_iwp_mc}
<center>
<img src="perf_threads_iwp_mc.svg" style="max-width:70%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_perf_iwp_mc}
Scalability of the Marching Cubes algorithm. We plot the algorithm efficiency (number of thousand-cubes per second) against the number of CPU cores.
\cgalFigureCaptionEnd


\section secmyexamples Examples

\subsection myExampleImplicit_domain Implicit sphere

The following example shows the usage of the Marching Cubes algorithm to extract an isosurface.
The domain is an `Implicit_domain` that describes the unit sphere by the distance to its center (set to the origin) as an implicit function.

\cgalExample{Isosurfacing_3/marching_cubes_implicit_sphere.cpp}

\subsection myExampleAll_cube Cartesian_grid_3 cube comparison

The following example runs all provided algorithms to extract an isosurface. The input 3D domain is a `Cartesian_grid_domain` that describes a cube by storing the Manhattan distance to its origin in a `Cartesian_grid_3`.

\cgalExample{Isosurfacing_3/all_cartesian_cube.cpp}

\subsection myExampleImage Image_3

The following example shows how to load data from an `Image_3`.

\cgalExample{Isosurfacing_3/marching_cubes_inrimage.cpp}

\subsection myExampleMeshOffset Offset mesh

The following example shows how to compute a signed offset mesh.
The input mesh is stored into an `AABB_tree` data structure to allow fast distance queries. Via the `Side_of_triangle_mesh` functor, the sign of the distance function is made negative inside the mesh.

\cgalExample{Isosurfacing_3/dual_contouring_mesh_offset.cpp}

*/
} /* namespace CGAL */
