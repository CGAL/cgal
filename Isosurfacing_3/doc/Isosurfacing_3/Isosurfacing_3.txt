namespace CGAL {
/*!

\mainpage User Manual
\anchor Chapter_Isosurfacing3

\cgalAutoToc
\author Julian Stahl and Daniel Zint

\cgalFigureAnchor{isosurfacing_bunny_offset}
<center>
<img src="bunny_offset.gif" style="max-width:50%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_bunny_offset}
Different isovalues of a bunny.
\cgalFigureCaptionEnd

\section secmyintroduction Introduction

This package provides functions to compute a surface mesh representing an isosurface.
The data structure from which an isosurface is extracted is a 3-dimensional scalar function.
An isosurface is defined as the surface on which the value of this function is equal to a given constant, i.e. the isovalue.
The isosurface is stored as a triangular or quadrilateral indexed face set.

\section secmyalgorithms Algorithms

There are multiple algorithms to extract isosurfaces.
This package contains Marching Cubes, topologically correct Marching Cubes, Dual Contouring and Octree Marching. (References?)

\subsection subsecmc Marching Cubes
The Marching Cubes algorithm processes all cells of the input domain individually.
Each cell corner gets a sign (+/-) to indicate if it is above or below the isovalue.
A new vertex is created on every cell edge where the sign changes, i.e. the isosurface is intersected.
The vertex position is computed via linear interpolation of the scalar values of the incident corners.
Depending on the configuration of signs at the corners the resulting vertices are connected to form triangles within the cell.

Marching Cubes is an old algorithm that is fast but approximate. It can be run on any domain that has cubical cells.
The algorithm creates a manifold triangle mesh if the domain is a regular grid.
This guarantees that every edge is incident to at most two faces and every vertex is surrounded by one triangle fan.
As long as the isosurface does not intersect the domains boundaries the resulting mesh is also watertight.
If the input domain contains multiple isosurfaces with the same value that are not connected Marching Cubes will also generate multiple meshes.
Compared to other approaches the algorithm often generates more triangles and many thin or acute triangles.
Sharp edges are not well preserved in a mesh generated with Marching Cubes.

\cgalFigureAnchor{isosurfacing_mc_cases}
<center>
<img src="mc_cases.png" style="max-width:70%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_mc_cases}
Some example cases of Marching Cubes.
\cgalFigureCaptionEnd

\subsection subsectmc Topologically correct Marching Cubes
This algorithm is an extension to Marching Cubes that provides additional guarantees.
It generates a mesh that is homeomorph to the trilinear interpolant of the input function inside each cube. ...

TODO examples

\subsection subsecdc Dual Contouring
The Dual Contouring algorithm first iterates over all cells. If a cell intersects the isosurface a vertex inside this cell is created.
Then it checks for each edge if it intersects the isosurface. If that is the case the vertices of all incident cells are connects to form a face.

This algorithm needs a functor that returns the gradient of the input function as an additional parameter.
The default argument for this parameter assumes the gradient to be zero.
The placement of a vertex position inside a cell is also configurable with an optional parameter.
Different placement methods are available, some of which require the gradient to be non-zero.

Dual Contouring works on any domain but does not guarantee a manifold or watertight mesh.
It creates less faces than Marching Cubes.
The algorithms can represent sharp edges better than Marching Cubes.

\cgalFigureAnchor{isosurfacing_iwp_dc}
<center>
<img src="iwp_dc.png" style="max-width:40%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_iwp_dc}
Isosurface of the IWP function generated by Dual Contouring.
\cgalFigureCaptionEnd

\subsection subseccomparison Comparison

|  Algorithm        | Domains | Faces       | Manifold  | Watertight*   | Topologically correct |
| ----              | ----    | ----        | ----      | ----          | ----                  |
  Marching Cubes    | Cubical | Triangles   | yes       | yes           | no                    |
  TMC               | Cubical | Triangles   | yes       | yes           | yes                   |
  Dual Contouring   | All     | Polygons    | no        | no            | no                    |

(* assuming the isosurface does not leave the given bounding box)

\cgalFigureAnchor{isosurfacing_compare_mc_dc}
<center>
<img src="cube_mc_dc.png" style="max-width:70%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_compare_mc_dc}
Comparison between a cube generated by Dual Contouring (left) and Marching Cubes (right).
\cgalFigureCaptionEnd


\section secmyinterface Interface

Each algorithm is represented by a single functions. The function signature is the same for each algorithm (except for some additional parameters for some of them):

\code{.cpp}
template <typename Concurrency_tag = Sequential_tag, class Domain_, class PointRange, class PolygonRange>
void make_triangle_mesh_using_marching_cubes(const Domain_& domain, const typename Domain_::FT iso_value,
                                             PointRange& points, PolygonRange& polygons);
\endcode

The input is provided in the form of a `domain` (see \ref secmydomains).

The `iso_value` parameter describes the grid value the isosurface should represent.

The output is in the form of an indexed face set that is written to the two collections `points` and `polygons`.
The vertex positions are stored as `Point_3` in `points`. Each face in `polygons` is a list of indices pointing into the `points` collection.
Depending on the algorithm, the indexed face set may either store a polygon soup or a topological mesh.

Algorithms can run sequentially on one CPU core or in parallel.
The Concurrency_tag is used to specify how the algorithm is executed and is either Sequential_tag or Parallel_tag.
To enable parallelism, CGAL needs to be linked with the Intel TBB library.
If the parallel version is not availible the sequential version will always be used as a fallback.


\section secmydomains Domains

A domain is an object that provides functions to access the input data, its geometry, topology, and optionally its gradient.
There are some predefined domain classes that wrap the input data and provide a generalized interface for the algorithm.
Users can also define new domains by implementing the `Isosurfacing_domain` concept.

\subsection mysubsecimplicitdomain Implicit domain
The `Implicit_domain` represents the input function in an implicit form without storing any values.
It takes a functor or lambda that computes the value of the function from the position of a vertex as parameter.
Additionally, the bounding box and spacing between grid points have to be specified.

\subsection mysubseccartesiandomain Cartesian grid domain
The `Cartesian_grid_domain` only takes a `Cartesian_grid_3` as parameter.
It represents a uniform grid of values that are either computed by the user or read from an `Image_3`.
The constructor of `Cartesian_grid_3` needs the number of grid points in each dimension and the bounding box.
The values are read and written with `value(x, y, z)` where x, y, and z are the coordinates of a grid point.
Alternatively, all required data can be copied from an `Image_3`.

\subsection mysubsecoctreedomain Octree domain
The `Octree_domain` wraps an octree to be used by isosurfacing algorithms.
The octree has to be already refined. ...


\section secmybenchmarks Performance

\cgalFigureAnchor{isosurfacing_perf_iwp_mc}
<center>
<img src="perf_threads_iwp_mc.svg" style="max-width:70%;"/>
</center>
\cgalFigureCaptionBegin{isosurfacing_perf_iwp_mc}
Scaling of Marching Cubes with more threads.
\cgalFigureCaptionEnd


\section secmyexamples Examples

\subsection myExampleImplicit_domain Implicit sphere

The following example shows the use of the marching cubes algorithm to extract an isosurface.
The domain is an `Implicit_domain` that describes a sphere by the distance to its origin as an implicit function.

\cgalExample{Isosurfacing_3/marching_cubes_implicit_sphere.cpp}

\subsection myExampleAll_cube Cartesian_grid_3 cube comparison

The following example compares all provided algorithms to extract an isosurface.
The domain is an `Cartesian_grid_domain` that describes a cube by storing the manhattan distance to its origin in a `Cartesian_grid_3`.

\cgalExample{Isosurfacing_3/all_cartesian_cube.cpp}

\subsection myExampleImage Image_3

The following example shows how to load data from an `Image_3`.

\cgalExample{Isosurfacing_3/marching_cubes_inrimage.cpp}

\subsection myExampleMeshOffset Offset mesh

The following example shows how to compute an offset mesh.
The original mesh is passed to an `AABB_tree` to allow fast distance queries.
With the use of `Side_of_triangle_mesh` the sign of the distance function is flipped inside the mesh.

\cgalExample{Isosurfacing_3/marching_cubes_mesh_offset.cpp}

\subsection myExampleOctree Octree Dual Contouring

The following example shows how to extract an isosurface from an octree using Dual Contouring.
The domain is an `Octree_domain` that describes a sphere by the distance to its origin stored in an octree.
The octree is highly refined in one octant and only coarse in the others.

\cgalExample{Isosurfacing_3/dual_contouring_octree.cpp}

*/
} /* namespace CGAL */
