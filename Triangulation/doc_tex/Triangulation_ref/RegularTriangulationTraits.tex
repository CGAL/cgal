
\begin{ccRefConcept}{RegularComplexTraits}

\ccDefinition

The concept \ccRefName\ describes the various types and functions that a class
has to provide as the first parameter (\ccc{RCTraits}) to the class template
\ccc{Regular_complex<DCTraits, PCDS>}. It brings the geometric ingredient to
the definition of a Regular complex, while the combinatorial ingredient is
brought by the second template parameter, \ccc{PCDS}.

\ccRefines

\ccc{PureComplexTraits}.

\ccTypes

\ccNestedType{Weighted_point_d}{A type representing a point in Euclidean
space with an associated weight (in $\real$).}

\ccNestedType{Side_of_oriented_orthogonal_sphere_d}{A predicate object that
must provide the templated operator\\\ccc{template<typename ForwardIterator>
Oriented_side operator()(ForwardIterator start, ForwardIterator end, const
Weighted_point_d & p)}.\\The operator returns \ccc{ON_POSITIVE_SIDE} if the
query point \ccc{p} lies in the positive side of the sphere \ccc{S} orthogonal
to the weighted points in the range \ccc{[start,end)}. It returns
\ccc{ON_NEGATIVE_SIDE} if the point \ccc{p} lies on the negative side of the
sphere \ccc{S}. It returns \ccc{ON_ORIENTED_BOUNDARY} if the point \ccc{p}
lies on the sphere \ccc{S}. If the simplex \ccc{[start,end)} is positively
oriented, then the positive side of sphere \ccc{S} corresponds geometrically
to the bounded side of \ccc{S} and the negative side corresponds to the
unbounded side of \ccc{S}. If the simplex is negatively oriented, the
correspondance is inverted. \\ The range's size must of course be one more
than the dimension of the Euclidean space the points live in: \ccPrecond
\ccc{std::distance(start,end)==start->dimension()+1}. The points in range
\ccc{[start,end)} must be affinely independent, {i.e.,} the simplex must
not be flat.}

\ccNestedType{Side_of_oriented_orthogonal_subphere_d}{A predicate object that
must provide the templated operator\\\ccc{template<typename ForwardIterator>
Oriented_side operator()(ForwardIterator start, ForwardIterator end, const
Point_d & p)}.\\ Let Aff be the affine subspace spanned by the points in range
\ccc{[start,end)}. The operator behaves in the same way as the above predicate
\ccc{Side_of_oriented_orthogonal_sphere_d}, but operates in the affine
subspace Aff. It is guaranteed that the affine subspace Aff is given a
consistent orientation when it is called many times with simplex points (in
range \ccc{[start,end)}) living in a same affine subspace.\\
\textbf{Important.} Information about the affine subspace Aff is computed
\textbf{once} and then stored in the predicate class, so it is wise to keep an
instance of the predicate around as long as one is sure that the affine
subspace Aff doesn't change. \ccPrecond \ccc{std::distance(start,end)>=3} and
\ccc{std::distance(start,end)<=start->dimension()+1}. The points in range
\ccc{[start,end)} must be affinely independent in Aff, {i.e.,} the
simplex must not be flat in Aff.}

\ccCreation
\ccCreationVariable{traits}

\ccConstructor{RegularComplexTraits();}{The default constructor.}

\ccOperations

The following methods permit access to the traits class's predicates:

\ccMethod{Side_of_oriented_orthogonal_sphere_d
side_of_oriented_sphere_d_object() const;}
{}
\ccGlue
\ccMethod{Side_of_oriented_orthogonal_subphere_d
side_of_oriented_subphere_d_object() const;}
{}

\ccHasModels

\ccc{Cartesian_d<FT, Dim, LA>},\\
\ccc{Simple_cartesian_d<FT, Dim, LA>},\\
\ccc{Filtered_kernel_d<K>} (recommended).

\ccSeeAlso

\ccc{PureComplexTraits}

\end{ccRefConcept}
