\begin{ccRefClass}{Delaunay_triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>}

\ccDefinition

The class \ccRefName\ is used to maintain the full cells and vertices of a
Delaunay triangulation in $\real^D$. It permits point insertion and
removal. The dimension $D$ should be kept reasonably small,
see the performances section in the user manual for what reasonable
means.
%: higher than 7 or 8, 
%you are entering a realm where patience is a highly useful virtue.

\ccInclude{CGAL/Delaunay_triangulation.h}

\ccParameters

\ccc{DelaunayTriangulationTraits} is the geometric traits class that provides the geometric types
and predicates needed by Delaunay triangulations. \ccc{DelaunayTriangulationTraits} must be a model of
the concept \ccc{DelaunayTriangulationTraits}.

\ccc{TriangulationDataStructure} is the class used to store the underlying triangulation data
structure. \ccc{TriangulationDataStructure} must be a model of the concept
\ccc{TriangulationDataStructure}. The class template \ccRefName\ accepts that no
second parameter be specified. It also accepts the tag \ccc{CGAL::Default} as
second parameter. In both cases, \ccc{TriangulationDataStructure} defaults to
\ccc{Triangulation_data_structure<
                    Ambient_dimension<DelaunayTriangulationTraits::Point_d>::type,
                    Triangulation_vertex<DelaunayTriangulationTraits>,
                    Triangulation_full_cell<DelaunayTriangulationTraits> >}.


\ccInheritsFrom
\ccc{Triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>}.

The class \ccc{Delaunay_triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>} inherits all the types
defined in the base class \ccc{Triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>}. Additionally, it
defines or overloads the following methods:

\ccCreation % - - - - - - - - - - - - - - - - - - - - - - - - - - - CREATION
\ccCreationVariable{dt}


\ccConstructor{Delaunay_triangulation(const int dim, const Geom_traits k =
Geom_traits());}{Instantiates a Delaunay triangulation with one vertex (the vertex
at infinity). See the description of the inherited nested type
\ccc{Triangulation<DelaunayTriangulationTraits, TriangulationDataStructure>::Ambient_dimension} for an explanation of
the use of the parameter \ccc{dim}. The complex stores a copy of the geometric
traits \ccc{k}.}


\ccHeading{Point removal} % - - - - - - - - - - - - - - - - - - - - - REMOVAL

\ccMethod{Full_cell_handle remove(Vertex_handle v);}{Remove the vertex \ccc{v}
from the Delaunay triangulation. If the current dimension of the triangulation has not
changed after the removal, then the returned full cell \ccc{c} geometrically
contains the removed vertex \ccc{v} (\ccc{c} can be finite or infinite).
Otherwise, the default-constructed \ccc{Full_cell_handle} is returned.
\ccPrecond \ccc{v} is a vertex of the triangulation, different from the
\ccc{infinite_vertex()}.}

% \ccMethod{Full_cell_handle remove(const Point & p);}{Locate the point \ccc{p} in
% the Delaunay triangulation. If a vertex is found at position \ccc{p}, it is removed
% from it, otherwise, the default-constructed \ccc{Full_cell_handle} is returned.
% If \ccc{p} is found and if the current dimension of the complex has not
% changed after the removal, then the returned full cell \ccc{c} geometrically
% contains the removed point \ccc{p} (\ccc{c} can be finite or infinite).
% Otherwise, the default-constructed \ccc{Full_cell_handle} is returned.}

% \ccMethod{Full_cell_handle remove(const Point & p, Full_cell_handle hint);}{Same
% as above, but uses \ccc{hint} as a starting point for locating the point
% \ccc{p} in the complex.}

\ccMethod{template< typename ForwardIterator > size_type remove(ForwardIterator
start, ForwardIterator end);}{Remove the points or the vertices (through their
\ccc{Vertex_handle}) in the range \ccc{[start, end)}. Returns the number of
elements actually removed.}


\ccHeading{Point insertion} % - - - - - - - - - - - - - - - - - - - INSERTION

\ccMethod{template< typename ForwardIterator >
size_type insert(ForwardIterator s, ForwardIterator e);}%
{Inserts the points found in range \ccc{[s,e)} in the Delaunay triangulation
and ensures that the empty-ball property is preserved.
Returns the number of vertices actually inserted. (If more than one vertex share
the same position in space, only one insertion is counted.)}

\ccMethod{Vertex_handle insert(const Point & p, const Full_cell_handle hint
= Full_cell_handle());}{Inserts point \ccc{p} in the Delaunay triangulation
and ensures that the empty-ball property is preserved. Returns a
\ccc{Vertex_handle} to the vertex of the triangulation with position \ccc{p}.
Prior to the actual insertion, \ccc{p} is located in the triangulation;
\ccc{hint} is used as a starting place for locating \ccc{p}.}

\ccMethod{Vertex_handle insert(const Point & p, const Vertex_handle hint);}%
{Same as above but uses a vertex as starting place for the search.}

\begin{ccAdvanced}

\ccMethod{Vertex_handle insert(const Point & p, const Locate_type lt,
const Face & f, const Facet & ft, const Full_cell_handle c);}
{Inserts the point \ccc{p} in the Delaunay triangulation
and ensures that the empty-ball property is preserved.
Returns a handle to the
(possibly newly created) vertex at that position. The behavior depends on the
value of \ccc{lt}:\begin{itemize} \item[\ccc{OUTSIDE_AFFINE_HULL}] Point
\ccc{p} is inserted so as to increase the current dimension of the Delaunay
triangulation. The method \ccVar.\ccc{insert_outside_affine_hull()} is called.
\item[\ccc{ON_VERTEX}] The position of the vertex \ccc{v} described by \ccc{f}
is set to \ccc{p}. \ccc{v} is returned. \item[Anything else] The point \ccc{p}
is inserted in the conflict zone {\em which is assumed} to contain 
full cell
\ccc{c}. (Roughly speaking, the method \ccVar.\ccc{insert_in_conflict_zone()}
is called.)\end{itemize} \ccPrecond The parameters \ccc{lt}, \ccc{f}, \ccc{ft}
and \ccc{c} must be consistent with the localization of point \ccc{p} in the
Delaunay triangulation.}

\ccMethod{Vertex_handle insert_outside_affine_hull(const Point & p);}
{Inserts the point \ccc{p} in the Delaunay triangulation. Returns a handle to the
(possibly newly created) vertex at that position. \ccPrecond The point \ccc{p}
must lie outside the affine hull of the Delaunay triangulation. This implies that
\ccVar.\ccc{current_dimension()} must be less that
\ccVar.\ccc{ambient_dimension()}.}

\ccMethod{Vertex_handle insert_in_conflict_zone(const Point & p, const
Full_cell_handle c);}
{Inserts the point \ccc{p} in the Delaunay triangulation. Returns a handle to the
(possibly newly created) vertex at that position.\ccPrecond The point \ccc{p}
must be in conflict with the full cell \ccc{c}.}

\end{ccAdvanced}

\ccHeading{Queries} % - - - - - - - - - - - - - - - - - - - - - - - - QUERIES

\ccMethod{bool conflict(const Point & p, Full_cell_const_handle c)
const;}{Returns \ccc{true} if and only if the point \ccc{p} is in (Delaunay)
conflict with full cell \ccc{c} ({i.e.}, the circumscribing ball of
$c$ contains $p$ in its interior).
}

\begin{ccAdvanced}

\ccMethod{Facet compute_conflict_zone(const Point & p, const Full_cell_handle c,
OutputIterator out) const;}{Outputs handles to the full cells in confict with
point \ccc{p} into the \ccc{OutputIterator out}. The full cell \ccc{c} is used
as a starting point for gathering the full cells in conflict with \ccc{p}. 
\ccPrecond \ccc{c} is in conflict
with \ccc{p}.\\ \ccVar.\ccc{current_dimension()}$\geq 2$.
}

\end{ccAdvanced}

\end{ccRefClass}
