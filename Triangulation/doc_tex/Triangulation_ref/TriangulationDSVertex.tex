\begin{ccRefConcept}{TriangulationDSVertex}

\ccDefinition

The concept \ccRefName\ describes what a vertex is in a model of the concept
\ccc{TriangulationDataStructure}. It sets requirements of combinatorial nature
only, as geometry is not concerned here. In particular, we only require that
the vertex holds a handle to a full cell incident to it in the triangulation.



\ccHasModels

\ccc{CGAL::Triangulation_ds_vertex<TriangulationDataStructure>}\\
\ccc{CGAL::Triangulation_vertex<TriangulationTraits, Data, TriangulationDSVertex>}

\ccTypes
\ccThree{Full_cell_handle}{v. set_full_cell(Full_cell_handle c);}{}
\ccThreeToTwo

\ccNestedType{Full_cell_handle}{A handle to a cell. It must be the same as the
nested type \ccc{TriangulationDataStructure::Full_cell_handle} of the \ccc{TriangulationDataStructure} in which the
\ccc{TriangulationDSVertex} is defined/used.}

\ccNestedType{
  template <typename TDS2>
  Rebind_TDS}
{This nested template class has to define a type \ccc{Other} which is the
{\it rebound} vertex, that is, the one whose \ccc{Triangulation_data_structure}
will be the actually used one.  The \ccc{Other} type will be the real base
class of \ccc{Triangulation_data_structure::Vertex}.}


\ccCreation	
\ccCreationVariable{v}

\ccConstructor{TriangulationDSVertex();}{The default constructor (no incident
full cell is set).}
\ccGlue
\ccConstructor{TriangulationDSVertex(Full_cell_handle c);}{Sets the incident
full cell to \ccc{c}. \ccPrecond \ccc{c} must not be the default-constructed
\ccc{Full_cell_handle}.}

\ccOperations
\ccThree{Full_cell_handle}{v. set_full_cell(Full_cell_handle c);}{}

\ccMethod{void set_full_cell(Full_cell_handle c);}{Set \ccc{c} as the vertex's
incident full cell. \ccPrecond \ccc{c} must not be the default-constructed
\ccc{Full_cell_handle}.}

\ccMethod{Full_cell_handle full_cell() const;}{Returns a handle to a
  full cell incident to the vertex.}

\begin{ccDebug}
\ccHeading{Validity check}

\ccMethod{bool is_valid(bool verbose=false) const;}{Performs any
desired test on a vertex. Should check if the incident full cell
actually contains the vertex.
}
\end{ccDebug}

% \ccHeading{Memory management}

% \ccMethod{void*   for_compact_container() const;}{}
% \ccGlue\ccMethod{void* & for_compact_container();}{}

% These member functions are required by the classes
% \ccc{Triangulation_data_structure<Dimensionality, TriangulationDSVertex, TriangulationDSFullCell>} and
% \ccc{Triangulation<TriangulationTraits, TriangulationDataStructure>} (and its derived classes) because they use
% the \cgal\ container class \ccc{Compact_container} to store their vertices and
% full cells. See the documentation of \ccc{Compact_container} for the exact
% requirements.

\ccHeading{Memory management}

\ccMethod{void * for_compact_container() const;}{}
\ccGlue
\ccMethod{void * & for_compact_container();}{}
{ These member functions are required by \ccc{Triangulation_data_structure}
  because it uses \ccc{Compact_container} to store its cells.  See the
  documentation of \ccc{Compact_container} for the exact requirements.}

\ccHeading{Input/Output}

These operators can be used directly and are called by the I/O
operator of class \ccc{TriangulationDataStructure}.

\ccFunction{template<class TriangulationDataStructure> istream& operator>>(istream & is,
        Triangulation_ds_vertex<TriangulationDataStructure> & v);}
{Reads (possibly) non-combinatorial information about a vertex from the stream \ccc{is}
into \ccc{v}.}

\ccFunction{template<class TriangulationDataStructure> ostream& operator<<(ostream & os, const
        Triangulation_ds_vertex<TriangulationDataStructure> & v);}
{Writes (possibly) non-combinatorial information about vertex \ccc{v} to the stream
    \ccc{os}.}

\ccSeeAlso

\ccc{TriangulationDSFullCell}\\
\ccc{TriangulationDSFace}\\
\ccc{TriangulationDataStructure}\\
\ccc{Triangulation}

\end{ccRefConcept}
