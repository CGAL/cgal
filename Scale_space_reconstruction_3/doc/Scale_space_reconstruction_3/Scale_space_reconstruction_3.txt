namespace CGAL {
/*!

\mainpage User Manual 
\anchor Chapter_Scale_space_reconstruction
\anchor chapterScaleSpaceReconstruction3
\cgalAutoToc

\authors Thijs van Lankveld


This %CGAL package implements a surface reconstruction method which takes as input an unordered point set and computes a triangulated surface mesh interpolating the point set. We assume that the input points were sampled from the surface of an object. The method can also process point sets sampled from the interior of the object, although we cannot provide guarantees on the output. This method can handle a decent amount of noise and outliers. The point set may greatly undersample the object in occluded regions, although no surface will be reconstructed to fill these regions.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figIntro, knot2_pts_surf.png}
Left: 5760 points on an synthetic knot data set. Right: reconstructed surface mesh.
\cgalFigureEnd

A triangulated surface mesh is generated by first constructing a coarse scale-space of the point set, then constructing a mesh on this scale-space, and finally transporting the mesh back to the original scale.


\section ScaleSpaceReconstruction3secMethod Scale-space

The problem of surface reconstruction from a point sample is ill-defined. Because the points only provide a sample of the surface, we cannot determine with exact certainty how the surface behaves between the points. We may get more information about the surface by sampling the surface further, but even then the problem remains at a smaller scale.

Given real-world data sets we also have to contend with noise and outliers, small errors in the point location and points that do not sample the surface respectively. These are generally caused by faults in the measurement procedure. Unless we actually know the surface sampled, we cannot determine whether a distinctive point is an outlier, is caused by noise, or samples a detail of the surface.

To overcome these obstacles, we use a scale-space \cgalCite{cgal:dmsl-ssmrp-11}, which models geometry at different scales. For this purpose, a \em scale is an abstraction level of the geometry. At a smaller, finer scale the geometry contains more details. Conversely at a larger, coarser scale the geometry contains less details. The \em scale-space is a model of the geometry at a dynamic scale. We refer to changing to a coarser scale as <em>advancing the scale-space</em>. In case of a point set, less detailed geometry means the points are closer to a smooth surface or this surface is closer to planar.

The scale-space surface reconstruction method is twofold. Firstly, a scale-space of the point set is constructed. Then, a triangulated surface mesh of the points in the scale-space is computed. Neighboring triangles in the mesh have consistent orientation, as expressed using the '<em>right-hand rule</em>' on the ordered vertices of the triangle.

The points maintain their original order in the scale-space. This means it is straightforward to revert the scale-space on the triangulated surface mesh. In essence, the method can reconstruct a smooted surface or a surface interpolating the original points. The only change is whether to apply the index triples to the scale-space or to the original point set.

When applied to the scale-space, the surface mesh is non-self-intersecting. The interior of the triangles cannot pairwise intersect in a line segment. However, the surface does not need to be manifold. An edge may be incident to more than two triangles and triangles may overlap exactly if the regions on both sides of the triangle are not part of the object. Note that we count overlapping triangles with opposite orientations as separate triangles. In many cases where the points sample the surface of an object, the computed surface will contain both an '<em>outward-facing</em>' and a similar '<em>inward-facing</em>' surface, with a thin volume between them.

The surface mesh will not have edges incident to only one triangle or holes, loops of such edges, and the triangles are all oriented towards the outside of the object sampled. If the point sample has '<em>holes</em>', it is likely that the surface mesh will contain overlapping triangles with opposite orientation touching this hole.

If the object is not densely sampled or has disconnected components, the surface may have several disconnected components. The surface may be presented as an unordered collection of triangles, or as a collection sorted per \em shell. A shell is a collection of connected triangles that are locally oriented towards the same side of the surface.

When applied to the original points, we are unable to guarantee the same topology of the surface. The triangles of this surface may pairwise intersect in their interior and the surface could have boundary edges. However, when using appropriate parameter settings for the number of iterations and neighborhood size the surface will generally not self-intersect. The appropriate parameter settings depend on the geometry of the point set and generally need to be fine-tuned per data set, as described later.

Both the smoothing operator and the mesh reconstruction assume that points near each other belong to the same part of the object. This is expressed in the notion of balls with a fixed size, the neighborhood radius. If such a ball contains multiple points, these points are near each other and will influence each other while advancing the scale-space. If such a ball is empty, it lies outside the object. Note that \em outside is based on regions empty of points, not on whether a volume is enclosed by the surface.

The initial scale-space is equivalent to the input point set. The scale-space is advanced by by projecting each point to the '<em>density</em>'-weighted principal component analysis (PCA) of the local, \em \f$\delta\f$-distance, neighborhood. If the point set was sampled from a surface for which any high-frequency deformation and sampling noise is smaller than the neighborhood size, the scale is coarse enough for mesh reconstruction after a few iterations of advancing the scale-space.

The result is returned as a collection of triples on the indices of the points of the surface triangles. This collection may be sorted per \em shell, where a shell is a collection of connected triangles that are locally oriented towards the same side of the surface.

The reconstruction method requires a user-specified neighborhood size parameter, related to the resolution of the data. This parameter indicates a region for which we can assume it contains at least one point if it is centered on the surface.

The neighborhood size can be estimated through statistical analysis. We use a kD-tree to estimate the mean distance to the n-th nearest neighbor and we use this distance as an approximator for the resolution.

The method provides access to intermediate results and the user can adjust these to better suit its needs. The (intermediate) results are the estimate of the resolution, the scale-space, and the final collection of surface triangles.


\subsection ScaleSpaceReconstruction3secParam Parameter Settings


The scale-space surface reconstruction method has two main global parameters: the radius of the neighborhood ball and the number of scale-space advancement iterations. If no appropriate neighborhood radius is known, this can be estimated using two more parameters: the mean number of neighbors and the number of samples. We have empirically determined values for each of these parameters that work well on a broad spectrum of data sets. However, we advise to carefully fine-tune these parameters for each new data sets.

The scale-space reconstruction operates locally. Points within a local neighborhood influence each other when advancing the scale-space. Similarly, points near each other in space are more likely to be near each other on the reconstructed surface. Therefore, it is important to have a good indication of which points are near each other. This proximity is expressed in the neighborhood ball radius parameter.

The neighborhood ball radius is related to the point density and the object thickness. In the ideal case, the radius is chosen such that any ball \f$ B \f$ with this radius centered on any point of surface of the object will contain several points that should be connected by a local patch in the surface to reconstruct. At the same time, \f$ B \f$ should not contain any points that should not be part of this local patch, such as points on the other side of the object.

The neighborhood radius can be estimated automatically from the point set. In this case, the radius is estimated such that on average it contains a given number of points. The number of points should be chosen such that the conditions on the neighborhood radius described above are preserved. Generally, an average of thirty neighbors gives good results. This number may be increased if parts of the object have a very low point density, it may be decreased if thin details of the object should be reconstructed better.

The radius estimation is based on a number of sample points. This number of samples is related to how regularly the point set covers the object. A large sample size may be required if the object is covered very irregularly. However, a larger number of samples may require more computation time. We generally use 200 samples to estimate the neighborhood radius.

The scale-space method tries to make the surface reconstruction problem less ill-posed by advancing the scale-space to a more coarse scale. At this coarse scale the point set samples a smoothed surface, which is easier to reconstruct. The number of advancement iterations determines how much this surface is smoothed.

The number of iterations is related to the noise in the point set, the acuteness of surface features, and the thickness of the object. Point sets with a lot of noise and objects with sharp or small features will require more iterations. At the same time, processing too many iterations can degenerate a volume into a plane. These degeneracies may cause the reconstructed surface to connect points on opposite surfaces of the object. Generally, four iterations of scale-space advancement are appropriate.


\section ScaleSpaceReconstruction3secDesign Software Design

The main class `Scale_space_surface_reconstruction_3` contains all the functionality to estimate the neighborhood size, compute the scale-space, and reconstruct the surface from the scale-space.

The neighborhood size is estimated using Orthogonal_k_neighbor_search. The point set is generally stored in a Orthogonal_k_neighbor_search::Tree. When the neighborhood size is estimated, this tree is searched for nearest neighbors.

The scale-space is computed using a weighted PCA procedure. For this procedure, we use the efficient \ref thirdpartyEigen libraries. Because this procedure is performed locally per point, it is performed with parallel computing when openMP is enabled.

The mesh reconstruction of the scale-space is performed by filtering an Alpha_shape_3 or Fixed_alpha_shape_3. Which of these is used is captured in the Fixed_scale template parameter of Scale_space_surface_reconstruction_3.

The resulting surface is stored as a collection of triples. Each triple contains three indices to the point set. Because the scale-space does not change the order of the points, these triples can be applied on the original point set to get an interpolating surface. The triples may also be applied to the scale-space to get a smoothed surface.


\section Triangulation3secComplexity Case Sets and Performance

There is a wide variety of possible point sample sets, whether synthetic or measured. The scale-space surface reconstruction method attempts to make the reconstruction problem less ill-posed. However, we cannot guarantee good results for arbitrary point set. Some point sets require careful parameter setting, while for others this method is ill-suited altogether. Here, we show different cases including the ideal sampling and different problem cases.

\subsection Triangulation3ssecIdeal Ideal Conditions

The scale-space surface reconstruction has lenient ideal conditions. The surface should be reasonably regularly sampled and it should not contain overly concave corners. These notions counteract each other by affecting the neighborhood parameter: more regular samplings may admit a smaller neighborhood parameter, which will admit smaller concavities. The point set may contain noise that is significantly smaller than the neighborhood size. Even so, when using the method to interpolate the original point set, this noise will deform the mesh. \cgalFigureRef{chapterScaleSpaceReconstruction3figIdeal} shows a reconstruction under ideal conditions.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figIdeal, retinal_pts.png, retinal_surf.png}
Left: In the ideal case, points are regularly distributed and concavities are limited. Right: reconstructed surface mesh.
\cgalFigureEnd

\subsection Triangulation3ssecBound Boundaries

Surfaces with boundaries are handled naturally. However, it is important to note that in these cases, the surface does not explicitly identify the boundary and loops around it. In many cases, this will lead to neighboring triangles of the surface that share a boundary edge to be identical except for their orientation. The boundaries may be made explicit by identifying orientation discrepancies between neighboring triangles, but this functionality is not provided by this package. \cgalFigureRef{chapterScaleSpaceReconstruction3figBound} shows a reconstructed surface with a boundary.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figBound, mushroom_pts.png, mushroom_surf.png}
Left: A point sample of a surface with boundary. Right: reconstructed surface mesh.
\cgalFigureEnd

\subsection Triangulation3ssecRegularity Sampling Regularity

As described above, ideally the point set regularly samples the surface. For example, for each point its six nearest points lie at roughly equal distance forming a rough hexagon around the point. This will generally not occur when working with realistic data. The scale-space method can reconstruct very unevenly sampled surfaces, as \cgalFigureRef{chapterScaleSpaceReconstruction3figUneven} shows. However, as noted earlier the sampling regularity and allowed concavity form a trade-off. \cgalFigureRef{chapterScaleSpaceReconstruction3figUnevenFail} shows a case where we cannot simultaneously correctly model the concave regions and sparse regions.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figUneven, femur_pts.png, femur_surf.png}
Left: A very irregularly sampled point set. Right: reconstructed surface mesh.
\cgalFigureEnd

\cgalFigureBegin{chapterScaleSpaceReconstruction3figUnevenFail, lion-head_pts.png, lion-head_surf.png}
Left: A very irregularly sampled point set with tight concavities. Right: reconstructed surface mesh. Note we cannot correctly model the mouth and eyes as well as the neck.
\cgalFigureEnd

\subsection Triangulation3ssecSharp Sharp Features

The scale-space surface reconstruction method was not designed to deal specifically with surfaces with sharp features. However, it reconstructs these features adequately when using appropriate parameter settings, as demonstrated in \cgalFigureRef{chapterScaleSpaceReconstruction3figSharp}. The main prerequisite for correctly reconstructing the sharp features is that they contain sufficient sample points on the features and the features are not too thin compared to the neighborhood parameter.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figSharp, fandisk_pts.png, fandisk_surf.png, fandisk_2_surf.png, fandisk_2_surf_detail.png}
Left: A point set on a surface with sharp creases. Center, Right: reconstructed surface mesh. Note that the sharp features are mostly reconstructed correctly. However, in the thin regions circled in red the feature is not reconstructed correctly. The trade-off between regularity and concavity also means a hole appears in the bottom right.
\cgalFigureEnd

\subsection Triangulation3ssecTopo Topology

The scale-space surface reconstruction method does not take into account the topology of the surface. This means the reconstructed surface may have a different topology than the surface sampled to obtain the point set. \cgalFigureRef{chapterScaleSpaceReconstruction3figTopo} shows an example point set that was sampled from a surface with the topology of a sphere; the reconstructed surface has the topology of a torus.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figTopo, man_pts.png, man_surf.png}
Left: An irregularly sampling of a surface with the topology of a sphere. Right: reconstructed surface mesh with the topology of a torus. Note that the irregular sampling makes it impossible to reconstruct a surface with the topology of a sphere, because the method uses a global scale parameter.
\cgalFigureEnd

\subsection Triangulation3ssecAttrib Point Attributes.

Many point sets contain point attributes such as normals or colors. Because the scale-space surface reconstruction constructs the connectivity between the original points any appropriate point attributes can be applied to the surface. \cgalFigureRef{chapterScaleSpaceReconstruction3figColor} shows the surface reconstructed for a set of points with colors.

\cgalFigureBegin{chapterScaleSpaceReconstruction3figColor, trophime.png, trophime_detail.png}
Left: A reconstructed surface with vertex coloring using the colors of the point set. Right: detail of the surface shown as wire-frame. Images or image-based modeling: MAP (Mod√®les et simulations pour l'Architecture et le Patrimoine) - UMR CNRS/MCC 3495.
\cgalFigureEnd


\subsection Triangulation3ssecPerform Performance

We have evaluated the scale-space surface reconstruction method on several data sets of various sizes. \cgalFigureRef{chapterScaleSpaceReconstruction3figBenchmarks} shows the parameter settings used when processing the scale-space reconstruction method.

\cgalFigureAnchor{chapterScaleSpaceReconstruction3figSettings}
<center>
|     Data set | Neighbors | Samples | Iterations | 
|        ----: |     ----: |   ----: |      ----: |
  Mushroom (s) |       10  |     200 |          2 |
  Elephant (s) |       15  |     200 |          1 |
    Knot 1 (s) |        8  |     100 |          8 |
   Retinal (s) |       30  |     200 |          4 |
         Femur |       25  |     300 |          6 |
    Kitten (s) |       10  |     100 |          4 |
    Knot 2 (s) |        8  |     300 |          8 |
      Bull (s) |      100  |     600 |          1 |
   Fandisk (s) |        6  |     300 |          8 |
 Lion-head (s) |       12  |     400 |          1 |
   Turbine (s) |       60  |     400 |          1 |
      Graill 1 |       10  |     200 |          4 |
     Graill 11 |       10  |     200 |          4 |
       Man (s) |      100  |     600 |          1 |
          Face |       10  |     200 |          4 |
    Carc 20 LR |       10  |     200 |          4 |
    Carc 21 LR |       10  |     200 |          4 |
        Bowl 1 |       10  |     200 |          4 |
        Bowl 5 |       10  |     200 |          4 |
       Fount 1 |       10  |     200 |          4 |
      Fount 11 |       10  |     200 |          4 |
      Trophime |       10  |     200 |          4 |
       Carc 20 |       10  |     200 |          4 |
       Carc 21 |       10  |     200 |          4 |
</center>
\cgalFigureCaptionBegin{chapterScaleSpaceReconstruction3figSettings}
Settings used when running the scale-space method on several data sets. Data sets indicated by "(s)" are synthetic. \em Neighbors indicates the number of neighbors the estimated neighborhood ball should contain on average, \em Samples indicates the number of sample points used to estimate the neighborhood radius, \em Iterations indicates the number of scale-space advancement iterations.
\cgalFigureCaptionEnd

\cgalFigureRef{chapterScaleSpaceReconstruction3figBenchmarks} shows the number of triangles of the surfaces constructed and the running time for doing so. Half of the data sets are synthetic, the others are constructed by image-based dense reconstruction. The data sets are ordered by size, the synthetic sets mainly making up the smaller ones.

The times were measured on a 64-bit Windows 7 system with 8 2.5GHz Intel processors and 16GB RAM. The scale-space constructions employ parallel computing using openMP. The smaller data sets use roughly 0.1GB of memory, but the largest data sets have a peak usage of 10.5GB during the meshing step. For this benchmark we used the Exact_predicates_inexact_constructions_kernel kernel, Fixed_scale enabled, and Shells disabled.14

\cgalFigureAnchor{chapterScaleSpaceReconstruction3figBenchmarks}
<center>
|     Data set |  Number of points | Surface triangles | Neighborhood (ms) | Scale-space (ms) | Meshing (ms) | Total (ms) |
|        ----: |     ----: |      ----: | ----: |   ----: |   ----: |   ----: |
  Mushroom (s) |     2,337 |      7,966 |     7 |      64 |      88 |     159 |
  Elephant (s) |     2,775 |      6,746 |     4 |      33 |      91 |     128 |
    Knot 1 (s) |     3,200 |     12,800 |     7 |     148 |     134 |     289 |
   Retinal (s) |     3,643 |     14,154 |     8 |     224 |     122 |     354 |
         Femur |     3,897 |     12,612 |     6 |     592 |     120 |     718 |
    Kitten (s) |     5,210 |     20,428 |     7 |     198 |     172 |     377 |
    Knot 2 (s) |     5,760 |     22,904 |     5 |     278 |     206 |     489 |
      Bull (s) |     6,200 |     11,892 |    20 |     238 |     149 |     407 |
   Fandisk (s) |     6,475 |     25,282 |     5 |     330 |     212 |     547 |
 Lion-head (s) |     8,356 |     27,128 |     7 |     125 |     249 |     382 |
   Turbine (s) |     9,210 |     14,084 |    12 |     293 |     201 |     507 |
      Graill 1 |    12,681 |     45,326 |    14 |   1,166 |     381 |   1,561 |
     Graill 11 |    14,617 |     54,550 |    18 |   1,072 |     454 |   1,544 |
       Man (s) |    17,495 |     38,496 |    25 |     845 |     421 |   1,291 |
          Face |   296,275 |    906,648 |   128 |  17,983 |   7,843 |  25,957 |
    Carc 20 LR | 1,311,850 |  1,311,850 |   154 |  20,652 |  10,822 |  31,632 |
    Carc 21 LR | 1,443,510 |  1,443,510 |   157 |  19,778 |  12,290 |  32,228 |
        Bowl 1 | 2,741,328 |  2,841,328 |   351 |  34,688 |  22,559 |  57,608 |
        Bowl 5 | 3,682,188 |  3,682,188 |   471 |  50,762 |  29,899 |  81,144 |
       Fount 1 | 1,504,761 |  5,946,502 |   764 | 112,028 |  51,451 | 164,262 |
      Fount 11 | 2,589,083 | 10,203,108 | 1,350 | 216,623 |  85,231 | 303,248 |
      Trophime | 4,572,657 | 16,982,194 | 2,413 | 630,502 | 134,427 | 767,389 |
       Carc 20 | 5,370,681 | 21,190,868 | 2,531 | 304,015 | 179,223 | 485,813 |
       Carc 21 | 5,800,135 | 23,042,576 | 2,916 | 365,731 | 212,840 | 581,535 |
</center>
\cgalFigureCaptionBegin{chapterScaleSpaceReconstruction3figBenchmarks}
Number of triangles of the surfaces constructed and running times in miliseconds for the scale-space method. Data sets indicated by "(s)" are synthetic.
\cgalFigureCaptionEnd


\section ScaleSpaceReconstruction3secExamples Examples

This first example shows how to read a point set from a file, reconstruct the surface, and write the surface to another file.

\cgalExample{Scale_space_reconstruction_3/scale_space.cpp}

The next example shows how to perform the reconstruction step-by-step and how to change the parameters between steps.

\cgalExample{Scale_space_reconstruction_3/scale_space_incremental.cpp}


\section ScaleSpaceReconstruction3secDesImpl Design and Implementation History

This method was developed by Julie Digne <i>et al.</i> in 2011 \cgalCite{cgal:dmsl-ssmrp-11} and implemented by Thijs van Lankveld at Inria - Sophia Antipolis in 2014.

*/ 
} /* namespace CGAL */

