% +------------------------------------------------------------------------+
% | Reference manual page: Point_2.tex
% +------------------------------------------------------------------------+
% | 27.03.2008   Author
% | Package: Curved_kernel_via_analysis_2
% |
\RCSdef{\RCSPointRev}{$Id: header.tex 40270 2007-09-07 15:29:10Z lsaboret $}
\RCSdefDate{\RCSPointDate}{$Date: 2007-09-07 17:29:10 +0200 (Fri, 07 Sep 2007) $}
% |
\ccRefPageBegin
%%RefPage: end of header, begin of main body
% +------------------------------------------------------------------------+


\begin{ccRefClass}[CGALi::]{Point_2}  %% add template arg's if necessary
\ccRefLabel{Point_2}

%% \ccHtmlCrossLink{}     %% add further rules for cross referencing links
%% \ccHtmlIndexC[class]{} %% add further index entries

\ccDefinition
  
%The class \ccRefName\ does this and that.

\ccInclude{Point_2.h}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccDefinition)

Class defines a point on a curve that can be analyzed.

Only points with finite coordinates can be constructed explicitly (by the user). Points on the boundary use special private constructors to to represent ends of curve arcs on the boundary.

%END-AUTO(\ccDefinition)


\ccParameters

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccParameters)

template$<$  \\
class \ccc{CurvedKernelViaAnalysis_2},   \\
class \ccc{Rep_} = \ccc{CGALi::Point_2_rep<CurvedKernelViaAnalysis_2>}$>$   \\
class \ccc{Point_2};

%END-AUTO(\ccParameters)


\ccIsModel

\ccTypes

%\ccCreation
%\ccCreationVariable{a}  %% choose variable name

%% \ccIncludeExampleCode{Curved_kernel_via_analysis_2/Point_2.C}

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccTypes)

\ccNestedType{Curved_kernel_via_analysis_2}
{
this instance's first template parameter
}
\ccGlue
\ccNestedType{Rep}
{
this instance's second template parameter
}
\ccGlue
\ccNestedType{Self}
{
this instance itself
}
\ccGlue
\ccNestedType{Curve_kernel_2}
{
type of underlying curve kernel
}
\ccGlue
\ccNestedType{X_coordinate_1}
{
type of an x-coordinate
}
\ccGlue
\ccNestedType{Xy_coordinate_2}
{
type of an xy-coordinate
}
\ccGlue
\ccNestedType{Curve_analysis_2}
{
type that analyzes a curve
}
\ccGlue
\ccNestedType{Base}
{
the handle superclass
}
\ccGlue
\ccNestedType{Kernel_point_2}
{
type of kernel point
}
\ccGlue

%END-AUTO(\ccTypes)

\ccCreation
\ccCreationVariable{a}  %% choose variable name for \ccMethod below

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccCreation)

\ccConstructor{Point_2();}
{
Default constructor.
}
\ccGlue
\ccConstructor{Point_2(const Self& p);}
{
copy constructor
}
\ccGlue
\ccConstructor{Point_2(const X_coordinate_1& x, const Curve_analysis_2& c, int arcno);}
{
Constructs an interior point.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The x-coordinate \item[c]The supporting curve \item[arcno]Arcno of point on c \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed point \end{description}
\ccGlue
\ccConstructor{Point_2(Arr_curve_end inf_end, const Curve_analysis_2& c, int arcno);}
{
[protected] \\
Constructs a point with x-coordinate at the left/right boundary.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[\ccc{inf_end}]Determines whether point is on left or right boundary \item[c]The supporting curve \item[arcno]Arcno of point on on left/right boundary \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed point \end{description}
\ccGlue
\ccConstructor{Point_2(const X_coordinate_1& x, const Curve_analysis_2& c, Arr_curve_end inf_end);}
{
[protected] \\
Constructs a point on bottom or top boundary.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[x]The x-coordinate of point \item[c]The supporting curve \item[\ccc{inf_end}]Defines whether point is on bottom or top boundary \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed point \end{description}
\ccGlue
\ccConstructor{Point_2(Rep rep);}
{
[protected] \\
constructs from a given represenation
Constructor for for rebind
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[rep]The representation \end{description}
\end{description}
\begin{description}
\item[Returns:]The constructed point \end{description}
\ccGlue

%END-AUTO(\ccCreation)

\ccOperations

% The section below is automatically generated. Do not edit!
%START-AUTO(\ccOperations)

\ccMethod{const X_coordinate_1& x() const;}
{
Access to the point's x-coordinate (y-coordinate can be undefined).
}
\ccGlue
\begin{description}
\item[Returns:]The stored x-coordinate \end{description}
\begin{description}
\item[Precondition:]the point's x must be finite \end{description}
\ccGlue
\ccMethod{const Xy_coordinate_2& xy() const;}
{
Access to underlying \ccc{Xy_coordinate_2} object.
}
\ccGlue
\begin{description}
\item[Returns:]The stored xy-coordinate \end{description}
\begin{description}
\item[Precondition:]The xy-coordinates must be finite \end{description}
\ccGlue
\ccMethod{Curve_analysis_2 curve() const;}
{
supporting curve of point
}
\ccGlue
\begin{description}
\item[Returns:]supporting curve of point \end{description}
\ccGlue
\ccMethod{int arcno() const;}
{
Arc number of point on a curve.
}
\ccGlue
\begin{description}
\item[Returns:]arcno of point \end{description}
\begin{description}
\item[Precondition:]Is not endpoint of a vertical ray or branch \end{description}
\ccGlue
\ccMethod{void set_location(Arr_parameter_space loc) const;}
{
sets location of a point in parameter space to loc
It is supposed that the user thoroughly understands malicious consequences that may result from the misuse of the location
}
\ccGlue
\ccMethod{Arr_parameter_space location() const;}
{
location of a point in parameter space
}
\ccGlue
\begin{description}
\item[Returns:]location in parameter space \end{description}
\ccGlue
\ccMethod{bool is_on_left_right() const;}
{
checks if the point lies on left/right boundary
}
\ccGlue
\begin{description}
\item[Returns:]true if it lies on left/right boundary, false otherwise \end{description}
\ccGlue
\ccMethod{bool is_on_bottom_top() const;}
{
checks if the point lies on bottom/top boundary
}
\ccGlue
\begin{description}
\item[Returns:]true if it lies on bottom/top boundary, false otherwise \end{description}
\ccGlue
\ccMethod{bool is_finite() const;}
{
checks whether the point is finite
}
\ccGlue
\begin{description}
\item[Returns:]true, if point is finite, false otherwise \end{description}
\ccGlue
\ccMethod{Comparison_result compare_x(const Kernel_point_2& q) const;}
{
Compares x-coordinates of this point with q.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[q]The other point \end{description}
\end{description}
\begin{description}
\item[Returns:]LARGER if x($\ast$this) $>$ x(q); SMALLER if x($\ast$this) $<$ x(q); EQUAL if x($\ast$this) = x(q). \end{description}
\begin{description}
\item[Precondition:]compared points are in the interior of parameter space \end{description}
\ccGlue
\ccMethod{Comparison_result compare_xy(const Kernel_point_2& q, bool equal_x = false) const;}
{
Compares this point with q lexicographically.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[q]The other point \end{description}
\end{description}
\begin{description}
\item[Returns:]LARGER if x($\ast$this) $>$ x(q), or if x($\ast$this) = x(q) and y($\ast$this) $>$ y(q); SMALLER if x($\ast$this) $<$ x(q), or if x($\ast$this) = x(q) and y($\ast$this) $<$ y(q); EQUAL if the two points are equal. \end{description}
\begin{description}
\item[Precondition:]Compared points are in the interior of parameter space \end{description}
\ccGlue
\ccMethod{bool is_on(const typename Curved_kernel_via_analysis_2::Curve_2& curve) const;}
{
Checks if a point lies on on a curve.
}
\ccGlue
\begin{description}
\item[Parameters:]
\begin{description}
\item[curve]The curve to check \end{description}
\end{description}
\begin{description}
\item[Returns:]true, if $\ast$this lies on curve, false otherwise \end{description}
\ccGlue
\ccMethod{bool operator==(const Kernel_point_2& q) const;}
{
equality
}
\ccGlue
\ccMethod{bool operator!=(const Kernel_point_2& q) const;}
{
inequality
}
\ccGlue
\ccMethod{bool operator<(const Kernel_point_2& q) const;}
{
less than in (x,y) lexicographic order
}
\ccGlue
\ccMethod{bool operator<=(const Kernel_point_2& q) const;}
{
less-equal in (x,y) lexicographic order
}
\ccGlue
\ccMethod{bool operator>(const Kernel_point_2& q) const;}
{
greater than in (x,y) lexicographic order
}
\ccGlue
\ccMethod{bool operator>=(const Kernel_point_2& q) const;}
{
greater-equal in (x,y) lexicographic order
}
\ccGlue
\ccMethod{void write(std::ostream& os) const;}
{
writes point to os
\subsubsection{Friends And Related Function Documentation}
\ccMethod{std::ostream& operator<<(std::ostream& os, const Point_2< CurvedKernelViaAnalysis_2, Rep_>& pt);}
{
[related] \\
writes pt to os
}
\ccGlue

%END-AUTO(\ccOperations)

\end{ccRefClass}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
\ccRefPageEnd
% EOF
% +------------------------------------------------------------------------+

