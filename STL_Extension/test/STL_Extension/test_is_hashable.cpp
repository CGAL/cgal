// test partially generated by Github Copilot

#include <CGAL/unordered_flat_map.h>
#include <CGAL/Point_2.h>
#include <CGAL/Point_3.h>
#include <CGAL/Vector_2.h>
#include <CGAL/Simple_cartesian.h>
#include <CGAL/Exact_predicates_inexact_constructions_kernel.h>
#include <CGAL/Exact_predicates_exact_constructions_kernel.h>
#include <string>
#include <utility> // std::pair

// Test types without hash support
struct No_hash {};
struct No_default_constructible_hash {};

// Provide boost::hash_value for No_default_constructible_hash
namespace boost {
  std::size_t hash_value(const No_default_constructible_hash&) { return 42; }
}

// But make std::hash not default constructible
namespace std {
  template <>
  struct hash<No_default_constructible_hash> {
    hash() = delete; // Not default constructible
    std::size_t operator()(const No_default_constructible_hash&) const { return 42; }
  };
}

int main() {
  using CGAL::is_hashable_v;
  using SC = CGAL::Simple_cartesian<double>;
  using Epick = CGAL::Exact_predicates_inexact_constructions_kernel;
  using Epeck = CGAL::Exact_predicates_exact_constructions_kernel;

  // Built-in types should be hashable
  static_assert(is_hashable_v<int>);
  static_assert(is_hashable_v<double>);
  static_assert(is_hashable_v<float>);
  static_assert(is_hashable_v<long>);
  static_assert(is_hashable_v<std::string>);

  // Types without hash support should not be hashable
  static_assert(!is_hashable_v<No_hash>);

  // Types with hash_value but non-default-constructible std::hash should not be hashable
  static_assert(!is_hashable_v<No_default_constructible_hash>);

  // CGAL kernel objects should be hashable (with Cartesian kernels)
  static_assert(is_hashable_v<SC::Point_2>);
  static_assert(is_hashable_v<SC::Point_3>);
  static_assert(is_hashable_v<SC::Vector_2>);
  static_assert(is_hashable_v<SC::Vector_3>);
  static_assert(is_hashable_v<SC::Segment_2>);
  static_assert(is_hashable_v<SC::Segment_3>);
  static_assert(is_hashable_v<SC::Aff_transformation_2>);
  static_assert(is_hashable_v<SC::Aff_transformation_3>);
  static_assert(is_hashable_v<SC::Circle_2>);
  static_assert(is_hashable_v<SC::Sphere_3>);
  static_assert(is_hashable_v<SC::Iso_rectangle_2>);
  static_assert(is_hashable_v<SC::Iso_cuboid_3>);
  static_assert(is_hashable_v<SC::Weighted_point_2>);
  static_assert(is_hashable_v<SC::Weighted_point_3>);

  // Test with Epick kernel
  static_assert(is_hashable_v<Epick::Point_2>);
  static_assert(is_hashable_v<Epick::Point_3>);
  static_assert(is_hashable_v<Epick::Vector_2>);
  static_assert(is_hashable_v<Epick::Vector_3>);

  // Test with Epeck kernel
  static_assert(!is_hashable_v<Epeck::Point_2>);
  static_assert(!is_hashable_v<Epeck::Point_3>);
  static_assert(!is_hashable_v<Epeck::Vector_2>);
  static_assert(!is_hashable_v<Epeck::Vector_3>);

  // Bbox types should be hashable
  static_assert(is_hashable_v<CGAL::Bbox_2>);
  static_assert(is_hashable_v<CGAL::Bbox_3>);

  // std::pair should not be hashable (no std::hash specialization in standard)
  static_assert(!is_hashable_v<std::pair<int, int>>);

  return 0;
}
