\begin{ccRefConcept}{CurvePairAnalysis_2::StatusLine_1}

\ccDefinition

The \ccc{StatusLine_1} concept is meant to provide information
about the intersections of a pair of curves with a vertical line $x = x_0$
for some finite $x_0$, 
ignoring covered vertical lines of the curves themselves.
Each intersection of a 
curve with the status line defined by some given $x$ induces an event. 
An event can be queried for its coordinates (\ccc{Algebraic_real_2})
and the involved curve(s). 
Again \ccc{StatusLine_1} at $x = \pm\infty$ are 
not allowed. 

\ccTypes \ccThree{}{+++++++++++++}{++++++++}

\ccNestedType{size_type}{A instance of a size type, e.g., \ccc{int}}

\ccNestedType{Multiplicity}{A instance of a multiplicity type, for instance,
\ccc{int}, that enables to encode the multiplicity of two intersecting curves.}

\ccNestedType{Algebraic_real_1}{Model of the concept
\ccc{AlgebraicKernel_d_1::Algebraic_real_1}.}

\ccNestedType{Algebraic_real_2}{Model of the concept
\ccc{AlgebraicKernel_d_2::AlgebraicReal_2}.}
  

\ccCreationVariable{sl}
\ccAccessFunctions

\ccMethod{Algebraic_real_1 x();}{
  returns the $x$-coordinate of the status line (always a finite value).
}

\ccMethod{size_type number_of_events();}{
  returns number of distinct and finite intersections of a pair of 
  curves with a status line ignoring a real vertical line component 
  of the curves at the given $x$-coordinate.
}

\ccMethod{size_type event_of_curve(size_type k, bool c);}{
  returns the $y$-position of the $k$-th curve event of the $c$-th
  (0 or 1) curve in the sequence of curve pair events. 
  Note that each curve pair event
  is formed by the first, the second, or both curves. 
  \ccPrecond{
    $0 \leq k$ 
    and the status line of the $c$-th curve at that $x$-coordinate
    has more than $k$ events}
}

\ccMethod{size_type event_of_curve(size_type k, Curve_analysis_2 ca);}{
  returns the $y$-position of the $k$-th curve event of the curve $ca$
  in the sequence of curve pair events. 
  Note that each curve pair event
  is formed by the first, the second, or both curves. 
  \ccPrecond{
    $0 \leq k$ 
    and the status line of $ca$ at that $x$-coordinate
    has more than $k$ events}
}

\ccMethod{Multiplicity multiplicity_of_intersection(size_type j);}{
  returns either~$0$, or, if known, the multiplicity of intersection defined at
  event with position~$j$. After all, always returning~$0$ is a correct
  behavior, but reporting the correct value may help for speed-up computations.
  \ccPrecond{There is an intersection of both curves at $j$-th event.}
  \ccPrecond{$0 \leq j < $\ccc{number_of_events()}}
}

\ccMethod{std::pair< size_type, size_type > curves_at_event(size_type j);}{
  returns a pair indicating which events of the two curves contribute to
  event~$j$ in the pair of curves. An entry can be $-1$, if the 
  corresponding curve is not involved. 
  \ccPrecond{$0 \leq j < $\ccc{number\_of_events()}}
}

\ccMethod{std::pair< size_type>  curves_at_event(size_type j, 
                                                 Curve_analysis_2 ca1,
                                                 Curve_analysis_2 ca2);}{
  returns a pair indicating which events of the two curves {\tt ca1} and {\tt
  ca2} contribute to event~$j$ in the pair of curves. An entry can be $-1$,
  if the corresponding curve is not involved.
  \ccPrecond{$0 \leq j < $\ccc{number\_of_events()}}
  \ccPrecond{$ca1$ and $ca2$ are the two curves involved in the curve pair}
  \ccPrecond{$ca1 != ca2$}
}

%Note that this interface mainly rewrites $\{f,g,x\}^n$ in a different way - 
%using \ccc{size_type}. Actually the CPVL has to compute this sequence, but for
%the interface it is nicer to have it already here to avoid conversion objects
%(introducing additional constructor calls, cache-misses, lookup and so on) in
%the next layer on top (CK). Obviously, the \ccc{size_type}s
%can be computed in a generic
%way from a sequence, so that it makes sense to offer a default implementation
%providing such conversion. There is no need to document this fact on the 
%conceptual view.

\ccMethod{bool is_event();}{
  returns \ccc{true} if the status line contains an event point. Namely, if
   one of the curves has an event, or if the two curves intersect, at a point 
   whose $x$-coordinate is sl.x().
}

\ccMethod{bool is_intersection();}{
  returns \ccc{true} if the status line contains an intersection point. 
  Namely, if the two curves intersect at a point whose $x$-coordinate 
  is sl.x().
}

\end{ccRefConcept}

\begin{ccRefConcept}{AlgebraicKernelWithAnalysis_d_2::CurvePairAnalysis_2}

\ccDefinition

The \ccc{CurvePairAnalysis_2} concept is meant to provide tools to analyze 
a pair of curves. An analysis is meant to describe the curve pair's 
interesting points and how they are connected. 
The analysis searches for {\it events}. Events only
occur at a finite number of $x$-coordinate. Each such coordinate is
covered by a \ccc{StatusLine_1}, 
originated by the events of a single curve
and also the intersections of two curves.
These coordinates also define open {\it intervals}
on the $x$-axis. \ccc{StatusLine_1} 
at values in between one such interval
differ only in the values of the \ccc{Algebraic_real_2} entries. Topological 
information is equal. 

{\bf Warning:} When a curve pair is constructed using the call
{\tt cpa(ca\_1,ca\_2)}, it is {\bf not} required that 
{\tt ca\_1==cpa.curve\_analysis(0)} and {\tt ca\_2==cpa.curve\_analysis(1)} 
holds.
In other words, the curves might be swapped internally.
The user is responsible to find out whether such a swapping took place
during the creation.

\ccRefines{
  \ccc{DefaultConstructible, CopyConstructible, Assignable}
}

\ccTypes \ccThree{}{+++++++++++++}{++++++++}

\ccNestedType{size_type}{A instance of a size type, e.g., \ccc{int}}

\ccNestedType{Algebraic_real_1}{Model of the concept
\ccc{AlgebraicKernel_d_1::Algebraic_real_1}.}

\ccNestedType{Algebraic_real_2}{Model of the concept
\ccc{AlgebraicKernel_d_2::AlgebraicReal_2}.}

\ccNestedType{Status_line_1}{Model of the concept
\ccc{CurvePairAnalysis_2::StatusLine_1}.}

\ccNestedType{Curve_analysis_2}{Model of the concept 
\ccc{CurvePairAnalysis::CurveAnalysis_2}.}

\ccCreation
\ccCreationVariable{cpa}

\ccConstructor{CurvePairAnalysis_2(Curve_analysis_2 ca1, Curve_analysis_2 ca2);}
{constructs an analysis for the curve-pair defined by analysis given by 
ca1 and ca2. 
\ccPrecond{The polynomials defining the analysis must be square free and 
coprime.}
}

\begin{ccAdvanced}

\ccConstructor{template < class InputIterator >
  CurvePairAnalysis_2(Curve_analysis_2 ca1, Curve_analysis_2 ca2, 
  InputIterator begin, InputIterator end);}{
  constructs an analysis for the pair of curves defined by $ca1$ and $ca2$. 
  The iterator range [begin,end) contains factors of $\mbox{resultant}(p,q,y)$,
  i.e., define $x$-coordinates, 
  which allows to simplify the real root isolation within this layer.
  The \ccc{value_type} of InputIterator is \ccc{Polynomial_1}.
\ccPrecond{The polynomials defining the analysis must be square free and coprime.}
} 
  This constructor has been introduced to enable an upper layer 
(geometric curved kernel) to use additional knowledge on the problem.
If the signature is not provided by a model, a compile error occurs.
\end{ccAdvanced}

\ccAccessFunctions

\ccMethod{Curve_analysis_2 curve_analysis(bool c);}{
  returns curve analysis for $c$-''th'' curve (0 or 1)
}

\ccMethod{size_type number_of_status_lines_with_event();}{
  returns number of status lines that contain an event point.
}


\ccMethod{size_type event_of_curve_analysis(size_type i, bool c);}{
  Given the $i$-th event of the curve pair 
  this method returns the id of the event of the corresponding curve
  analysis $c$ (0 or 1), or $-1$, if the curve has no event 
  at this coordinate.
  \ccPrecond{$0 \leq i < $\ccc{num\_status\_lines\_with\_event()}}
}

\ccMethod{size_type event_of_curve_analysis(size_type i, Curve_analysis_2 ca);}{
  Given the $i$-th event of the curve pair 
  this method returns the id of the event of the curve analysis $ca$, 
  or $-1$, if the curve has no event at this coordinate.
  \ccPrecond{$ca$ is one of the curves that form the curve pair}
  \ccPrecond{$0 \leq i < $\ccc{num\_status\_lines\_with\_event()}}
}

\ccMethod{Status_line status_line_at_event(size_type i);}{
  returns an instance of \ccc{StatusLine_1} at the $i$-th event
  \ccPrecond{$0 \leq i < $\ccc{num\_status\_lines\_with\_event()}}
}

\ccMethod{Status_line status_line_of_interval(size_type i);}{
  returns an instance of \ccc{StatusLine_1} of the $i$-th interval
  between $x$-events.
  \ccPrecond{$0 \leq i \leq $\ccc{num\_status\_lines\_with\_event()}}
}

\ccMethod{Status_line status_line_for_x(Algebraic_real_1 x,
  CGAL::Sign perturb = CGAL::ZERO);}{
  returns status\_line\_at\_event(i), if $x$ hits $i$-th event, otherwise
  returns status\_line\_of\_interval(i), where $i$ is the id of the interval
  $x$ lies in. 
  If $perturb$ is CGAL::NEGATIVE (CGAL::POSITIVE) and $x$ states
  an event, then status\_line\_of\_interval(i) 
  (status\_line\_of\_interval(i+1)) is returned.
  \ccPrecond{$x$ is finite}
}

\ccMethod{Status_line status_line_at_exact_x(Algebraic_real_1 x);}{
  returns an instance of \ccc{StatusLine_1} at the given $x$
  \ccPrecond{$x$ is finite}
}

Note that the access methods to status lines are not redundant! The ones
using an id-value are efficient for speed-ups (caching, avoids to search for
some $x$, or the unique representative status line for an interval),
while the ones with given $x$ still perform a look-up. There is also a 
difference between \ccc{ status_line_for_x(x0,CGAL::ZERO)} and 
\ccc{status_line_at_exact_x(x0)} in the case \ccc{x0} is contained 
in an interval between events. Namely, the former is allowed to return a
precomputed representative for the interval, while the later enforces
a status line exactly at the given \ccc{x0} which implies that the 
$y$-coordinates are with respect to the given \ccc{x0}. In the first case,
the accessible $y$-coordinates are with respect to the representative's 
$x$-coordinate only.


%
%\begin{ccAdvanced}
%
%\ccMethod{Algebraic_real_2_const_iterator solve_begin();}{
%  returns iterator running over all finite intersection of the two curves.
%}
%
%\ccMethod{Algebraic_real_2_const_iterator solve_end();}{
%  returns past-end-value for all finite intersections of the two curves.
%}

%\ccMethod{size_type find(Algebraic_real_2 s);}{
%  returns the index of the event at the status line defined by 
%  $s$'s $x$-coordinate, or -1 if $s$ is does not lie on any curve.
%}

%\end{ccAdvanced}


%Additionally note that we talk about 4 sequences of $x$-critical lines here. 
%
%\begin{itemize}
%\item The sequence of StatusLine\_1 of $p$ where each CVL has been 
%converted and merged with $q$ to a CVPL.
%\item The sequence of StatusLine\_1 of $q$ where each CVL has been 
%converted and merged with $p$ to a CPVL.
%\item The sequence of StatusLine\_1 of the intersections of 
%$p$ and $q$
%\item The merged sequence of StatusLine_1 of the former three 
%sequences. The method event\_id\_of\_x helps to find indexes in the first 
%three sequences starting from an index in this sequence!
%\end{itemize}

\end{ccRefConcept}
