%------------------------------------------------------------------------------
%KILLSTART DISS REP
%LDEL TRACE.*?\)\;
\documentclass[a4paper]{article}
\usepackage{MyLweb}
\input{defs}

\excludeversion{ignoreindiss}
\excludeversion{ignore}

\begin{document}

\title{Filtered Extended Kernel}
\author{Michael Seel}
\maketitle

%KILLEND REP
\section{Introduction}

It is convenient to extend the vision of standard rational points by
so-called {\em non-standard} points.  We have one non-standard point
for each equivalence class of rays. Two rays are called equivalent if
one is contained in the other. The geometric properties of
non-standard points are derived by giving them a geometric
interpretation by means of an infinimaximal $R$. $R$ is a real
variable. The value of $R$ is finite but larger than the value of any
concrete real number. Let $F$ be the square box with corners
|NW(-R,R)|, |NE(R,R)|, |SE(R,-R)|, and |SW(-R,-R)|. Let $p$ be a
non-standard point and let $r$ be a ray defining it. If the frame $F$
contains the source point of $r$ then let $p(R)$ be the intersection
of $r$ with the frame $F$, if $F$ does not contain the source of $r$
then $p(R)$ is undefined.  For a standard point let $p(R)$ be equal to
$p$ if $p$ is contained in the frame $F$ and let $p(R)$ be undefined
otherwise. Clearly, for any standard or non-standard point $p(R)$ is
defined for any sufficiently large $R$.

Let $f$ be any function on standard points, say with $k$ arguments. We
call $f$ {\em extensible} if for any $k$ points $p_1$, \ldots, $p_k$
the function value $f(p_1(R),\ldots,p_k(R))$ is constant for all
sufficiently large $R$ and has the same value as the function
evaluated at a fixed large enough value $R_0$.  We also consider
geometric constructions. Let $g$ be a construction on standard points
constructing a tuple of $l$ points from a tuple of $k$ points. We call
$g$ {\em extensible} if for any $k$ points $p_1$, \ldots, $p_k$ the
construction is closed in our set of extended points: if it constructs
a point tuple $q_1$, \ldots, $q_l$ of extended points for all
sufficiently large $R$ with the property that by fixing a large enough
$R_0$ the tuple is the result of the standard construction.  As we
will see in a moment the predicates |lexicographic order| of points,
|orientation|, and |side_of_circle| are extensible. Also the
calculation of the point in the |intersection| of line segments
defined on two pairs of points is extensible.

For a formal definition of extended points, extended segments and the
corresponding predicates see the technical
report~\cite{TR:infimaximalframes}.

\section{Implementation}
%KILLEND DISS

In this section we descibe a more advanced extended kernel than
|Simple_extended_kernel|. This kernel tries to optimize runtime by use
of a filter stage. It does not rely on polynomial arithmetic but on
unrolled polynomial expressions directly programmed for the evaluation
of the predicates and constructions. We explain the techniques used.
We implement specialized kernel types that store the arbitrary
precision coordinates but also intervals of number type double
approximating them.  Then we show how our running example, the
orientation test, is implemented in its unrolled fashion. We finally
present the intersection operation based on a case-dependent
implementation. Our description covers all ideas needed to implement
the whole extended kernel concept.


\subsection*{Kernel types}
In contrast to the first approach based on a polynomial arithmetic
type |Polynomial<>| plugged into CGAL homogeneous points, we implement
an extended kernel based on specialized types. The components are the
types listed below plus the predicates and constructions that are
required to construct a model of our |ExtendedKernelTraits_2|
concept. The types that we implement are
@c
SPolynomial<RT>
SQuotient<RT>
Extended_point<RT>
Extended_segment<RT>
Extended_direction<RT>

@ We shortly elaborate on the usage of the above types and their
design. Let |RT| be a multi-precision integer number type like LEDA
|integer|. |SPolynomial<RT>| is a container type storing linear
polynomials of the form $mR+n$. |SQuotient<RT>| stores a two tuple
consisting of an |SPolynomial<RT>| and an |RT| object and represents
the corresponding quotient.

Our definition tells us that an extended point $p$ in homogeneous
representation has the form $(m_x R + n_x, m_y R + n_y, w)$, where $R$
is our frame defining variable and all other identifiers are numbers
from |RT|. |p.hx()| returns the x-polynomial $m_x R + n_x$ and
|p.hy()| the y-polynomial $m_y R + n_y$ (of type
|SPolynomial<RT>|). |p.hw()| returns $w$.  These are the homogeneous
$x$- and $y$- coordinates of $p$ with common denominator $w$. For
completeness $p$ also provides a Cartesian interface |p.x()| returning
an |SQuotient<RT>| of the form $(m_x R + n_x)/w$. In analogy $|p.y()|
= (m_y R + n_y)/w$.

All number entries of $p$ can be accessed as multi-precision numbers as
well as as double approximations stored in an interval of type
|CGAL::Interval_nt_advanced|. Thus a point stores 5 |RT| entries and
10 double precision entries. The number type interface consists of the
operations |p.mx()|, |p.nx()|, |p.my()|, |p.ny()|, |p.hw()|, and
|p.mxD()|, |p.nxD()|, |p.myD()|, |p.nyD()|, |p.hwD()| for the
intervals. The operation |p.is_standard()| returns true, iff both
$m_x$ and $m_y$ are zero.

The points are programmed along the lines of the LEDA and CGAL
geometric kernel design. They have I/O stream operators, and they can
be drawn in a LEDA window, when our frame parameter $R$ is fixed.
\begin{ignoreindiss}
<<simple polynomials>>=
template <typename RT>
class SPolynomial {
  RT _m,_n;
public:
  SPolynomial() : _m(),_n() {}
  SPolynomial(const RT& m, const RT& n) : _m(m),_n(n) {}
  SPolynomial(const RT& n) : _m(),_n(n) {}
  SPolynomial(const SPolynomial<RT>& p) : _m(p._m),_n(p._n) {}
  SPolynomial<RT>& operator=(const SPolynomial<RT>& p)
  { _m=p._m; _n=p._n; return *this; }

  const RT& m() const { return _m; }
  const RT& n() const { return _n; }
  void negate() { _m=-_m; _n=-_n; }

  SPolynomial<RT> operator*(const RT& c) const
  { return SPolynomial<RT>(c*_m,c*_n); }
  SPolynomial<RT> operator+(const SPolynomial<RT>& p) const
  { return SPolynomial<RT>(_m+p._m,_n+p._n); }
  SPolynomial<RT> operator-(const SPolynomial<RT>& p) const
  { return SPolynomial<RT>(_m-p._m,_n-p._n); }
  SPolynomial<RT> operator-() const
  { return SPolynomial<RT>(-_m,-_n); }
  void operator /= (const RT& c) 
  { _m /= c; _n /= c; } 
  const RT& operator[](int i) { return (i%2 ? _n : _m); }
  const RT& operator[](int i) const { return (i%2 ? _n : _m); }
  bool is_zero() const { return (_m==0 && _n==0); }
  int sign() const
  { if ( _m != 0 ) return CGAL_NTS sign(_m); 
    return CGAL_NTS sign(_n); }

  // only for visualization:
  static void set_R(const RT& R) { _R = R; }
  RT eval_at(const RT& r) const { return _m*r+_n; }
  RT eval_at_R() const { return _m*_R+_n; }
protected:
  static RT _R;
};

template <class RT> RT SPolynomial<RT>::_R;

template <typename RT>
int sign(const SPolynomial<RT>& p)
{ return p.sign(); }

template <typename RT>
bool operator==(const SPolynomial<RT>& p1, const SPolynomial<RT>& p2)
{ return (p1-p2).is_zero(); }

template <typename RT>
bool operator>(const SPolynomial<RT>& p1, const SPolynomial<RT>& p2)
{ return (p1-p2).sign()>0; }

template <typename RT>
bool operator<(const SPolynomial<RT>& p1, const SPolynomial<RT>& p2)
{ return (p1-p2).sign()<0; }

template <class RT> 
inline double to_double(const SPolynomial<RT>& p) 
{ return (CGAL::to_double(p.eval_at(SPolynomial<RT>::_R))); }

template <class RT> 
std::ostream& operator<<(std::ostream& os, const SPolynomial<RT>& p)
{ 
  switch( os.iword(CGAL::IO::mode) ) {
    case CGAL::IO::ASCII : 
      os << p.m() << " " << p.n(); break;
    case CGAL::IO::BINARY :
      CGAL::write(os,p.m());CGAL::write(os,p.n()); break;
    default:
      if ( p.m() == 0 ) os<<"["<<p.n()<<"]";
      else os<<"["<<p.m()<<" R + "<<p.n()<<"]"; 
  } 
  return os; 
}
template <class RT> 
std::istream& operator>>(std::istream& is, SPolynomial<RT>& p)
{ RT m,n; 
  switch( is.iword(CGAL::IO::mode) ){ 
    case CGAL::IO::ASCII : 
      is >> m >> n; p = SPolynomial<RT>(m,n); break;
    case CGAL::IO::BINARY :
      CGAL::read(is,m);CGAL::read(is,n);break;
    default:
    CGAL_assertion_msg(0,"\nStream must be in ascii or binary mode\n");
      break;  
  }
  return is; 
}

template <class RT> /*CGAL_KERNEL_INLINE*/ 
CGAL::io_Operator io_tag(const SPolynomial<RT>&) 
{ return CGAL::io_Operator(); }


@ We need a container quotient type to return cartesian coordinates.
We only need it for visualization and interface completion. It has no
number type functionality.
<<simple polynomials>>=
template <typename RT>
class SQuotient {
  SPolynomial<RT> _p;
  RT              _n;
public:
  SQuotient() : _p(),_n() {}
  SQuotient(const SPolynomial<RT>& p, const RT& n) : _p(p),_n(n) {}
  SQuotient(const SQuotient<RT>& p) : _p(p._p),_n(p._n) {}
  SQuotient<RT>& operator=(const SQuotient<RT>& p)
  { _p=p._p; _n=p._n; return *this; }
  const SPolynomial<RT>& numerator() const { return _p; }
  const RT&              denominator() const { return _n; }
};

template <class RT> 
inline double to_double(const SQuotient<RT>& q) 
{ return (CGAL::to_double(q.numerator().eval_at_R())/
          CGAL::to_double(q.denominator())); }


@ \end{ignoreindiss} 

Points are realized by a smart-pointer scheme.  There is a backend
object type |Extended_point_rep<RT>| (the representation) and a
frontend handle type |Extended_point<RT>|. We only elaborate on the
representation type. Details on smart pointers are offered in the
LEDA book \cite{ledabook}.
<<extended points>>=
template <typename RT> class Extended_point;
template <typename RT> class Extended_point_rep;

template <typename RT>
class Extended_point_rep {
  friend class Extended_point<RT>;
  SPolynomial<RT> x_,y_; RT w_;
  typedef Interval_nt_advanced DT;
  DT mxd,myd,nxd,nyd,wd;
public:
  <<construction>>
};

@ \newcommand{\OP}{\mathrm{\ op\ }}%
For the filter stage we use interval approximations of type
|CGAL::Interval_nt_advanced|. See H. Br{\"o}nnimann et.al
\cite{bbp-ia-98scg} for more information.  An object of this type is
an interval of two doubles representing any number in the interval. An
arithmetic operation |op| of $+$, $-$, $*$, $/$ on two intervals $X$
and $Y$ calculates an interval $X \OP Y$ such that $\forall x \in X, y
\in Y : (x \OP y) \in (X \OP Y)$. This allows us to determine the
correct sign of an interval expression as long as the interval does
not contain zero. The type uses exceptions to tell user code that a
sign determination does not lead to a secure result. That exception
can be catched to repair the resulting uncertainty. We will see how
this works in our predicates below. The type |Interval_nt_advanced|
implements dynamic filtering. Rounding errors are accumulated during
the execution of the program. The type requires its user to take the
responsibility for the rounding mode of the processor. Whenever an
arithmetic interval expression is evaluated the processor should be
in its correct rounding mode (switching the processor is an expensive
operation, thereby the user's care does pay-off). The switching is done by
class declaration statement |Protect_FPU_rounding<true> P|. The
construction of object |P| sets the correct rounding mode, its
destruction resets the previous mode which ensures correct execution
of code parts that rely on different rounding modes.

The following conversion routine constructs an interval that contains
a |double| approximation |cn| from its parameter |n| (a LEDA
|integer|). Only two cases can occur: |n| can be approximated
accurately by an interval $[cn,cn]$ of zero width if the bit
representation of |n| has less than $53$ bits. Otherwise we add the
smallest representable |double| to make the interval contain |n|. By
the addition the interval is expanded by exactly the radius of the
machine accuracy. For more information on rounding problems please
refer to D. Goldberg \cite{goldberg:csfloat}.
@c
DT to_interval(const leda_integer& n)
{ double cn = CGAL::to_double(n);
  leda_integer pn = ( n>0 ? n : -n);
  if ( pn.iszero() || log(pn) < 53 ) return DT(cn);
  else { 
    Protect_FPU_rounding<true> P;
    return DT(cn)+CGAL::Interval_base::Smallest;
  }
}

@ On construction of the representation we construct the |double|
approximation of the multi-precision entries. Note that we trade space
for execution time.
<<construction>>=
Extended_point_rep(const RT& x, const RT& y, const RT& w) :
  x_(x),y_(y),w_(w)
{ CGAL_assertion_msg(w!=0,"denominator is zero.");
  nxd=CGAL::to_interval(x);
  nyd=CGAL::to_interval(y);
  wd=CGAL::to_interval(w);
  mxd=myd=0;
}

Extended_point_rep(const SPolynomial<RT>& x, 
                   const SPolynomial<RT>& y, 
                   const RT& w) : x_(x),y_(y),w_(w)
{ CGAL_assertion_msg(w!=0,"denominator is zero.");
  mxd=CGAL::to_interval(x.m());
  myd=CGAL::to_interval(y.m());
  nxd=CGAL::to_interval(x.n());
  nyd=CGAL::to_interval(y.n());
  wd=CGAL::to_interval(w);
}

@ We do not show the implementation of the class |Extended_point<RT>|.
It mainly serves as an interface of the representation class and
inherits the handle maintainance code from the front end class
|CGAL::Handle_for|.
\begin{ignoreindiss}
<<construction>>=
Extended_point_rep() : x_(),y_(),w_() {}
~Extended_point_rep() {}
void negate() 
{ x_ = -x_; y_ = -y_; w_ = -w_; 
  mxd = -mxd; myd = -myd; nxd = -nxd; nyd = -nyd; wd = -wd; }

<<extended points>>=
template <typename RT_>
class Extended_point : public Handle_for< Extended_point_rep<RT_> > {
  typedef Extended_point_rep<RT_> Rep;
  typedef Handle_for< Rep >       Base;
public:
  typedef typename Rep::DT DT;
  typedef RT_ RT;
  typedef SPolynomial<RT>  SP;

  Extended_point() : Base( Rep() ) {}

  Extended_point(const RT& x, const RT& y, const RT& w) :
    Base( Rep(x,y,w) )
  { if (w < 0) ptr()->negate(); }
  
  Extended_point(const SPolynomial<RT>& x, 
                 const SPolynomial<RT>& y, 
                 const RT& w) : Base( Rep(x,y,w) )
  { if (w < 0) ptr()->negate(); }

  Extended_point(const RT& mx, const RT& nx,
                 const RT& my, const RT& ny, const RT& w) :
    Base( Rep(SP(mx,nx), SP(my,ny), w) )
  { if (w < 0) ptr()->negate(); }
  
  Extended_point(const Extended_point<RT>& p) : Base(p) {}
  ~Extended_point() {}

  Extended_point& operator=(const Extended_point<RT>& p) 
  { Base::operator=(p); return *this; }

  const RT& mx() const { return ptr()->x_.m(); }
  const RT& nx() const { return ptr()->x_.n(); }
  const RT& my() const { return ptr()->y_.m(); }
  const RT& ny() const { return ptr()->y_.n(); }
  const RT& hw()  const { return ptr()->w_; }
  const DT& mxD() const { return ptr()->mxd; }
  const DT& nxD() const { return ptr()->nxd; }
  const DT& myD() const { return ptr()->myd; }
  const DT& nyD() const { return ptr()->nyd; }
  const DT& hwD() const { return ptr()->wd; }

  SQuotient<RT> x() const 
  { return SQuotient<RT>(ptr()->x_, ptr()->w_); }
  SQuotient<RT> y() const 
  { return SQuotient<RT>(ptr()->y_, ptr()->w_); }

  const SPolynomial<RT> hx() const { return ptr()->x_; }
  const SPolynomial<RT> hy() const { return ptr()->y_; }

  bool is_standard() const { return (mx()==0)&&(my()==0); }
  Extended_point<RT> opposite() const 
  { return Extended_point<RT>(-mx(),nx(),-my(),ny(),w()); }

<<point check ops>>

};

template <class RT> 
std::ostream& operator<<(std::ostream& os, const Extended_point<RT>& p)
{ switch( os.iword(CGAL::IO::mode) ) {
    case CGAL::IO::ASCII : 
      os << p.hx() << " " << p.hy() << " " << p.hw(); break;
    case CGAL::IO::BINARY :
      CGAL::write(os,p.hx());CGAL::write(os,p.hy()); 
      CGAL::write(os,p.hw()); break;
    default:
      os << "(" << p.hx() << "," << p.hy() << "," << p.hw() << ")"; 
#if 0
      os << "((" << CGAL::to_double(p.nx())/CGAL::to_double(p.hw()) << "," 
         << CGAL::to_double(p.ny())/CGAL::to_double(p.hw()) << "))"; 
#endif
  } 
  return os; 
}
template <class RT> 
std::istream& operator>>(std::istream& is, Extended_point<RT>& p)
{ SPolynomial<RT> x,y; RT w;
  switch( is.iword(CGAL::IO::mode) ){ 
    case CGAL::IO::ASCII : 
      is >> x >> y >> w; break;
    case CGAL::IO::BINARY :
      CGAL::read(is,x);CGAL::read(is,y);CGAL::read(is,w); break;
    default:
    CGAL_assertion_msg(0,"\nStream must be in ascii or binary mode\n");
      break;  
  }
  p = Extended_point<RT>(x,y,w); 
  return is; 
}


@ \end{ignoreindiss} 
\subsection*{Predicates}
We show the implementation of the orientation predicate of extended
points. All other predicates follow the same strategy. For three
homogeneous points in polynomials we derive the formula for the
orientation determinant and build up a filter cascade. We implement
three template functions that code the unrolled coefficients of the
polynomial in $R$ of degree $2$. We do not prove the derivation of the
following algebraic expressions, we instead explain how we obtained
them. We used the math package Maple \cite{maple5-refman92} to do the
algebra. The following script executed in maple produces the code
expressions below. The lines with the comments have to be executed for
the corresponding indices.
@c
> pxi := mxi*R+nxi // i=1,2,3
> pyi := myi*R+nyi // i=1,2,3
> M := array([[px1,py1,w1],[px2,py2,w2],[px3,py3,w3]]);
> orient := collect(det(M),R);
> coeffi := coeff(orient,R,i); // i=0,1,2
> C(coeffi); // i=0,1,2

@ Finally just paste the coefficient code into the template functions.
The following operations code the coefficient of the squared, linear,
and constant term of the function in $R$ that is the result of the
determinant evaluation of $M$.
<<orientation predicate>>=
template <typename NT> inline
int orientation_coeff2(const NT& mx1, const NT& /*nx1*/, 
                       const NT& my1, const NT& /*ny1*/, const NT& w1,
                       const NT& mx2, const NT& /*nx2*/, 
                       const NT& my2, const NT& /*ny2*/, const NT& w2,
                       const NT& mx3, const NT& /*nx3*/, 
                       const NT& my3, const NT& /*ny3*/, const NT& w3) 
{
  NT coeff2 = mx1*w3*my2-mx1*w2*my3+mx3*w2*my1-
              mx2*w3*my1-mx3*w1*my2+mx2*w1*my3;
  return CGAL_NTS sign(coeff2);
}

template <typename NT> inline 
int orientation_coeff1(const NT& mx1, const NT& nx1, 
                       const NT& my1, const NT& ny1, const NT& w1,
                       const NT& mx2, const NT& nx2, 
                       const NT& my2, const NT& ny2, const NT& w2,
                       const NT& mx3, const NT& nx3, 
                       const NT& my3, const NT& ny3, const NT& w3) 
{
  NT coeff1 = mx1*w3*ny2-mx1*w2*ny3+nx1*w3*my2-mx2*w3*ny1-
              nx1*w2*my3+mx2*w1*ny3-nx2*w3*my1+mx3*w2*ny1+
              nx2*w1*my3-mx3*w1*ny2+nx3*w2*my1-nx3*w1*my2;
  return CGAL_NTS sign(coeff1);
}

template <typename NT> inline
int orientation_coeff0(const NT& /*mx1*/, const NT& nx1, 
                       const NT& /*my1*/, const NT& ny1, const NT& w1,
                       const NT& /*mx2*/, const NT& nx2, 
                       const NT& /*my2*/, const NT& ny2, const NT& w2,
                       const NT& /*mx3*/, const NT& nx3, 
                       const NT& /*my3*/, const NT& ny3, const NT& w3) 
{
  NT coeff0 = -nx2*w3*ny1+nx1*w3*ny2+nx2*w1*ny3-
               nx1*w2*ny3+nx3*w2*ny1-nx3*w1*ny2;
  return CGAL_NTS sign(coeff0);
}

@ \begin{ignoreindiss}
<<orientation predicate>>=
DEFCOUNTER(or0)
DEFCOUNTER(or1)
DEFCOUNTER(or2)
@ \end{ignoreindiss} 

Now the final orientation predicate consists of three |try|-|catch|
blocks. Each |try| block contains the filtered coefficient evaluation.
If the sign evaluation is not defined (the resulting interval contains
zero) then the |Uncertain_conversion_exception| exception is thrown. The |catch|
block evaluates the expression with |RT| arithmetic. Note again the
protection of the rounding mode with the |Protect_FPU_rounding<true>|
class declaration. The macros |INCTOTAL()| and |INCEXCEPTION()| are
used to accumulate the statistics of the filter stages.
<<orientation predicate>>=
template <typename RT>
int orientation(const Extended_point<RT>& p1, 
                const Extended_point<RT>& p2, 
                const Extended_point<RT>& p3) 
{ TRACEN("orientation "<<p1<<p2<<p3);
  int res;
  try { INCTOTAL(or2); Protect_FPU_rounding<true> Protection;
    res = orientation_coeff2(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                             p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                             p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(or2);
    res = orientation_coeff2(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                             p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                             p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(or1); Protect_FPU_rounding<true> Protection;
    res = orientation_coeff1(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                             p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                             p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(or1);
    res = orientation_coeff1(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                             p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                             p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(or0); Protect_FPU_rounding<true> Protection;
    res = orientation_coeff0(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                             p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                             p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(or0);
    res = orientation_coeff0(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                             p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                             p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw());
  }
  return res;
}

@ Corresponding implementations are provided for the predicates
|compare_x()|, |compare_y()|, |compare_xy()|, and
|compare_pair_dist()|.  The latter realizes the squared distance
comparison of two pairs of points. The resulting polynomial has again
degree $2$ but contains more complicated expressions than the
orientation predicate above.
\begin{ignoreindiss}
<<comparison predicate>>=
template <typename NT> 
inline
int compare_expr(const NT& n1, const NT& d1, 
                 const NT& n2, const NT& d2)
{ return CGAL_NTS sign( n1*d2 - n2*d1 ); }

DEFCOUNTER(cmpx0)
DEFCOUNTER(cmpx1)

template <typename RT>
int compare_x(const Extended_point<RT>& p1, 
              const Extended_point<RT>& p2) 
{
  int res;
  try { INCTOTAL(cmpx1); Protect_FPU_rounding<true> Protection;
    res = compare_expr(p1.mxD(),p1.hwD(),p2.mxD(),p2.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmpx1);
    res = compare_expr(p1.mx(),p1.hw(),p2.mx(),p2.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(cmpx0); Protect_FPU_rounding<true> Protection;
    res = compare_expr(p1.nxD(),p1.hwD(),p2.nxD(),p2.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmpx0);
    res = compare_expr(p1.nx(),p1.hw(),p2.nx(),p2.hw());
  }
  return res;  
}

DEFCOUNTER(cmpy0)
DEFCOUNTER(cmpy1)

template <typename RT>
int compare_y(const Extended_point<RT>& p1, 
              const Extended_point<RT>& p2) 
{
  int res;
  try { INCTOTAL(cmpy1); Protect_FPU_rounding<true> Protection;
    res = compare_expr(p1.myD(),p1.hwD(),p2.myD(),p2.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmpy1);
    res = compare_expr(p1.my(),p1.hw(),p2.my(),p2.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(cmpy0); Protect_FPU_rounding<true> Protection;
    res = compare_expr(p1.nyD(),p1.hwD(),p2.nyD(),p2.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmpy0);
    res = compare_expr(p1.ny(),p1.hw(),p2.ny(),p2.hw());
  }
  return res;  
}


template <typename RT>
inline
int compare_xy(const Extended_point<RT>& p1, 
               const Extended_point<RT>& p2) 
{ int c1 = compare_x(p1,p2);
  if ( c1 != 0 ) return c1;
  else return compare_y(p1,p2);
}

template <typename RT>
inline
bool strictly_ordered_along_line(const Extended_point<RT>& p1, 
                                 const Extended_point<RT>& p2, 
                                 const Extended_point<RT>& p3) 
{ return ( orientation(p1,p2,p3) == 0 ) &&
         ( compare_xy(p1,p2) * compare_xy(p2,p3) == 1 );
}

template <typename RT>
inline bool operator==(const Extended_point<RT>& p1, 
                       const Extended_point<RT>& p2) 
{ CHECK(bool(compare_xy(p1,p2) == 0),p1.checkrep()==p2.checkrep())
  return (p1.identical(p2) || compare_xy(p1,p2) == 0); }

template <typename RT>
inline bool operator!=(const Extended_point<RT>& p1, 
                       const Extended_point<RT>& p2) 
{ return !(p1==p2); }


template <typename NT> 
inline
int cmppd_coeff2(const NT& mx1, const NT& /*nx1*/, 
                 const NT& my1, const NT& /*ny1*/, const NT& w1,
                 const NT& mx2, const NT& /*nx2*/, 
                 const NT& my2, const NT& /*ny2*/, const NT& w2,
                 const NT& mx3, const NT& /*nx3*/, 
                 const NT& my3, const NT& /*ny3*/, const NT& w3, 
                 const NT& mx4, const NT& /*nx4*/, 
                 const NT& my4, const NT& /*ny4*/, const NT& w4) 
{ 
  NT w1Q(w1*w1), w2Q(w2*w2), w3Q(w3*w3), w4Q(w4*w4);
  NT w1w2Q(w1Q*w2Q), w3w4Q(w3Q*w4Q), two(2);
  NT coeff2 =    w3w4Q * w2Q *mx1*mx1-
                 two* w3w4Q  *w2*mx1*w1*mx2+
                 w3w4Q * w1Q *mx2*mx2+
                 w3w4Q * w2Q *my1*my1-
                 two* w3w4Q  *w2*my1*w1*my2+
                 w3w4Q * w1Q *my2*my2-
                 w1w2Q * w4Q *mx3*mx3+
                 two* w1w2Q  *w4*mx3*w3*mx4-
                 w1w2Q * w3Q *mx4*mx4-
                 w1w2Q * w4Q *my3*my3+
                 two* w1w2Q  *w4*my3*w3*my4-
                 w1w2Q * w3Q *my4*my4;
  return CGAL_NTS sign(coeff2);  
}


template <typename NT> 
inline
int cmppd_coeff1(const NT& mx1, const NT& nx1, 
                 const NT& my1, const NT& ny1, const NT& w1,
                 const NT& mx2, const NT& nx2, 
                 const NT& my2, const NT& ny2, const NT& w2,
                 const NT& mx3, const NT& nx3, 
                 const NT& my3, const NT& ny3, const NT& w3, 
                 const NT& mx4, const NT& nx4, 
                 const NT& my4, const NT& ny4, const NT& w4) 
{ 
  NT w1Q(w1*w1), w2Q(w2*w2), w3Q(w3*w3), w4Q(w4*w4);
  NT w1w2Q(w1Q*w2Q), w3w4Q(w3Q*w4Q), two(2);
  NT coeff1 = two * (w3w4Q * w1Q * mx2*nx2-
                     w3w4Q * w2*my1*w1*ny2+
                     w3w4Q * w1Q * my2*ny2+
                     w1w2Q * w4*nx3*w3*mx4-
                     w1w2Q * w4Q *mx3*nx3+
                     w3w4Q * w2Q *mx1*nx1-
                     w3w4Q * w2*mx1*w1*nx2-
                     w3w4Q * w2*nx1*w1*mx2-
                     w3w4Q * w2*ny1*w1*my2-
                     w1w2Q * w4Q *my3*ny3+
                     w1w2Q * w4*my3*w3*ny4+
                     w1w2Q * w4*ny3*w3*my4+
                     w3w4Q * w2Q *my1*ny1-
                     w1w2Q * w3Q *my4*ny4+
                     w1w2Q * w4*mx3*w3*nx4-
                     w1w2Q * w3Q *mx4*nx4);
  return CGAL_NTS sign(coeff1);
}

template <typename NT> 
inline
int cmppd_coeff0(const NT& /*mx1*/, const NT& nx1, 
                 const NT& /*my1*/, const NT& ny1, const NT& w1,
                 const NT& /*mx2*/, const NT& nx2, 
                 const NT& /*my2*/, const NT& ny2, const NT& w2,
                 const NT& /*mx3*/, const NT& nx3, 
                 const NT& /*my3*/, const NT& ny3, const NT& w3, 
                 const NT& /*mx4*/, const NT& nx4, 
                 const NT& /*my4*/, const NT& ny4, const NT& w4) 
{ 
  NT w1Q(w1*w1), w2Q(w2*w2), w3Q(w3*w3), w4Q(w4*w4);
  NT w1w2Q(w1Q*w2Q), w3w4Q(w3Q*w4Q), two(2);
  NT coeff0 = w3w4Q * (w1Q * ( nx2*nx2 + ny2*ny2 ) +
                       w2Q * ( ny1*ny1 + nx1*nx1 )) -
              w1w2Q * (w4Q * ( nx3*nx3 + ny3*ny3 ) +
                       w3Q * ( nx4*nx4 + ny4*ny4 )) +
              two* (- w3w4Q * (w2*nx1*w1*nx2 + w2*ny1*w1*ny2) 
                    + w1w2Q * (w4*ny3*w3*ny4 + w4*nx3*w3*nx4));
  return CGAL_NTS sign(coeff0);
}

DEFCOUNTER(cmppd2)
DEFCOUNTER(cmppd1)
DEFCOUNTER(cmppd0)

// leghth.mws
template <typename RT>
int compare_pair_dist(
  const Extended_point<RT>& p1, const Extended_point<RT>& p2, 
  const Extended_point<RT>& p3, const Extended_point<RT>& p4) 
{ 
  int res;
  try { INCTOTAL(cmppd2); Protect_FPU_rounding<true> Protection;
    res = cmppd_coeff2(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                       p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                       p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD(),
                       p4.mxD(),p4.nxD(),p4.myD(),p4.nyD(),p4.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmppd2);
    res = cmppd_coeff2(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                       p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                       p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw(),
                       p4.mx(),p4.nx(),p4.my(),p4.ny(),p4.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(cmppd1); Protect_FPU_rounding<true> Protection;
    res = cmppd_coeff1(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                       p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                       p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD(),
                       p4.mxD(),p4.nxD(),p4.myD(),p4.nyD(),p4.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmppd1);
    res = cmppd_coeff1(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                       p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                       p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw(),
                       p4.mx(),p4.nx(),p4.my(),p4.ny(),p4.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(cmppd0); Protect_FPU_rounding<true> Protection;
    res = cmppd_coeff0(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                       p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                       p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD(),
                       p4.mxD(),p4.nxD(),p4.myD(),p4.nyD(),p4.hwD());
  }
  catch (Uncertain_conversion_exception) { INCEXCEPTION(cmppd0);
    res = cmppd_coeff0(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                       p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                       p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw(),
                       p4.mx(),p4.nx(),p4.my(),p4.ny(),p4.hw());
  }
  return res;
}


@ \end{ignoreindiss}
\subsection*{Extended segments and intersection}

We provide extended segments and some primitives. We mostly
concentrate on the intersection predicate of lines supported by
non-trivial extended segments. In this implementation we want to avoid
the calculation of the polynomial |gcd|. Therefore, we extract the
possible intersection configurations in advance and avoid higher
degree polynomials resulting from the general algebraic term.
<<extended segments>>=
template <typename RT>
class Extended_segment {
  Extended_point<RT> _p1,_p2;
public:
  Extended_segment() : _p1(),_p2() {}
  Extended_segment(const Extended_point<RT>& p1,
                   const Extended_point<RT>& p2) : 
    _p1(p1), _p2(p2) {}
  Extended_segment(const Extended_segment<RT>& s) :
    _p1(s._p1), _p2(s._p2) {}
  Extended_segment<RT>& operator=(const Extended_segment<RT>& s)
  { _p1 = s._p1; _p2 = s._p2; return *this; }

  const Extended_point<RT>& source() const { return _p1; }
  const Extended_point<RT>& target() const { return _p2; }

  void line_equation(RT& a, RT& b, SPolynomial<RT>& c) const;
};

@ \begin{ignoreindiss}
<<extended segments>>=
template <class RT> 
std::ostream& operator<<(std::ostream& os, const Extended_segment<RT>& s)
{ os << s.source() << s.target(); return os; }
template <class RT> 
std::istream& operator>>(std::istream& is, Extended_segment<RT>& s)
{ Extended_point<RT> p1,p2;
  is >> p1 >> p2; s=Extended_segment<RT>(p1,p2); return is; }

@ \end{ignoreindiss}%
We extract the line equation $ax + by + c = 0$ directly from
non-standard points if the extended segment is just a segment.  Note
that for all lines crossing the interior of our box $a, b,c$ are just
constants from our integer ring type |RT|. However the frame segments
also support lines of the from $x \pm R = 0$ and $y \pm R = 0$.
Therefore, we allow a linear polynomial for the coefficient $c$.
<<extended segment primitives>>=
template <typename RT>
void Extended_segment<RT>::
line_equation(RT& a, RT& b, SPolynomial<RT>& c) const
{
  bool sstandard = _p1.is_standard();
  bool tstandard = _p2.is_standard();
  if (sstandard && tstandard) {
    <<standard segment>>
  }
  Extended_point<RT> p;
  bool correct_orientation=true;
  if (!sstandard && !tstandard) {
    <<two points on the frame box>>
  } 
  else if (sstandard && !tstandard) 
  { p = _p2; }
  else if (!sstandard && tstandard) 
  { p = _p1; correct_orientation=false; }
  <<one point on the frame box>>

}

@ If two points span a standard segment then the three coefficients of
the line through the points can be derived from the following
determinant equation (just resolve for the variables in the last row).
\begin{eqnarray*}
\begin{vmatrix}
 x1 & y1 & w1 \\
 x2 & y2 & w2 \\
  a &  b & c 
\end{vmatrix} 
& = & 0
\end{eqnarray*}. 
<<standard segment>>=
a = _p1.ny()*_p2.hw() - _p2.ny()*_p1.hw();
b = _p1.hw()*_p2.nx() - _p2.hw()*_p1.nx();
c = SPolynomial<RT>(_p1.nx()*_p2.ny() - _p2.nx()*_p1.ny());
return;

@ Two points on the box produce two basic configurations. Either the
points are both on one frame segment. Or they are part of one affine
line crossing the box. If they lie on the same frame segment then
their corresponding coordinate polynomials are equal in homogeneous
representation and equal to $\pm R$. Note that we keep the algebraic
calculation within the polynomials of degree less than 2. When both
points lie on the same frame segment then the minimal representation
of the corresponding coordinate polynomial is $\pm 1R+0$. This leads
to line equations of the form $0x + 1y + \mp R = 0$ when the
y-coordinates are equal and to $1x + 0y + \mp R = 0$ when the
x-coordinates are equal. In case that the points span a standard
affine line we forward the treatment to the mixed case by setting $p$
to one of the points.
<<two points on the frame box>>=
bool x_equal = (_p1.hx()*_p2.hw() - _p2.hx()*_p1.hw()).is_zero();
bool y_equal = (_p1.hy()*_p2.hw() - _p2.hy()*_p1.hw()).is_zero();
if (x_equal && CGAL_NTS abs(_p1.mx())==_p1.hw() && _p1.nx()==0 ) 
{ int dy = (_p2.hy()-_p1.hy()).sign(); 
  a=-dy; b=0; c = SPolynomial<RT>(dy*_p1.hx().sign(),0); return; }
if (y_equal && CGAL_NTS abs(_p1.my())==_p1.hw() && _p1.ny()==0 ) 
{ int dx = (_p2.hx()-_p1.hx()).sign(); 
  a=0; b=dx; c = SPolynomial<RT>(-dx*_p1.hy().sign(),0); return; }
p = _p2; // evaluation according to mixed case

@ Finally we have the point $p$ at the tip of a line (somewhere on the
frame box).  Obviously we can extract the affine equation of the line
from the polynomial representation. We just set the parameter $R$ to
$0$ and $1$, obtain two points, and calculate the equation. Note that
by the special structure of our non-standard points the $2\times2$
determinants reduce nicely. |p.hw()| is a common factor of all
coefficients $a, b, c$ of the line:
\[ a = y_1 w_1 - y_2 w_1, b = x_2 w_1 - x_1 w_2, c = x_1 y_2 - x_2 y_1\]
where 
\[ x_1 = |p.nx()|, y_1 = |p.ny()|, w_1 = |p.hw()|,
x_2 = |p.mx() + p.nx()|, y_2 = |p.my() + p.ny()|, w_2 = |p.hw()| \]
For $a$ and $b$ it is obvious that |p.hw()| can be canceled out, and
the difference simplified.  $c$ can be reduced to |p.nx()*p.my() -
p.ny()*p.mx()| due to the special choice of our points. Remember that
for non-standard points either their x- or y-coordinate is equal to
$\pm R$. In the homogeneous representation this means that either
$|p.mx()| = \pm |p.hw()|$ and $|p.nx()| = 0$, or $|p.my()| = \pm
|p.hw()|$ and $|p.ny()| = 0$. In either case one can safely divide by
|p.hw()|.
<<one point on the frame box>>=
RT x1 = p.nx(), y1 = p.ny();               // R==0
RT x2 = p.mx()+p.nx(), y2 = p.my()+p.ny(); // R==1
RT w = p.hw();
RT ci;
if ( correct_orientation ) {
  a = -p.my(); // (y1*w-w*y2)/w
  b =  p.mx(); // (x2*w-w*x1)/w
  ci = (p.nx()*p.my()-p.ny()*p.mx())/w; // (x1*y2-x2*y1)/w;
} else {
  a =  p.my(); // (y2*w-w*y1)
  b = -p.mx(); // (x1*w-w*x2)
  ci = (p.ny()*p.mx()-p.nx()*p.my())/w; // (x2*y1-x1*y2)/w;
}
c = SPolynomial<RT>(ci);


@ We finally provide the intersection construction of two lines
supported by two segments. We use the linear system that defines the
common point of two lines.
\begin{eqnarray*}
\begin{pmatrix}
 a1 & b1 \\
 a2 & b2 
\end{pmatrix} 
\begin{pmatrix} x \\ y \end{pmatrix} & = & 
%{x \choose y} & = & 
\begin{pmatrix} -c_1 \\ -c_2 \end{pmatrix} 
%{-c1 \choose -c2}
\end{eqnarray*}
Note that the line equations are either standard affine lines or lines
supporting box segments. The expressions for $x$ and $y$ are
polynomials in $R$ up to degree $1$, for $w$ it is just a constant.
<<extended segment primitives>>=
template <typename RT>
Extended_point<RT> intersection(
  const Extended_segment<RT>& s1, const Extended_segment<RT>& s2)
{ 
  RT a1,b1,a2,b2;
  SPolynomial<RT> c1,c2;
  s1.line_equation(a1,b1,c1);
  s2.line_equation(a2,b2,c2);
  SPolynomial<RT> x = c2*b1 - c1*b2;
  SPolynomial<RT> y = c1*a2 - c2*a1;
  RT w = a1*b2 - a2*b1; CGAL_assertion(w!=0);
  <<reduce point representation by gcd operation>>
  return Extended_point<RT>(x,y,w);
}

@ We introduce an option that allows us to reduce the homogeneous
representation of points by dividing both polynomials by the gcd of
their content\footnote{Remember: the content of a polynomial is the
gcd of all nonzero coefficients.} and their common denominator. This
leads to a representation of minimal bitlength. We found that this
reduction pays off a lot. Remember that we use the kernel in binary
operations of Nef polyhedra and their recursive usage of intermediate
structures accumulates long point representations without this
reduction.
<<reduce point representation by gcd operation>>=
#ifdef REDUCE_INTERSECTION_POINTS
RT xgcd,ygcd;
if ( x.m() == RT(0) )  xgcd = ( x.n() == 0 ? RT(1) : x.n() ); 
else /* != 0 */    xgcd = ( x.n() == 0 ? x.m() : gcd(x.m(),x.n()) ); 
if ( y.m() == RT(0) )  ygcd = ( y.n() == 0 ? RT(1) : y.n() ); 
else /* != 0 */    ygcd = ( y.n() == 0 ? y.m() : gcd(y.m(),y.n()) ); 
RT d = gcd(w,gcd(xgcd,ygcd));
x /= d;
y /= d;
w /= d;
#endif // REDUCE_INTERSECTION_POINTS
@ \begin{ignoreindiss}
We introduce the two primitives |orientation| and |is_degenerate|
for user comfort. The |contains| predicate checks if a point is part
of a relatively closed segment.
<<extended segment primitives>>=
template <typename RT>
inline
int orientation(const Extended_segment<RT>& s, const Extended_point<RT>& p) 
{ return orientation(s.source(),s.target(),p); }

template <typename RT>
inline
bool is_degenerate(const Extended_segment<RT>& s)
{ return s.source()==s.target(); }

template <typename RT>
inline
bool contains(const Extended_segment<RT>& s, 
              const Extended_point<RT>& p) 
{ int p_rel_source = compare_xy(p,s.source());
  int p_rel_target = compare_xy(p,s.target());
  return ( orientation(s,p) == 0 ) &&
         ( p_rel_source >= 0 && p_rel_target <= 0 ||
           p_rel_source <= 0 && p_rel_target >= 0 );
}


@ \subsection*{Direction predicates}

<<extended directions>>=
template <typename RT>
class Extended_direction {
  Extended_point<RT> _p1,_p2;
public:
  Extended_direction() : _p1(),_p2() {}
  Extended_direction(const Extended_direction<RT>& d) :
    _p1(d._p1),_p2(d._p2) {}
  Extended_direction<RT>& operator=(const Extended_direction<RT>& d) 
  { _p1 = d._p1; _p2 = d._p2; return *this; }

  Extended_direction(const Extended_point<RT>& p1,
                     const Extended_point<RT>& p2) :
    _p1(p1),_p2(p2) {}

  Extended_direction(const RT& x, const RT& y) :
    _p1(0,0,1),_p2(x,y,1) {}
  
  const Extended_point<RT>& p1() const { return _p1; }
  const Extended_point<RT>& p2() const { return _p2; }
  int dx_sign() const 
  { return (_p2.hx()*_p1.hw()-_p1.hx()*_p2.hw()).sign(); }
  int dy_sign() const 
  { return (_p2.hy()*_p1.hw()-_p1.hy()*_p2.hw()).sign(); }
};

template <class RT> 
std::ostream& operator<<(std::ostream& os, const Extended_direction<RT>& d)
{ os << d.p1() << "," << d.p2(); 
  return os; }
template <class RT> 
std::istream& operator>>(std::istream& is, Extended_direction<RT>& d)
{ Extended_point<RT> x,y;
  is >> x >> y; d = Extended_direction<RT>(x,y); 
  return is; }


<<direction predicates>>=
template <typename NT>
inline
int coeff2_dor(const NT& mx1, const NT& /*nx1*/, 
               const NT& my1, const NT& /*ny1*/, const NT& w1,
               const NT& mx2, const NT& /*nx2*/, 
               const NT& my2, const NT& /*ny2*/, const NT& w2,
               const NT& mx3, const NT& /*nx3*/, 
               const NT& my3, const NT& /*ny3*/, const NT& w3, 
               const NT& mx4, const NT& /*nx4*/, 
               const NT& my4, const NT& /*ny4*/, const NT& w4) 
{
  NT coeff2 = w1*mx2*w3*my4-w1*mx2*w4*my3-w2*mx1*w3*my4+w2*mx1*w4*my3-
              w1*my2*w3*mx4+w1*my2*w4*mx3+w2*my1*w3*mx4-w2*my1*w4*mx3;
  return CGAL_NTS sign(coeff2);
}

template <typename NT>
inline
int coeff1_dor(const NT& mx1, const NT& nx1, 
               const NT& my1, const NT& ny1, const NT& w1,
               const NT& mx2, const NT& nx2, 
               const NT& my2, const NT& ny2, const NT& w2,
               const NT& mx3, const NT& nx3, 
               const NT& my3, const NT& ny3, const NT& w3, 
               const NT& mx4, const NT& nx4, 
               const NT& my4, const NT& ny4, const NT& w4)
{
  NT coeff1 = -w1*my2*w3*nx4+w1*mx2*w3*ny4+w1*my2*w4*nx3-w1*mx2*w4*ny3+
               w1*nx2*w3*my4-w1*nx2*w4*my3+w2*my1*w3*nx4-w2*mx1*w3*ny4-
               w2*my1*w4*nx3+w2*mx1*w4*ny3-w2*nx1*w3*my4+w2*nx1*w4*my3-
               w1*ny2*w3*mx4+w1*ny2*w4*mx3+w2*ny1*w3*mx4-w2*ny1*w4*mx3;
  return CGAL_NTS sign(coeff1);
}

template <typename NT>
inline
int coeff0_dor(const NT& /*mx1*/, const NT& nx1, 
               const NT& /*my1*/, const NT& ny1, const NT& w1,
               const NT& /*mx2*/, const NT& nx2, 
               const NT& /*my2*/, const NT& ny2, const NT& w2,
               const NT& /*mx3*/, const NT& nx3, 
               const NT& /*my3*/, const NT& ny3, const NT& w3, 
               const NT& /*mx4*/, const NT& nx4, 
               const NT& /*my4*/, const NT& ny4, const NT& w4)
{
  NT coeff0 = w1*nx2*w3*ny4-w1*nx2*w4*ny3-w2*nx1*w3*ny4+w2*nx1*w4*ny3-
              w1*ny2*w3*nx4+w1*ny2*w4*nx3+w2*ny1*w3*nx4-w2*ny1*w4*nx3;
  return CGAL_NTS sign(coeff0);
}

DEFCOUNTER(ord2)
DEFCOUNTER(ord1)
DEFCOUNTER(ord0)


template <typename RT>
inline
int orientation(const Extended_direction<RT>& d1,
                const Extended_direction<RT>& d2)
{ 
  Extended_point<RT> p1(d1.p1()), p2(d1.p2()),
                     p3(d2.p1()), p4(d2.p2());
  int res;
  try { INCTOTAL(ord2); Protect_FPU_rounding<true> Protection;
    res = coeff2_dor(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                     p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                     p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD(),
                     p4.mxD(),p4.nxD(),p4.myD(),p4.nyD(),p4.hwD());
  } catch (Uncertain_conversion_exception) { INCEXCEPTION(ord2);
    res = coeff2_dor(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                     p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                     p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw(),
                     p4.mx(),p4.nx(),p4.my(),p4.ny(),p4.hw());
  }
  if ( res != 0 ) return res; 

  try { INCTOTAL(ord1); Protect_FPU_rounding<true> Protection;
    res = coeff1_dor(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                     p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                     p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD(),
                     p4.mxD(),p4.nxD(),p4.myD(),p4.nyD(),p4.hwD());
  } catch (Uncertain_conversion_exception) { INCEXCEPTION(ord1);
    res = coeff1_dor(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                     p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                     p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw(),
                     p4.mx(),p4.nx(),p4.my(),p4.ny(),p4.hw());
  }
  if ( res != 0 ) return res; 
  try { INCTOTAL(ord0); Protect_FPU_rounding<true> Protection;
    res = coeff0_dor(p1.mxD(),p1.nxD(),p1.myD(),p1.nyD(),p1.hwD(),
                     p2.mxD(),p2.nxD(),p2.myD(),p2.nyD(),p2.hwD(),
                     p3.mxD(),p3.nxD(),p3.myD(),p3.nyD(),p3.hwD(),
                     p4.mxD(),p4.nxD(),p4.myD(),p4.nyD(),p4.hwD());
  } catch (Uncertain_conversion_exception) { INCEXCEPTION(ord0);
    res = coeff0_dor(p1.mx(),p1.nx(),p1.my(),p1.ny(),p1.hw(),
                     p2.mx(),p2.nx(),p2.my(),p2.ny(),p2.hw(),
                     p3.mx(),p3.nx(),p3.my(),p3.ny(),p3.hw(),
                     p4.mx(),p4.nx(),p4.my(),p4.ny(),p4.hw());
  }
  return res;
}

@ In affine geometry two directions are equal iff
@c
d1.dx()*d2.dy() == d1.dy()*d2.dx() &&
sign(d1.dx()) == sign(d2.dx()) &&
sign(d1.dy()) == sign(d2.dy())

@ We thus translate the first into a filtered determinant expression
and check the second and third line directly.
<<direction predicates>>=
template <typename RT>
inline
bool operator==(const Extended_direction<RT>& d1,
                const Extended_direction<RT>& d2)
{
  return orientation(d1,d2) == 0 &&
         d1.dx_sign() == d2.dx_sign() &&
         d1.dy_sign() == d2.dy_sign();
}

template <typename RT>
inline
bool operator!=(const Extended_direction<RT>& d1,
                const Extended_direction<RT>& d2)
{ return !(d1==d2); }


template <typename RT>
bool strictly_ordered_ccw(const Extended_direction<RT>& d1,
                          const Extended_direction<RT>& d2,
                          const Extended_direction<RT>& d3)
{ 
  if (d1 == d3) return (d1 != d2);
  int or12 = orientation(d1,d2);
  int or13 = orientation(d1,d3);
  int or32 = orientation(d3,d2);
  if ( or13 >= 0 ) // not right_turn
    return ( or12 > 0 && or32 < 0 );
  else // ( or13 < 0 ) right_turn
    return ( or12 > 0 || or32 < 0 );
}

template <typename RT>
inline
bool operator<(const Extended_direction<RT>& d1,
               const Extended_direction<RT>& d2)
{ Extended_direction<RT> d0(1,0);
  bool d0d1eq = (d1 == d0);
  bool d0d2eq = (d2 == d0);
  return (d0d1eq && !d0d2eq) ||
         strictly_ordered_ccw(d0,d1,d2) && !d0d2eq;
}

@ \end{ignoreindiss}
\subsection*{The kernel wrapper}

All operations are either mapped to the above primitives or similar to
the ones in the default homogeneous kernel. We do not present the
layout of the kernel class |Filtered_extended_homogeneous<RT>|. It is
similar to |Extended_homogeneous<RT>|. We only present the usefulness
of |Extended_homogeneous<RT>| with respect to checking of our advanced
kernel. We used the naive approach to back-up the results of our
filtered code. As the expressions in this code base are much more
complicated, errors were hard to determine. We enriched the filtered
kernel by checking statements that we switched on when runtime
examples seemed to produce problems. (Of course we had to log our
random test inputs to allow checking in case of errors). When switched
on by using the compile flag |KERNEL_CHECK| our checking macro is
defined to be
@c
#define CHECK(c1,c2) CGAL_assertion((c1) == (c2));

@ Then the orientation member of |Filtered_extended_homogeneous<RT>|
is just defined as:
@c
int orientation(const Point_2& p1, const Point_2& p2, const Point_2& p3) 
const
{ CHECK(K.orientation(p1.checkrep(),p2.checkrep(),p3.checkrep()),
        CGAL::orientation(p1,p2,p3))
  return CGAL::orientation(p1,p2,p3); }

@ where |Point_2| is the extended point type in the local scope of
|Filtered_extended_homogeneous<RT>|. |p.checkrep()| returns an
extended point of type |Extended_homogeneous<RT>::Point_2| based on
the |Polynomial<RT>| number type. And |K| is a kernel object of type
|Extended_homogeneous<RT>| in the local scope.

At last the filtered kernel has a member method |print_statistics()|
that outputs the total number of failed filter stages in its base
version.  If the kernel is used with the compile flag
|KERNEL_ANALYSIS| then each filtered code section is evaluated
separately. All sections give the number of failed stages and the
number of total evaluations thereby the efficiency of the filter can
be evaluated with respect to the input used. This ends the description
of the filtered extended kernel model.

\begin{ignoreindiss}
<<extended kernel>>=

template <typename RT_>
class Filtered_extended_homogeneous {
typedef Filtered_extended_homogeneous<RT_> Self;

public:
typedef CGAL::Homogeneous<RT_> Standard_kernel;
typedef typename Standard_kernel::RT           Standard_RT;
typedef typename Standard_kernel::FT           Standard_FT;
typedef typename Standard_kernel::Point_2      Standard_point_2;
typedef typename Standard_kernel::Segment_2    Standard_segment_2;
typedef typename Standard_kernel::Line_2       Standard_line_2;
typedef typename Standard_kernel::Direction_2  Standard_direction_2;
typedef typename Standard_kernel::Ray_2        Standard_ray_2;
typedef typename Standard_kernel::Aff_transformation_2 
  Standard_aff_transformation_2;

typedef SPolynomial<RT_>        RT;
typedef SQuotient<RT_>          FT;
typedef Extended_point<RT_>     Point_2;
typedef Extended_segment<RT_>   Segment_2;
typedef Extended_direction<RT_> Direction_2;
<<kernel check ops>>

enum Point_type { SWCORNER=1, LEFTFRAME, NWCORNER, 
                  BOTTOMFRAME, STANDARD, TOPFRAME,
                  SECORNER, RIGHTFRAME, NECORNER };

<<extended filtered homogeneous kernel members>>

};


<<extended filtered homogeneous kernel members>>=
Standard_RT dx(const Standard_line_2& l) const { return l.b(); }
Standard_RT dy(const Standard_line_2& l) const { return -l.a(); }
Standard_FT abscissa_distance(const Standard_line_2& l) const 
{ return Standard_kernel::make_FT(-l.c(),l.b()); }

Point_type determine_type(const Standard_line_2& l) const
{
  // TRACEN("determine_type "<<l);
  Standard_RT adx = CGAL_NTS abs(dx(l)), ady = CGAL_NTS abs(dy(l));
  int sdx = CGAL_NTS sign(dx(l)), sdy = CGAL_NTS sign(dy(l));
  int cmp_dx_dy = CGAL_NTS compare(adx,ady), s(1);
  // TRACEN("   "<<cmp_dx_dy<<" "<<sdx<<" "<<sdy);
  if (sdx < 0 && ( cmp_dx_dy > 0 || cmp_dx_dy == 0 && 
      sdy != (s=CGAL_NTS sign(abscissa_distance(l))))) {
    if (0 == s) return ( sdy < 0 ? SWCORNER : NWCORNER );
    else        return LEFTFRAME;
  } else if (sdx > 0 && ( cmp_dx_dy > 0 || cmp_dx_dy == 0 && 
             sdy != (s=CGAL_NTS sign(abscissa_distance(l))))) { 
    if (0 == s) return ( sdy < 0 ? SECORNER : NECORNER );
    else        return RIGHTFRAME;
  } else if (sdy < 0 && ( cmp_dx_dy < 0 || cmp_dx_dy == 0 && 
             abscissa_distance(l) < Standard_FT(0))) {
    return BOTTOMFRAME;
  } else if (sdy > 0 && ( cmp_dx_dy < 0 || cmp_dx_dy == 0 && 
             abscissa_distance(l) > Standard_FT(0))) {
    return TOPFRAME;
  }
  CGAL_assertion_msg(false," determine_type: degenerate line.");
  return (Point_type)-1; // never come here
}

Point_2 epoint(const Standard_RT& m1, const Standard_RT& n1, 
                  const Standard_RT& m2, const Standard_RT& n2, 
                                 const Standard_RT& n3) const
{ return Point_2(m1,n1,m2,n2,n3); }

public:

Point_2 construct_point(const Standard_point_2& p) const
{ return Point_2(p.hx(), p.hy(), p.hw()); }

Point_2 construct_point(const Standard_line_2& l, Point_type& t) const
{
  t = determine_type(l);
  // TRACEN("construct_point(line)"<<l<<" "<<t);
  Point_2 res;
  switch (t) {
    case SWCORNER:   res = epoint(-1, 0, -1, 0, 1); break;
    case NWCORNER:   res = epoint(-1, 0,  1, 0, 1); break;
    case SECORNER:   res = epoint( 1, 0, -1, 0, 1); break; 
    case NECORNER:   res = epoint( 1, 0,  1, 0, 1); break;  
    case LEFTFRAME:  res = epoint(-l.b(), 0,  l.a(), -l.c(), l.b()); 
                     break; 
    case RIGHTFRAME: res = epoint( l.b(), 0, -l.a(), -l.c(), l.b()); 
                     break; 
    case BOTTOMFRAME: res = epoint( l.b(), -l.c(), -l.a(), 0, l.a()); 
                     break; 
    case TOPFRAME: res = epoint(-l.b(), -l.c(),  l.a(), 0, l.a()); 
                     break; 
    default: CGAL_assertion_msg(0,"EPoint type not correct!");
  }
  return res;
}

Point_2 construct_point(const Standard_point_2& p1, 
                        const Standard_point_2& p2, 
                        Point_type& t) const
{ return construct_point(Standard_line_2(p1,p2),t); }
Point_2 construct_point(const Standard_line_2& l) const
{ Point_type dummy; return construct_point(l,dummy); }
Point_2 construct_point(const Standard_point_2& p1, 
                        const Standard_point_2& p2) const
{ return construct_point(Standard_line_2(p1,p2)); }
Point_2 construct_point(const Standard_point_2& p, 
                        const Standard_direction_2& d) const
{ return construct_point(Standard_line_2(p,d)); }
Point_2 construct_opposite_point(const Standard_line_2& l) const
{ Point_type dummy; return construct_point(l.opposite(),dummy); }

Point_type type(const Point_2& p) const
{
  if (p.is_standard()) return STANDARD;
  // now we are on the square frame
  RT rx = p.hx();
  RT ry = p.hy();
  int sx = CGAL_NTS sign(rx);
  int sy = CGAL_NTS sign(ry);
  if (sx < 0) rx = -rx;
  if (sy < 0) ry = -ry;
  if (rx>ry) {
    if (sx > 0) return RIGHTFRAME;
    else        return LEFTFRAME;
  }
  if (rx<ry) {
    if (sy > 0) return TOPFRAME;
    else        return BOTTOMFRAME;
  }
  // now (rx == ry) 
  if (sx==sy) {
    if (sx < 0) return SWCORNER;
    else        return NECORNER;
  } else { CGAL_assertion(sx==-sy);
    if (sx < 0) return NWCORNER;
    else        return SECORNER;
  }
}


bool is_standard(const Point_2& p) const
{ return p.is_standard();  }

Standard_point_2 standard_point(const Point_2& p) const
{ CGAL_assertion(is_standard(p));
  return Standard_point_2(p.nx(),p.ny(),p.hw());
}

Standard_line_2 standard_line(const Point_2& p) const
{ CGAL_assertion(!p.is_standard());
  Standard_point_2 p0(p.nx(),p.ny(),p.hw());
  Standard_point_2 p1(p.mx()+p.nx(),p.my()+p.ny(),p.hw());
  return Standard_line_2(p0,p1);
}

Standard_ray_2 standard_ray(const Point_2& p) const
{ CGAL_assertion(!p.is_standard());
  Standard_line_2 l = standard_line(p);
  Standard_direction_2 d = l.direction();
  Standard_point_2 q = l.point(0);
  return Standard_ray_2(q,d);
}

Point_2 NE() const { return construct_point(Standard_line_2(-1, 1,0)); }
Point_2 SE() const { return construct_point(Standard_line_2( 1, 1,0)); }
Point_2 NW() const { return construct_point(Standard_line_2(-1,-1,0)); }
Point_2 SW() const { return construct_point(Standard_line_2( 1,-1,0)); }

int orientation(const Point_2& p1, const Point_2& p2, const Point_2& p3) 
const
{ CHECK(K.orientation(p1.checkrep(),p2.checkrep(),p3.checkrep()),
        CGAL::orientation(p1,p2,p3))
  return CGAL::orientation(p1,p2,p3); }

bool left_turn(const Point_2& p1, const Point_2& p2, const Point_2& p3) 
const
{ return orientation(p1,p2,p3) > 0; }

bool first_pair_closer_than_second(
  const Point_2& p1, const Point_2& p2, 
  const Point_2& p3, const Point_2& p4) const
{ CHECK(K.first_pair_closer_than_second(p1.checkrep(),p2.checkrep(),
                                        p3.checkrep(),p4.checkrep()),
        CGAL::compare_pair_dist(p1,p2,p3,p4)<0)
  return CGAL::compare_pair_dist(p1,p2,p3,p4)<0; }

int compare_xy(const Point_2& p1, const Point_2& p2) const
{ CHECK(K.compare_xy(p1.checkrep(),p2.checkrep()),
        CGAL::compare_xy(p1,p2))
  return CGAL::compare_xy(p1,p2); }

int compare_x(const Point_2& p1, const Point_2& p2) const
{ CHECK(K.compare_x(p1.checkrep(),p2.checkrep()),
        CGAL::compare_x(p1,p2))
  return CGAL::compare_x(p1,p2); }

int compare_y(const Point_2& p1, const Point_2& p2) const
{ CHECK(K.compare_y(p1.checkrep(),p2.checkrep()),
        CGAL::compare_y(p1,p2))
  return CGAL::compare_y(p1,p2); }

bool strictly_ordered_along_line(
  const Point_2& p1, const Point_2& p2, const Point_2& p3) const
{ CHECK(K.strictly_ordered_along_line(
          p1.checkrep(),p2.checkrep(),p3.checkrep()),
        CGAL::strictly_ordered_along_line(p1,p2,p3))
  return CGAL::strictly_ordered_along_line(p1,p2,p3); }


Segment_2 construct_segment(const Point_2& p, const Point_2& q) const
{ return Segment_2(p,q); }

Point_2 source(const Segment_2& s) const
{ return s.source(); }

Point_2 target(const Segment_2& s) const
{ return s.target(); }

bool is_degenerate(const Segment_2& s) const
{ return s.source()==s.target(); }

int orientation(const Segment_2& s, const Point_2& p) const
{ return orientation(s.source(),s.target(),p); }

Point_2 intersection(const Segment_2& s1, const Segment_2& s2) const
{ CHECK(CGAL::intersection(s1,s2).checkrep(),
        K.intersection(convert(s1),convert(s2)))
  return CGAL::intersection(s1,s2); }

bool contains(const Segment_2& s, const Point_2& p) const
/*{\Mop returns true iff |s| contains |p|.}*/
{ return CGAL::contains(s,p); }

Direction_2 construct_direction(
  const Point_2& p1, const Point_2& p2) const
{ return Direction_2(p1,p2); }

bool strictly_ordered_ccw(const Direction_2& d1, 
  const Direction_2& d2, const Direction_2& d3) const
{ CHECK(K.strictly_ordered_ccw(convert(d1),convert(d2),convert(d3)),
        CGAL::strictly_ordered_ccw(d1,d2,d3));
  return CGAL::strictly_ordered_ccw(d1,d2,d3); }

void print_statistics() const
{
  std::cout << "Statistics of filtered kernel:\n";
  std::cout << "total failed double filter stages = (now needs CGAL_PROFILE)\n";
  PRINT_CHECK_ENABLED;
  PRINT_STATISTICS(or2);
  PRINT_STATISTICS(or1);
  PRINT_STATISTICS(or0);
  PRINT_STATISTICS(cmpx1);
  PRINT_STATISTICS(cmpx0);
  PRINT_STATISTICS(cmpy1);
  PRINT_STATISTICS(cmpy0);
  PRINT_STATISTICS(cmppd2);
  PRINT_STATISTICS(cmppd1);
  PRINT_STATISTICS(cmppd0);
  PRINT_STATISTICS(ord2);
  PRINT_STATISTICS(ord1);
  PRINT_STATISTICS(ord0);
}

template <class Forward_iterator>
void determine_frame_radius(Forward_iterator start, Forward_iterator end,
                            Standard_RT& R0) const
{ Standard_RT R;
  while ( start != end ) {
    Point_2 p = *start;
    if ( is_standard(p) ) {
      R = CGAL_NTS max(CGAL_NTS abs(p.mx())/p.hw(), 
                       CGAL_NTS abs(p.my())/p.hw());
    } else {
      RT rx = CGAL_NTS abs(p.hx()), ry = CGAL_NTS abs(p.hy());
      if ( rx[1] > ry[1] )      R = CGAL_NTS abs(ry[0]-rx[0])/(rx[1]-ry[1]);
      else if ( rx[1] < ry[1] ) R = CGAL_NTS abs(rx[0]-ry[0])/(ry[1]-rx[1]);
      else /* rx[1] == ry[1] */ R = CGAL_NTS abs(rx[0]-ry[0])/(2*p.hw());
    }
    R0 = CGAL_NTS max(R+1,R0); ++start;
  }
}

const char* output_identifier() const 
{ return "Filtered_extended_homogeneous"; }


<<Filtered_extended_homogeneous.h>>=
<<CGAL EH Header>>
#ifndef CGAL_FILTERED_EXTENDED_HOMOGENEOUS_H
#define CGAL_FILTERED_EXTENDED_HOMOGENEOUS_H

#include <CGAL/basic.h>
#include <CGAL/Handle_for.h>
#include <CGAL/Interval_arithmetic.h>
#include <CGAL/Homogeneous.h>
#undef _DEBUG
#define _DEBUG 59
#include <CGAL/Nef_2/debug.h>

#define REDUCE_INTERSECTION_POINTS
//#define KERNEL_ANALYSIS
//#define KERNEL_CHECK

#ifdef  KERNEL_CHECK
#include <CGAL/Extended_homogeneous.h>
#define CHECK(c1,c2) CGAL_assertion((c1) == (c2));
#define PRINT_CHECK_ENABLED std::cout << "kernel check enabled!\n"
#else
#define CHECK(c1,c2)
#define PRINT_CHECK_ENABLED std::cout << "no kernel check!\n"
#endif

#ifdef KERNEL_ANALYSIS
#define DEFCOUNTER(c) \
  static int c##_total=0; static int c##_exception=0;
#define INCTOTAL(c) c##_total++
#define INCEXCEPTION(c) c##_exception++
#define PRINT_STATISTICS(c) \
std::cout << #c##" " << c##_exception << "/" << c##_total << std::endl
#else
#define DEFCOUNTER(c)
#define INCTOTAL(c)
#define INCEXCEPTION(c)
#define PRINT_STATISTICS(c)
#endif

namespace CGAL {
<<simple polynomials>>
<<extended points>>
<<orientation predicate>>
<<comparison predicate>>
<<extended segments>>
<<extended segment primitives>>
<<extended directions>>
<<direction predicates>>
<<extended kernel>>

} //namespace CGAL

#undef CHECK
#undef KERNEL_CHECK
#undef REDUCE_INTERSECTION_POINTS
#undef KERNEL_ANALYSIS
#undef COUNTER
#undef INCTOTAL
#undef INCEXCEPTION
#undef PRINT_STATISTICS
#undef PRINT_CHECK_ENABLED

#endif // CGAL_FILTERED_EXTENDED_HOMOGENEOUS_H

@ Within our extended point type we add conversion to the polynomial
based version.
<<point check ops>>=
#ifdef KERNEL_CHECK
typedef CGAL::Extended_homogeneous<RT_> CheckKernel;
typedef typename CheckKernel::Point_2   CheckPoint;
typedef typename CheckKernel::RT        CheckRT;

CheckRT convert(const CGAL::SPolynomial<RT_>& p) const
{ return CheckRT(p.n(),p.m()); }
CheckRT convert(const RT_& t) const
{ return CheckRT(t); }
CheckPoint checkrep() const
{ return CheckPoint(convert(hx()),convert(hy()),convert(w())); }

#endif // KERNEL_CHECK

<<kernel check ops>>=
#ifdef KERNEL_CHECK
typedef Extended_homogeneous<RT_>         CheckKernel;
typedef typename CheckKernel::Point_2     CheckPoint;
typedef typename CheckKernel::Direction_2 CheckDirection;
typedef typename CheckKernel::Segment_2   CheckSegment;
CheckKernel K;

CheckSegment convert(const Segment_2& s) const
{ return CheckSegment(s.source().checkrep(),
                      s.target().checkrep()); }
CheckDirection convert(const Direction_2& d) const
{ return K.construct_direction(d.p2().checkrep(),d.p1().checkrep()); }

#endif // KERNEL_CHECK



@ \begin{ignore}
<<CGAL EH Header>>=
// ============================================================================
//
// Copyright (c) 1997-2000 The CGAL Consortium
//
// This software and related documentation is part of an INTERNAL release
// of the Computational Geometry Algorithms Library (CGAL). It is not
// intended for general use.
//
// ----------------------------------------------------------------------------
//
// release       : $CGAL_Revision$
// release_date  : $CGAL_Date$
//
// file          : include/CGAL/Filtered_extended_homogeneous.h
// package       : Nef_2 
// chapter       : Nef Polyhedra
//
// source        : nef_2d/Filtered_extended_points.lw
// revision      : $Id$
// revision_date : $Date$
//
// author(s)     : Michael Seel <seel@mpi-sb.mpg.de>
// maintainer    : Michael Seel <seel@mpi-sb.mpg.de>
// coordinator   : Michael Seel <seel@mpi-sb.mpg.de>
//
// implementation: Filtered extended homogeneous kernel
// ============================================================================
@ \end{ignore}
\end{ignoreindiss}
%KILLSTART DISS REP
\bibliographystyle{alpha}
\bibliography{comp_geo,general,diss}
\newpage
\section{Appendix}
\input manpages/ExtendedKernelTraits_2.man
\end{document}
%KILLEND DISS REP

