\begin{ccRefClass} {Residue}
\label{Residue}

\def\ccTagOperatorLayout{\ccTrue}

\ccDefinition

The class \ccRefName\ represents a finite field $\Z{/p\Z}$, 
for some prime number $p$. \\

The prime number $p$ is stored in a static member variable. 
The class provides static member functions to change this value. 
{\bf Note that changing the prime invalidates already existing objects 
of this type.}
However, already existing objects do not lose their value with respect to the 
old prime and can be reused after restoring the old prime. 
Since the type is based on double 
arithmetic the prime is restricted to values less than $2^{26}$. 
The initial value of $p$ is 67111067. 
 
Please note that the implementation of class \ccc{CGAL::Residue} requires a mantissa 
precision according to the IEEE Standard for Floating-Point Arithmetic (IEEE 754). 
However, on some processors the traditional FPU uses an extended precision. Hence, it 
is  indispensable that the proper mantissa length is enforced before performing 
any arithmetic operations. Moreover, it is required that numbers are rounded to the 
next nearest value. This can be ensured using \ccc{CGAL::Protect_FPU_rounding} with 
\ccc{CGAL_FE_TONEAREST}, which also enforces the required precision as a side effect. 

In case the flag \ccc{CGAL_HAS_THREADS} 
is undefined the prime is just stored in a static member 
of the class, that is, \ccRefName\ is not thread-safe in this case.  
In case \ccc{CGAL_HAS_THREADS}
the implementation of the class is thread safe using 
\ccc{boost::thread_specific_ptr}. However, this may cause some performance 
penalty. Hence, it may be advisable to configure \ccc{CGAL} with 
\ccc{CGAL_HAS_NO_THREADS}. 

\ccInclude{CGAL/Residue.h}

\ccIsModel
\ccc{Field}\\


\ccCreation
\ccCreationVariable{x}

\ccConstructor{Residue();}
{introduces a variable \ccVar, which is initialized with zero;}
\ccGlue
\ccConstructor{Residue(const Residue& m);}
{copy constructor;}
\ccGlue
\ccConstructor{Residue(int i);}
{introduces a variable \ccVar, which is initialized with $i \%  p$;}
\ccGlue
\ccConstructor{Residue(long i);}
{introduces a variable \ccVar, which is initialized with $i \%  p$;}

\ccOperations

\ccMethod{static int set_current_prime(int p);}{ 
        Static member function;\\
        sets current prime to the given value and returns the old prime. }
\ccGlue
\ccMethod{static int get_current_prime();}{
        Static member function;\\
        returns the value of the current prime.      
    }
\ccGlue
\ccMethod{int  get_value() const;}{
        Returns the unique representative of \ccVar within the range 
        $[-p/2,p/2]$, where $p$ is the current prime. 
    }


\ccFunction{Residue operator+(Residue a);}{}\ccGlue
\ccFunction{Residue operator-(Residue a);}{}\ccGlue

\ccFunction{Residue operator+(Residue a,Residue b);}{}\ccGlue
\ccFunction{Residue operator-(Residue a,Residue b);}{}\ccGlue
\ccFunction{Residue operator*(Residue a,Residue b);}{}\ccGlue
\ccFunction{Residue operator/(Residue a,Residue b);}{}\ccGlue

\ccMethod{Residue & operator+=(Residue a);}{}\ccGlue
\ccMethod{Residue & operator-=(Residue a);}{}\ccGlue
\ccMethod{Residue & operator*=(Residue a);}{}\ccGlue
\ccMethod{Residue & operator/=(Residue a);}{}\ccGlue

\ccFunction{Residue operator==(Residue a,Residue b);}{}\ccGlue
\ccFunction{Residue operator!=(Residue a,Residue b);}{}\ccGlue


\end{ccRefClass} 
