% +------------------------------------------------------------------------+
% | Reference manual page: OptimalConvexPartitionTraits_2.tex
% +------------------------------------------------------------------------+
% | 10.05.2000   Susan Hert
% | Package: Partition_2
% | 
% |
% +------------------------------------------------------------------------+


\begin{ccRefConcept}{OptimalConvexPartitionTraits_2}
\ccIndexSubitemBegin[C]{optimal_convex_partition_2}{traits class}

\ccDefinition
  
Requirements of a traits class to be
used with the function \ccc{optimal_convex_partition_2} that computes
an optimal convex partition of a polygon.

\ccRefines

\ccRefConceptPage{PartitionTraits_2}%
\ccIndexMainItem[c]{PartitionTraits_2}

\ccTypes

\ccIndexMainItem[c]{PartitionTraits_2}
In addition to the types listed with the concept \ccc{PartitionTraits_2}, the
following types are required:

\ccNestedType{Segment_2}{A segment type}
\ccNestedType{Ray_2}{A ray type}
\ccNestedType{Object_2}{A general object type that can be either a point or a segment}
\ccNestedType{Construct_segment_2}{Function object type that provides
\ccc{Segment_2 operator()(Point_2 p, Point_2 q)}, which constructs and
returns the segment defined by the points $p$ and $q$.}
\ccNestedType{Construct_ray_2}{Function object type that provides
\ccc{Ray_2 operator()(Point_2 p, Point_2 q)}, which constructs and returns
the ray from point $p$ through point $q$.}
\ccNestedType{Collinear_are_ordered_along_line_2}{Predicate object type that
determines orderings of \ccc{Point_2}s on a line.  Must provide
\ccc{bool operator()(Point_2 p, Point_2 q, Point_2 r)} that 
returns \ccStyle{true}, iff \ccStyle{q} lies between \ccStyle{p}
and \ccStyle{r} and \ccc{p}, \ccc{q}, and \ccc{r} satisfy the precondition
that they are collinear.}

\ccNestedType{Are_stritcly_ordered_along_line_2}{Predicate object type that
determines orderings of \ccc{Point_2}s.  Must provide
\ccc{bool operator()(Point_2 p, Point_2 q, Point_2 r)} that 
returns \ccStyle{true}, iff the three points are collinear and 
\ccStyle{q} lies strictly between \ccStyle{p}
and \ccStyle{r}.  Note that \ccc{false} should be returned if
\ccStyle{q==p} or \ccStyle{q==r}.}

\ccNestedType{Intersect_2}{Function object type that provides
\ccc{Object_2 operator()(Segment_2 s1, Segment_2 s2)} that returns
the intersection of two segments (which may be either a segment or
a point).}

\ccNestedType{Assign_2}{Function object type that provides
\ccc{bool operator()(Segment_2 s1, Object_2 o)} that returns 
\ccc{true} if \ccc{o} is a segment and assigns the value of \ccc{o}
to \ccc{s1}; returns \ccc{false} otherwise.}

\ccCreationVariable{traits}  %% choose variable name
\ccCreation

Only a copy constructor is required.

\ccConstructor{OptimalConvexPartitionTraits_2(OptimalConvexPartitionTraits_2& tr
)}{}

\ccOperations

\ccIndexMainItem[c]{PartitionTraits_2}
In addition to the functions required by \ccc{PartitionTraits_2}, the following
functions that create instances of the above function object types
must exist:

\ccSetThreeColumns{Collinear_are_ordered_along_line_2xxxx}{traits.collinear_are_ordered_along_line_2_object()}{}
\ccMethod{Collinear_are_ordered_along_line_2 collinear_are_ordered_along_line_2_object() const;}{}
\ccMethod{Construct_segment_2 construct_segment_2_object() const;}{}
\ccMethod{Construct_ray_2 construct_ray_2_object() const;}{}
\ccMethod{Are_strictly_ordered_along_line_2
    are_strictly_ordered_along_line_2_object() const;}{}


\ccHasModels

%\ccc{Partition_optimal_convex_traits_2},
\ccRefIdfierPage{CGAL::Partition_traits_2<R>}

\ccSeeAlso

\ccRefIdfierPage{CGAL::convex_partition_is_valid_2} \\
\ccRefIdfierPage{CGAL::Partition_is_valid_traits_2<Traits, PolygonIsValid>}

\ccIndexSubitemEnd[C]{optimal_convex_partition_2}{traits class}
\end{ccRefConcept}

% +------------------------------------------------------------------------+
%%RefPage: end of main body, begin of footer
% EOF
% +------------------------------------------------------------------------+

